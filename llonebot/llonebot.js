import * as path from "node:path";
import path__default, { resolve } from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import require$$0$5 from "os";
import require$$1$1 from "tty";
import * as fs from "node:fs";
import fs__default, { appendFile, statSync, existsSync, mkdirSync } from "node:fs";
import * as os from "node:os";
import os__default from "node:os";
import fs$1 from "fs";
import fsPromise, { unlink, stat, access, copyFile, writeFile, readFile } from "node:fs/promises";
import crypto$1, { randomUUID, createHash } from "node:crypto";
import { WebSocket as WebSocket$1, WebSocketServer } from "ws";
import require$$4$1, { gzipSync, deflateSync } from "node:zlib";
import require$$1$2 from "path";
import require$$1$3 from "util";
import require$$2$2 from "events";
import require$$0$6 from "child_process";
import require$$2$1 from "stream";
import require$$0$8 from "debug";
import require$$0$7 from "buffer";
import require$$1$4 from "string_decoder";
import require$$1$6 from "node:events";
import require$$0$9, { fileURLToPath as fileURLToPath$1 } from "url";
import require$$2$3 from "node:http";
import require$$0$a from "crypto";
import require$$6$1 from "querystring";
import require$$1$5 from "node:net";
import require$$8 from "ms";
import * as fileType from "file-type";
import { promisify, isDeepStrictEqual } from "node:util";
import { isSilk, isWav, getWavFileInfo, encode, getDuration, decode } from "silk-wasm";
import fsPromise$1, { unlink as unlink$1 } from "fs/promises";
import { createRequire } from "node:module";
import init from "@minatojs/sql.js";
import https from "node:https";
var __defProp$c = Object.defineProperty;
var __name$c = (target, value) => __defProp$c(target, "name", { value, configurable: true });
function noop() {
}
__name$c(noop, "noop");
function isNullable(value) {
  return value === null || value === void 0;
}
__name$c(isNullable, "isNullable");
function isNonNullable(value) {
  return !isNullable(value);
}
__name$c(isNonNullable, "isNonNullable");
function isPlainObject(data) {
  return data && typeof data === "object" && !Array.isArray(data);
}
__name$c(isPlainObject, "isPlainObject");
function filterKeys(object, filter) {
  return Object.fromEntries(Object.entries(object).filter(([key2, value]) => filter(key2, value)));
}
__name$c(filterKeys, "filterKeys");
function mapValues(object, transform) {
  return Object.fromEntries(Object.entries(object).map(([key2, value]) => [key2, transform(value, key2)]));
}
__name$c(mapValues, "mapValues");
function pick(source2, keys, forced) {
  if (!keys) return { ...source2 };
  const result = {};
  for (const key2 of keys) {
    if (forced || source2[key2] !== void 0) result[key2] = source2[key2];
  }
  return result;
}
__name$c(pick, "pick");
function omit(source2, keys) {
  if (!keys) return { ...source2 };
  const result = { ...source2 };
  for (const key2 of keys) {
    Reflect.deleteProperty(result, key2);
  }
  return result;
}
__name$c(omit, "omit");
function defineProperty(object, key2, value) {
  return Object.defineProperty(object, key2, { writable: true, value, enumerable: false });
}
__name$c(defineProperty, "defineProperty");
function contain(array1, array2) {
  return array2.every((item) => array1.includes(item));
}
__name$c(contain, "contain");
function intersection(array1, array2) {
  return array1.filter((item) => array2.includes(item));
}
__name$c(intersection, "intersection");
function difference(array1, array2) {
  return array1.filter((item) => !array2.includes(item));
}
__name$c(difference, "difference");
function union(array1, array2) {
  return Array.from(/* @__PURE__ */ new Set([...array1, ...array2]));
}
__name$c(union, "union");
function deduplicate(array) {
  return [...new Set(array)];
}
__name$c(deduplicate, "deduplicate");
function remove(list, item) {
  const index = list?.indexOf(item);
  if (index >= 0) {
    list.splice(index, 1);
    return true;
  } else {
    return false;
  }
}
__name$c(remove, "remove");
function makeArray(source2) {
  return Array.isArray(source2) ? source2 : isNullable(source2) ? [] : [source2];
}
__name$c(makeArray, "makeArray");
function is(type2, value) {
  if (arguments.length === 1) return (value2) => is(type2, value2);
  return type2 in globalThis && value instanceof globalThis[type2] || Object.prototype.toString.call(value).slice(8, -1) === type2;
}
__name$c(is, "is");
function isArrayBufferLike(value) {
  return is("ArrayBuffer", value) || is("SharedArrayBuffer", value);
}
__name$c(isArrayBufferLike, "isArrayBufferLike");
function isArrayBufferSource(value) {
  return isArrayBufferLike(value) || ArrayBuffer.isView(value);
}
__name$c(isArrayBufferSource, "isArrayBufferSource");
var Binary;
((Binary2) => {
  Binary2.is = isArrayBufferLike;
  Binary2.isSource = isArrayBufferSource;
  function fromSource(source2) {
    if (ArrayBuffer.isView(source2)) {
      return source2.buffer.slice(source2.byteOffset, source2.byteOffset + source2.byteLength);
    } else {
      return source2;
    }
  }
  Binary2.fromSource = fromSource;
  __name$c(fromSource, "fromSource");
  function toBase64(source2) {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(source2).toString("base64");
    }
    let binary = "";
    const bytes2 = new Uint8Array(source2);
    for (let i = 0; i < bytes2.byteLength; i++) {
      binary += String.fromCharCode(bytes2[i]);
    }
    return btoa(binary);
  }
  Binary2.toBase64 = toBase64;
  __name$c(toBase64, "toBase64");
  function fromBase64(source2) {
    if (typeof Buffer !== "undefined") return fromSource(Buffer.from(source2, "base64"));
    return Uint8Array.from(atob(source2), (c2) => c2.charCodeAt(0));
  }
  Binary2.fromBase64 = fromBase64;
  __name$c(fromBase64, "fromBase64");
  function toHex(source2) {
    if (typeof Buffer !== "undefined") return Buffer.from(source2).toString("hex");
    return Array.from(new Uint8Array(source2), (byte) => byte.toString(16).padStart(2, "0")).join("");
  }
  Binary2.toHex = toHex;
  __name$c(toHex, "toHex");
  function fromHex(source2) {
    if (typeof Buffer !== "undefined") return fromSource(Buffer.from(source2, "hex"));
    const hex = source2.length % 2 === 0 ? source2 : source2.slice(0, source2.length - 1);
    const buffer2 = [];
    for (let i = 0; i < hex.length; i += 2) {
      buffer2.push(parseInt(`${hex[i]}${hex[i + 1]}`, 16));
    }
    return Uint8Array.from(buffer2).buffer;
  }
  Binary2.fromHex = fromHex;
  __name$c(fromHex, "fromHex");
})(Binary || (Binary = {}));
Binary.fromBase64;
Binary.toBase64;
Binary.fromHex;
Binary.toHex;
function clone(source2, refs = /* @__PURE__ */ new Map()) {
  if (!source2 || typeof source2 !== "object") return source2;
  if (is("Date", source2)) return new Date(source2.valueOf());
  if (is("RegExp", source2)) return new RegExp(source2.source, source2.flags);
  if (isArrayBufferLike(source2)) return source2.slice(0);
  if (ArrayBuffer.isView(source2)) return source2.buffer.slice(source2.byteOffset, source2.byteOffset + source2.byteLength);
  const cached = refs.get(source2);
  if (cached) return cached;
  if (Array.isArray(source2)) {
    const result2 = [];
    refs.set(source2, result2);
    source2.forEach((value, index) => {
      result2[index] = Reflect.apply(clone, null, [value, refs]);
    });
    return result2;
  }
  const result = Object.create(Object.getPrototypeOf(source2));
  refs.set(source2, result);
  for (const key2 of Reflect.ownKeys(source2)) {
    const descriptor = { ...Reflect.getOwnPropertyDescriptor(source2, key2) };
    if ("value" in descriptor) {
      descriptor.value = Reflect.apply(clone, null, [descriptor.value, refs]);
    }
    Reflect.defineProperty(result, key2, descriptor);
  }
  return result;
}
__name$c(clone, "clone");
function deepEqual(a, b, strict) {
  if (a === b) return true;
  if (!strict && isNullable(a) && isNullable(b)) return true;
  if (typeof a !== typeof b) return false;
  if (typeof a !== "object") return false;
  if (!a || !b) return false;
  function check(test, then) {
    return test(a) ? test(b) ? then(a, b) : false : test(b) ? false : void 0;
  }
  __name$c(check, "check");
  return check(Array.isArray, (a2, b2) => a2.length === b2.length && a2.every((item, index) => deepEqual(item, b2[index]))) ?? check(is("Date"), (a2, b2) => a2.valueOf() === b2.valueOf()) ?? check(is("RegExp"), (a2, b2) => a2.source === b2.source && a2.flags === b2.flags) ?? check(isArrayBufferLike, (a2, b2) => {
    if (a2.byteLength !== b2.byteLength) return false;
    const viewA = new Uint8Array(a2);
    const viewB = new Uint8Array(b2);
    for (let i = 0; i < viewA.length; i++) {
      if (viewA[i] !== viewB[i]) return false;
    }
    return true;
  }) ?? Object.keys({ ...a, ...b }).every((key2) => deepEqual(a[key2], b[key2], strict));
}
__name$c(deepEqual, "deepEqual");
function capitalize(source2) {
  return source2.charAt(0).toUpperCase() + source2.slice(1);
}
__name$c(capitalize, "capitalize");
function uncapitalize(source2) {
  return source2.charAt(0).toLowerCase() + source2.slice(1);
}
__name$c(uncapitalize, "uncapitalize");
function camelCase(source2) {
  return source2.replace(/[_-][a-z]/g, (str) => str.slice(1).toUpperCase());
}
__name$c(camelCase, "camelCase");
function tokenize(source2, delimiters, delimiter) {
  const output2 = [];
  let state = 0;
  for (let i = 0; i < source2.length; i++) {
    const code = source2.charCodeAt(i);
    if (code >= 65 && code <= 90) {
      if (state === 1) {
        const next = source2.charCodeAt(i + 1);
        if (next >= 97 && next <= 122) {
          output2.push(delimiter);
        }
        output2.push(code + 32);
      } else {
        if (state !== 0) {
          output2.push(delimiter);
        }
        output2.push(code + 32);
      }
      state = 1;
    } else if (code >= 97 && code <= 122) {
      output2.push(code);
      state = 2;
    } else if (delimiters.includes(code)) {
      if (state !== 0) {
        output2.push(delimiter);
      }
      state = 0;
    } else {
      output2.push(code);
    }
  }
  return String.fromCharCode(...output2);
}
__name$c(tokenize, "tokenize");
function paramCase(source2) {
  return tokenize(source2, [45, 95], 45);
}
__name$c(paramCase, "paramCase");
function snakeCase(source2) {
  return tokenize(source2, [45, 95], 95);
}
__name$c(snakeCase, "snakeCase");
var camelize = camelCase;
var hyphenate = paramCase;
function formatProperty(key2) {
  if (typeof key2 !== "string") return `[${key2.toString()}]`;
  return /^[a-z_$][\w$]*$/i.test(key2) ? `.${key2}` : `[${JSON.stringify(key2)}]`;
}
__name$c(formatProperty, "formatProperty");
function trimSlash(source2) {
  return source2.replace(/\/$/, "");
}
__name$c(trimSlash, "trimSlash");
function sanitize(source2) {
  if (!source2.startsWith("/")) source2 = "/" + source2;
  return trimSlash(source2);
}
__name$c(sanitize, "sanitize");
var Time;
((Time2) => {
  Time2.millisecond = 1;
  Time2.second = 1e3;
  Time2.minute = Time2.second * 60;
  Time2.hour = Time2.minute * 60;
  Time2.day = Time2.hour * 24;
  Time2.week = Time2.day * 7;
  let timezoneOffset = (/* @__PURE__ */ new Date()).getTimezoneOffset();
  function setTimezoneOffset(offset) {
    timezoneOffset = offset;
  }
  Time2.setTimezoneOffset = setTimezoneOffset;
  __name$c(setTimezoneOffset, "setTimezoneOffset");
  function getTimezoneOffset() {
    return timezoneOffset;
  }
  Time2.getTimezoneOffset = getTimezoneOffset;
  __name$c(getTimezoneOffset, "getTimezoneOffset");
  function getDateNumber(date = /* @__PURE__ */ new Date(), offset) {
    if (typeof date === "number") date = new Date(date);
    if (offset === void 0) offset = timezoneOffset;
    return Math.floor((date.valueOf() / Time2.minute - offset) / 1440);
  }
  Time2.getDateNumber = getDateNumber;
  __name$c(getDateNumber, "getDateNumber");
  function fromDateNumber(value, offset) {
    const date = new Date(value * Time2.day);
    if (offset === void 0) offset = timezoneOffset;
    return new Date(+date + offset * Time2.minute);
  }
  Time2.fromDateNumber = fromDateNumber;
  __name$c(fromDateNumber, "fromDateNumber");
  const numeric = /\d+(?:\.\d+)?/.source;
  const timeRegExp = new RegExp(`^${[
    "w(?:eek(?:s)?)?",
    "d(?:ay(?:s)?)?",
    "h(?:our(?:s)?)?",
    "m(?:in(?:ute)?(?:s)?)?",
    "s(?:ec(?:ond)?(?:s)?)?"
  ].map((unit) => `(${numeric}${unit})?`).join("")}$`);
  function parseTime(source2) {
    const capture = timeRegExp.exec(source2);
    if (!capture) return 0;
    return (parseFloat(capture[1]) * Time2.week || 0) + (parseFloat(capture[2]) * Time2.day || 0) + (parseFloat(capture[3]) * Time2.hour || 0) + (parseFloat(capture[4]) * Time2.minute || 0) + (parseFloat(capture[5]) * Time2.second || 0);
  }
  Time2.parseTime = parseTime;
  __name$c(parseTime, "parseTime");
  function parseDate(date) {
    const parsed = parseTime(date);
    if (parsed) {
      date = Date.now() + parsed;
    } else if (/^\d{1,2}(:\d{1,2}){1,2}$/.test(date)) {
      date = `${(/* @__PURE__ */ new Date()).toLocaleDateString()}-${date}`;
    } else if (/^\d{1,2}-\d{1,2}-\d{1,2}(:\d{1,2}){1,2}$/.test(date)) {
      date = `${(/* @__PURE__ */ new Date()).getFullYear()}-${date}`;
    }
    return date ? new Date(date) : /* @__PURE__ */ new Date();
  }
  Time2.parseDate = parseDate;
  __name$c(parseDate, "parseDate");
  function format(ms) {
    const abs2 = Math.abs(ms);
    if (abs2 >= Time2.day - Time2.hour / 2) {
      return Math.round(ms / Time2.day) + "d";
    } else if (abs2 >= Time2.hour - Time2.minute / 2) {
      return Math.round(ms / Time2.hour) + "h";
    } else if (abs2 >= Time2.minute - Time2.second / 2) {
      return Math.round(ms / Time2.minute) + "m";
    } else if (abs2 >= Time2.second) {
      return Math.round(ms / Time2.second) + "s";
    }
    return ms + "ms";
  }
  Time2.format = format;
  __name$c(format, "format");
  function toDigits(source2, length = 2) {
    return source2.toString().padStart(length, "0");
  }
  Time2.toDigits = toDigits;
  __name$c(toDigits, "toDigits");
  function template(template2, time = /* @__PURE__ */ new Date()) {
    return template2.replace("yyyy", time.getFullYear().toString()).replace("yy", time.getFullYear().toString().slice(2)).replace("MM", toDigits(time.getMonth() + 1)).replace("dd", toDigits(time.getDate())).replace("hh", toDigits(time.getHours())).replace("mm", toDigits(time.getMinutes())).replace("ss", toDigits(time.getSeconds())).replace("SSS", toDigits(time.getMilliseconds(), 3));
  }
  Time2.template = template;
  __name$c(template, "template");
})(Time || (Time = {}));
var __defProp$b = Object.defineProperty;
var __name$b = (target, value) => __defProp$b(target, "name", { value, configurable: true });
var symbols = {
  // internal symbols
  shadow: Symbol.for("cordis.shadow"),
  receiver: Symbol.for("cordis.receiver"),
  original: Symbol.for("cordis.original"),
  // context symbols
  store: Symbol.for("cordis.store"),
  events: Symbol.for("cordis.events"),
  static: Symbol.for("cordis.static"),
  filter: Symbol.for("cordis.filter"),
  expose: Symbol.for("cordis.expose"),
  isolate: Symbol.for("cordis.isolate"),
  internal: Symbol.for("cordis.internal"),
  intercept: Symbol.for("cordis.intercept"),
  // service symbols
  setup: Symbol.for("cordis.setup"),
  invoke: Symbol.for("cordis.invoke"),
  extend: Symbol.for("cordis.extend"),
  tracker: Symbol.for("cordis.tracker"),
  provide: Symbol.for("cordis.provide"),
  immediate: Symbol.for("cordis.immediate")
};
var GeneratorFunction = function* () {
}.constructor;
var AsyncGeneratorFunction = async function* () {
}.constructor;
function isConstructor(func) {
  if (!func.prototype) return false;
  if (func instanceof GeneratorFunction) return false;
  if (AsyncGeneratorFunction !== Function && func instanceof AsyncGeneratorFunction) return false;
  return true;
}
__name$b(isConstructor, "isConstructor");
function resolveConfig(plugin, config) {
  const schema = plugin["Config"] || plugin["schema"];
  if (schema && plugin["schema"] !== false) config = schema(config);
  return config ?? {};
}
__name$b(resolveConfig, "resolveConfig");
function isUnproxyable(value) {
  return [Map, Set, Date, Promise].some((constructor) => value instanceof constructor);
}
__name$b(isUnproxyable, "isUnproxyable");
function joinPrototype(proto1, proto2) {
  if (proto1 === Object.prototype) return proto2;
  const result = Object.create(joinPrototype(Object.getPrototypeOf(proto1), proto2));
  for (const key2 of Reflect.ownKeys(proto1)) {
    Object.defineProperty(result, key2, Object.getOwnPropertyDescriptor(proto1, key2));
  }
  return result;
}
__name$b(joinPrototype, "joinPrototype");
function isObject(value) {
  return value && (typeof value === "object" || typeof value === "function");
}
__name$b(isObject, "isObject");
function getTraceable(ctx, value, noTrap) {
  if (!isObject(value)) return value;
  if (Object.hasOwn(value, symbols.shadow)) {
    return Object.getPrototypeOf(value);
  }
  const tracker = value[symbols.tracker];
  if (!tracker) return value;
  return createTraceable(ctx, value, tracker, noTrap);
}
__name$b(getTraceable, "getTraceable");
function withProps(target, props) {
  if (!props) return target;
  return new Proxy(target, {
    get: /* @__PURE__ */ __name$b((target2, prop, receiver) => {
      if (prop in props && prop !== "constructor") return Reflect.get(props, prop, receiver);
      return Reflect.get(target2, prop, receiver);
    }, "get"),
    set: /* @__PURE__ */ __name$b((target2, prop, value, receiver) => {
      if (prop in props && prop !== "constructor") return Reflect.set(props, prop, value, receiver);
      return Reflect.set(target2, prop, value, receiver);
    }, "set")
  });
}
__name$b(withProps, "withProps");
function withProp(target, prop, value) {
  return withProps(target, Object.defineProperty(/* @__PURE__ */ Object.create(null), prop, {
    value,
    writable: false
  }));
}
__name$b(withProp, "withProp");
function createShadow(ctx, target, property, receiver) {
  if (!property) return receiver;
  const origin = Reflect.getOwnPropertyDescriptor(target, property)?.value;
  if (!origin) return receiver;
  return withProp(receiver, property, ctx.extend({ [symbols.shadow]: origin }));
}
__name$b(createShadow, "createShadow");
function createShadowMethod(ctx, value, outer, shadow) {
  return new Proxy(value, {
    apply: /* @__PURE__ */ __name$b((target, thisArg, args) => {
      if (thisArg === outer) thisArg = shadow;
      args = args.map((arg) => {
        if (typeof arg !== "function" || arg[symbols.original]) return arg;
        return new Proxy(arg, {
          get: /* @__PURE__ */ __name$b((target2, prop, receiver) => {
            if (prop === symbols.original) return target2;
            const value2 = Reflect.get(target2, prop, receiver);
            if (prop === "toString" && value2 === Function.prototype.toString) {
              return function(...args2) {
                return Reflect.apply(value2, this === receiver ? target2 : this, args2);
              };
            }
            return value2;
          }, "get"),
          apply: /* @__PURE__ */ __name$b((target2, thisArg2, args2) => {
            return Reflect.apply(target2, getTraceable(ctx, thisArg2), args2.map((arg2) => getTraceable(ctx, arg2)));
          }, "apply"),
          construct: /* @__PURE__ */ __name$b((target2, args2, newTarget) => {
            return Reflect.construct(target2, args2.map((arg2) => getTraceable(ctx, arg2)), newTarget);
          }, "construct")
        });
      });
      return getTraceable(ctx, Reflect.apply(target, thisArg, args));
    }, "apply")
  });
}
__name$b(createShadowMethod, "createShadowMethod");
function createTraceable(ctx, value, tracker, noTrap) {
  if (ctx[symbols.shadow]) {
    ctx = Object.getPrototypeOf(ctx);
  }
  const proxy = new Proxy(value, {
    get: /* @__PURE__ */ __name$b((target, prop, receiver) => {
      if (prop === symbols.original) return target;
      if (prop === tracker.property) return ctx;
      if (typeof prop === "symbol") {
        return Reflect.get(target, prop, receiver);
      }
      if (tracker.associate && ctx[symbols.internal][`${tracker.associate}.${prop}`]) {
        return Reflect.get(ctx, `${tracker.associate}.${prop}`, withProp(ctx, symbols.receiver, receiver));
      }
      const shadow = createShadow(ctx, target, tracker.property, receiver);
      const innerValue = Reflect.get(target, prop, shadow);
      const innerTracker = innerValue?.[symbols.tracker];
      if (innerTracker) {
        return createTraceable(ctx, innerValue, innerTracker);
      } else if (!noTrap && typeof innerValue === "function") {
        return createShadowMethod(ctx, innerValue, receiver, shadow);
      } else {
        return innerValue;
      }
    }, "get"),
    set: /* @__PURE__ */ __name$b((target, prop, value2, receiver) => {
      if (prop === symbols.original) return false;
      if (prop === tracker.property) return false;
      if (typeof prop === "symbol") {
        return Reflect.set(target, prop, value2, receiver);
      }
      if (tracker.associate && ctx[symbols.internal][`${tracker.associate}.${prop}`]) {
        return Reflect.set(ctx, `${tracker.associate}.${prop}`, value2, withProp(ctx, symbols.receiver, receiver));
      }
      const shadow = createShadow(ctx, target, tracker.property, receiver);
      return Reflect.set(target, prop, value2, shadow);
    }, "set"),
    apply: /* @__PURE__ */ __name$b((target, thisArg, args) => {
      return applyTraceable(proxy, target, thisArg, args);
    }, "apply")
  });
  return proxy;
}
__name$b(createTraceable, "createTraceable");
function applyTraceable(proxy, value, thisArg, args) {
  if (!value[symbols.invoke]) return Reflect.apply(value, thisArg, args);
  return value[symbols.invoke].apply(proxy, args);
}
__name$b(applyTraceable, "applyTraceable");
function createCallable(name, proto, tracker) {
  const self2 = /* @__PURE__ */ __name$b(function(...args) {
    const proxy = createTraceable(self2["ctx"], self2, tracker);
    return applyTraceable(proxy, self2, this, args);
  }, "self");
  defineProperty(self2, "name", name);
  return Object.setPrototypeOf(self2, proto);
}
__name$b(createCallable, "createCallable");
var ReflectService = class _ReflectService {
  constructor(ctx) {
    this.ctx = ctx;
    defineProperty(this, symbols.tracker, {
      associate: "reflect",
      property: "ctx"
    });
    this._mixin("reflect", ["get", "set", "provide", "accessor", "mixin", "alias"]);
    this._mixin("scope", ["config", "runtime", "effect", "collect", "accept", "decline"]);
    this._mixin("registry", ["using", "inject", "plugin"]);
    this._mixin("lifecycle", ["on", "once", "parallel", "emit", "serial", "bail", "start", "stop"]);
  }
  static {
    __name$b(this, "ReflectService");
  }
  static resolveInject(ctx, name) {
    let internal2 = ctx[symbols.internal][name];
    while (internal2?.type === "alias") {
      name = internal2.name;
      internal2 = ctx[symbols.internal][name];
    }
    return [name, internal2];
  }
  static checkInject(ctx, name, error) {
    ctx = ctx[symbols.shadow] ?? ctx;
    if (["prototype", "then", "registry", "lifecycle"].includes(name)) return;
    if (name[0] === "$" || name[0] === "_") return;
    if (!ctx.runtime.plugin) return;
    if (ctx.bail(ctx, "internal/inject", name)) return;
    const lines = error.stack.split("\n");
    lines.splice(1, 1);
    error.stack = lines.join("\n");
    ctx.emit(ctx, "internal/warning", error);
  }
  static handler = {
    get: /* @__PURE__ */ __name$b((target, prop, ctx) => {
      if (typeof prop !== "string") return Reflect.get(target, prop, ctx);
      if (Reflect.has(target, prop)) {
        return getTraceable(ctx, Reflect.get(target, prop, ctx), true);
      }
      const [name, internal2] = _ReflectService.resolveInject(target, prop);
      const error = new Error(`property ${name} is not registered, declare it as \`inject\` to suppress this warning`);
      if (!internal2) {
        _ReflectService.checkInject(ctx, name, error);
        return Reflect.get(target, name, ctx);
      } else if (internal2.type === "accessor") {
        return internal2.get.call(ctx, ctx[symbols.receiver]);
      } else {
        if (!internal2.builtin) _ReflectService.checkInject(ctx, name, error);
        return ctx.reflect.get(name);
      }
    }, "get"),
    set: /* @__PURE__ */ __name$b((target, prop, value, ctx) => {
      if (typeof prop !== "string") return Reflect.set(target, prop, value, ctx);
      const [name, internal2] = _ReflectService.resolveInject(target, prop);
      if (!internal2) {
        return Reflect.set(target, name, value, ctx);
      }
      if (internal2.type === "accessor") {
        if (!internal2.set) return false;
        return internal2.set.call(ctx, value, ctx[symbols.receiver]);
      } else {
        ctx.reflect.set(name, value);
        return true;
      }
    }, "set"),
    has: /* @__PURE__ */ __name$b((target, prop) => {
      if (typeof prop !== "string") return Reflect.has(target, prop);
      if (Reflect.has(target, prop)) return true;
      const [, internal2] = _ReflectService.resolveInject(target, prop);
      return !!internal2;
    }, "has")
  };
  get(name) {
    const internal2 = this.ctx[symbols.internal][name];
    if (internal2?.type !== "service") return;
    const key2 = this.ctx[symbols.isolate][name];
    const value = this.ctx[symbols.store][key2]?.value;
    return getTraceable(this.ctx, value);
  }
  set(name, value) {
    this.provide(name);
    const key2 = this.ctx[symbols.isolate][name];
    const oldValue = this.ctx[symbols.store][key2]?.value;
    value ??= void 0;
    let dispose = /* @__PURE__ */ __name$b(() => {
    }, "dispose");
    if (oldValue === value) return dispose;
    if (!isNullable(value) && !isNullable(oldValue)) {
      throw new Error(`service ${name} has been registered`);
    }
    const ctx = this.ctx;
    if (!isNullable(value)) {
      dispose = ctx.effect(() => () => {
        ctx.set(name, void 0);
      });
    }
    if (isUnproxyable(value)) {
      ctx.emit(ctx, "internal/warning", new Error(`service ${name} is an unproxyable object, which may lead to unexpected behavior`));
    }
    const self2 = Object.create(ctx);
    self2[symbols.filter] = (ctx2) => {
      return ctx[symbols.isolate][name] === ctx2[symbols.isolate][name];
    };
    ctx.emit(self2, "internal/before-service", name, value);
    ctx[symbols.store][key2] = { value, source: ctx };
    ctx.emit(self2, "internal/service", name, oldValue);
    return dispose;
  }
  provide(name, value, builtin) {
    const internal2 = this.ctx.root[symbols.internal];
    if (name in internal2) return;
    const key2 = Symbol(name);
    internal2[name] = { type: "service", builtin };
    this.ctx.root[symbols.isolate][name] = key2;
    if (!isObject(value)) return;
    this.ctx[symbols.store][key2] = { value, source: null };
    defineProperty(value, symbols.tracker, {
      associate: name,
      property: "ctx"
    });
  }
  _accessor(name, options) {
    const internal2 = this.ctx.root[symbols.internal];
    if (name in internal2) return () => {
    };
    internal2[name] = { type: "accessor", ...options };
    return () => delete this.ctx.root[symbols.isolate][name];
  }
  accessor(name, options) {
    this.ctx.scope.effect(() => {
      return this._accessor(name, options);
    });
  }
  alias(name, aliases) {
    const internal2 = this.ctx.root[symbols.internal];
    if (name in internal2) return;
    for (const key2 of aliases) {
      internal2[key2] ||= { type: "alias", name };
    }
  }
  _mixin(source2, mixins) {
    const entries = Array.isArray(mixins) ? mixins.map((key2) => [key2, key2]) : Object.entries(mixins);
    const getTarget = typeof source2 === "string" ? (ctx) => ctx[source2] : () => source2;
    const disposables = entries.map(([key2, value]) => {
      return this._accessor(value, {
        get(receiver) {
          const service2 = getTarget(this);
          if (isNullable(service2)) return service2;
          const mixin = receiver ? withProps(receiver, service2) : service2;
          const value2 = Reflect.get(service2, key2, mixin);
          if (typeof value2 !== "function") return value2;
          return value2.bind(mixin ?? service2);
        },
        set(value2, receiver) {
          const service2 = getTarget(this);
          const mixin = receiver ? withProps(receiver, service2) : service2;
          return Reflect.set(service2, key2, value2, mixin);
        }
      });
    });
    return () => disposables.forEach((dispose) => dispose());
  }
  mixin(source2, mixins) {
    this.ctx.scope.effect(() => {
      return this._mixin(source2, mixins);
    });
  }
  trace(value) {
    return getTraceable(this.ctx, value);
  }
  bind(callback) {
    return new Proxy(callback, {
      apply: /* @__PURE__ */ __name$b((target, thisArg, args) => {
        return target.apply(this.trace(thisArg), args.map((arg) => this.trace(arg)));
      }, "apply")
    });
  }
};
var reflect_default = ReflectService;
function isBailed(value) {
  return value !== null && value !== false && value !== void 0;
}
__name$b(isBailed, "isBailed");
var Lifecycle = class {
  constructor(ctx) {
    this.ctx = ctx;
    defineProperty(this, symbols.tracker, {
      associate: "lifecycle",
      property: "ctx"
    });
    defineProperty(this.on("internal/listener", function(name, listener, options) {
      const method = options.prepend ? "unshift" : "push";
      if (name === "ready") {
        if (!this.lifecycle.isActive) return;
        this.scope.ensure(async () => listener());
        return () => false;
      } else if (name === "dispose") {
        this.scope.disposables[method](listener);
        defineProperty(listener, "name", "event <dispose>");
        return () => remove(this.scope.disposables, listener);
      } else if (name === "fork") {
        this.scope.runtime.forkables[method](listener);
        return this.scope.collect("event <fork>", () => remove(this.scope.runtime.forkables, listener));
      }
    }), Context.static, ctx.scope);
    for (const level of ["info", "error", "warning"]) {
      defineProperty(this.on(`internal/${level}`, (format, ...param) => {
        if (this._hooks[`internal/${level}`].length > 1) return;
        console.info(format, ...param);
      }), Context.static, ctx.scope);
    }
    defineProperty(this.on("internal/before-service", function(name) {
      for (const runtime of this.registry.values()) {
        if (!runtime.inject[name]?.required) continue;
        const scopes = runtime.isReusable ? runtime.children : [runtime];
        for (const scope of scopes) {
          if (!this[symbols.filter](scope.ctx)) continue;
          scope.updateStatus();
          scope.reset();
        }
      }
    }, { global: true }), Context.static, ctx.scope);
    defineProperty(this.on("internal/service", function(name) {
      for (const runtime of this.registry.values()) {
        if (!runtime.inject[name]?.required) continue;
        const scopes = runtime.isReusable ? runtime.children : [runtime];
        for (const scope of scopes) {
          if (!this[symbols.filter](scope.ctx)) continue;
          scope.start();
        }
      }
    }, { global: true }), Context.static, ctx.scope);
    const checkInject = /* @__PURE__ */ __name$b((scope, name) => {
      if (!scope.runtime.plugin) return false;
      for (const key2 in scope.runtime.inject) {
        if (name === reflect_default.resolveInject(scope.ctx, key2)[0]) return true;
      }
      return checkInject(scope.parent.scope, name);
    }, "checkInject");
    defineProperty(this.on("internal/inject", function(name) {
      return checkInject(this.scope, name);
    }, { global: true }), Context.static, ctx.scope);
  }
  static {
    __name$b(this, "Lifecycle");
  }
  isActive = false;
  _tasks = /* @__PURE__ */ new Set();
  _hooks = {};
  async flush() {
    while (this._tasks.size) {
      await Promise.all(Array.from(this._tasks));
    }
  }
  filterHooks(hooks, thisArg) {
    thisArg = getTraceable(this.ctx, thisArg);
    return hooks.slice().filter((hook) => {
      const filter = thisArg?.[Context.filter];
      return hook.global || !filter || filter.call(thisArg, hook.ctx);
    });
  }
  *dispatch(type2, args) {
    const thisArg = typeof args[0] === "object" || typeof args[0] === "function" ? args.shift() : null;
    const name = args.shift();
    if (name !== "internal/event") {
      this.emit("internal/event", type2, name, args, thisArg);
    }
    for (const hook of this.filterHooks(this._hooks[name] || [], thisArg)) {
      yield hook.callback.apply(thisArg, args);
    }
  }
  async parallel(...args) {
    await Promise.all(this.dispatch("emit", args));
  }
  emit(...args) {
    Array.from(this.dispatch("emit", args));
  }
  async serial(...args) {
    for await (const result of this.dispatch("serial", args)) {
      if (isBailed(result)) return result;
    }
  }
  bail(...args) {
    for (const result of this.dispatch("bail", args)) {
      if (isBailed(result)) return result;
    }
  }
  register(label, hooks, callback, options) {
    const method = options.prepend ? "unshift" : "push";
    hooks[method]({ ctx: this.ctx, callback, ...options });
    return this.ctx.state.collect(label, () => this.unregister(hooks, callback));
  }
  unregister(hooks, callback) {
    const index = hooks.findIndex((hook) => hook.callback === callback);
    if (index >= 0) {
      hooks.splice(index, 1);
      return true;
    }
  }
  on(name, listener, options) {
    if (typeof options !== "object") {
      options = { prepend: options };
    }
    this.ctx.scope.assertActive();
    listener = this.ctx.reflect.bind(listener);
    const result = this.bail(this.ctx, "internal/listener", name, listener, options);
    if (result) return result;
    const hooks = this._hooks[name] ||= [];
    const label = typeof name === "string" ? `event <${name}>` : "event (Symbol)";
    return this.register(label, hooks, listener, options);
  }
  once(name, listener, options) {
    const dispose = this.on(name, function(...args) {
      dispose();
      return listener.apply(this, args);
    }, options);
    return dispose;
  }
  async start() {
    this.isActive = true;
    const hooks = this._hooks.ready || [];
    while (hooks.length) {
      const { ctx, callback } = hooks.shift();
      ctx.scope.ensure(async () => callback());
    }
    await this.flush();
  }
  async stop() {
    this.isActive = false;
    this.ctx.scope.reset();
  }
};
var events_default = Lifecycle;
var CordisError = class _CordisError extends Error {
  constructor(code, message) {
    super(message ?? _CordisError.Code[code]);
    this.code = code;
  }
  static {
    __name$b(this, "CordisError");
  }
};
((CordisError2) => {
  CordisError2.Code = {
    INACTIVE_EFFECT: "cannot create effect on inactive context"
  };
})(CordisError || (CordisError = {}));
var EffectScope = class {
  constructor(parent, config) {
    this.parent = parent;
    this.config = config;
    this.uid = parent.registry ? parent.registry.counter : 0;
    this.ctx = this.context = parent.extend({ scope: this });
    this.proxy = new Proxy({}, {
      get: /* @__PURE__ */ __name$b((target, key2) => Reflect.get(this.config, key2), "get")
    });
  }
  static {
    __name$b(this, "EffectScope");
  }
  uid;
  ctx;
  disposables = [];
  error;
  status = 0;
  isActive = false;
  // Same as `this.ctx`, but with a more specific type.
  context;
  proxy;
  acceptors = [];
  tasks = /* @__PURE__ */ new Set();
  hasError = false;
  get _config() {
    return this.runtime.isReactive ? this.proxy : this.config;
  }
  assertActive() {
    if (this.uid !== null || this.isActive) return;
    throw new CordisError("INACTIVE_EFFECT");
  }
  effect(callback, config) {
    this.assertActive();
    const result = isConstructor(callback) ? new callback(this.ctx, config) : callback(this.ctx, config);
    let disposed = false;
    const original = typeof result === "function" ? result : result.dispose.bind(result);
    const wrapped = /* @__PURE__ */ __name$b((...args) => {
      if (disposed) return;
      disposed = true;
      remove(this.disposables, wrapped);
      return original(...args);
    }, "wrapped");
    this.disposables.push(wrapped);
    if (typeof result === "function") return wrapped;
    result.dispose = wrapped;
    return result;
  }
  collect(label, callback) {
    const dispose = defineProperty(() => {
      remove(this.disposables, dispose);
      return callback();
    }, "name", label);
    this.disposables.push(dispose);
    return dispose;
  }
  restart() {
    this.reset();
    this.error = null;
    this.hasError = false;
    this.status = 0;
    this.start();
  }
  _getStatus() {
    if (this.uid === null) return 4;
    if (this.hasError) return 3;
    if (this.tasks.size) return 1;
    if (this.ready) return 2;
    return 0;
  }
  updateStatus(callback) {
    const oldValue = this.status;
    callback?.();
    this.status = this._getStatus();
    if (oldValue !== this.status) {
      this.context.emit("internal/status", this, oldValue);
    }
  }
  ensure(callback) {
    const task = callback().catch((reason) => {
      this.context.emit(this.ctx, "internal/error", reason);
      this.cancel(reason);
    }).finally(() => {
      this.updateStatus(() => this.tasks.delete(task));
      this.context.events._tasks.delete(task);
    });
    this.updateStatus(() => this.tasks.add(task));
    this.context.events._tasks.add(task);
  }
  cancel(reason) {
    this.error = reason;
    this.updateStatus(() => this.hasError = true);
    this.reset();
  }
  get ready() {
    return Object.entries(this.runtime.inject).every(([name, inject]) => {
      return !inject.required || !isNullable(this.ctx.get(name));
    });
  }
  reset() {
    this.isActive = false;
    this.disposables = this.disposables.splice(0).filter((dispose) => {
      if (this.uid !== null && dispose[Context.static] === this) return true;
      (async () => dispose())().catch((reason) => {
        this.context.emit(this.ctx, "internal/error", reason);
      });
    });
  }
  init(error) {
    if (!this.config) {
      this.cancel(error);
    } else {
      this.start();
    }
  }
  start() {
    if (!this.ready || this.isActive || this.uid === null) return true;
    this.isActive = true;
    this.updateStatus(() => this.hasError = false);
  }
  accept(...args) {
    const keys = Array.isArray(args[0]) ? args.shift() : null;
    const acceptor = { keys, callback: args[0], ...args[1] };
    return this.effect(() => {
      this.acceptors.push(acceptor);
      if (acceptor.immediate) acceptor.callback?.(this.config);
      return () => remove(this.acceptors, acceptor);
    });
  }
  decline(keys) {
    return this.accept(keys, () => true);
  }
  checkUpdate(resolved, forced) {
    if (forced || !this.config) return [true, true];
    if (forced === false) return [false, false];
    const modified = /* @__PURE__ */ Object.create(null);
    const checkPropertyUpdate = /* @__PURE__ */ __name$b((key2) => {
      const result = modified[key2] ??= !deepEqual(this.config[key2], resolved[key2]);
      hasUpdate ||= result;
      return result;
    }, "checkPropertyUpdate");
    const ignored = /* @__PURE__ */ new Set();
    let hasUpdate = false, shouldRestart = false;
    let fallback = this.runtime.isReactive || null;
    for (const { keys, callback, passive } of this.acceptors) {
      if (!keys) {
        fallback ||= !passive;
      } else if (passive) {
        keys?.forEach((key2) => ignored.add(key2));
      } else {
        let hasUpdate2 = false;
        for (const key2 of keys) {
          hasUpdate2 ||= checkPropertyUpdate(key2);
        }
        if (!hasUpdate2) continue;
      }
      const result = callback?.(resolved);
      if (result) shouldRestart = true;
    }
    for (const key2 in { ...this.config, ...resolved }) {
      if (fallback === false) continue;
      if (!(key2 in modified) && !ignored.has(key2)) {
        const hasUpdate2 = checkPropertyUpdate(key2);
        if (fallback === null) shouldRestart ||= hasUpdate2;
      }
    }
    return [hasUpdate, shouldRestart];
  }
};
var ForkScope = class extends EffectScope {
  constructor(parent, runtime, config, error) {
    super(parent, config);
    this.runtime = runtime;
    this.dispose = defineProperty(parent.scope.collect(`fork <${parent.runtime.name}>`, () => {
      this.uid = null;
      this.reset();
      this.context.emit("internal/fork", this);
      const result = remove(runtime.disposables, this.dispose);
      if (remove(runtime.children, this) && !runtime.children.length) {
        parent.registry.delete(runtime.plugin);
      }
      return result;
    }), Context.static, runtime);
    runtime.children.push(this);
    runtime.disposables.push(this.dispose);
    this.context.emit("internal/fork", this);
    this.init(error);
  }
  static {
    __name$b(this, "ForkScope");
  }
  dispose;
  start() {
    if (super.start()) return true;
    for (const fork of this.runtime.forkables) {
      this.ensure(async () => fork(this.context, this._config));
    }
  }
  update(config, forced) {
    const oldConfig = this.config;
    const state = this.runtime.isForkable ? this : this.runtime;
    if (state.config !== oldConfig) return;
    let resolved;
    try {
      resolved = resolveConfig(this.runtime.plugin, config);
    } catch (error) {
      this.context.emit("internal/error", error);
      return this.cancel(error);
    }
    const [hasUpdate, shouldRestart] = state.checkUpdate(resolved, forced);
    this.context.emit("internal/before-update", this, config);
    this.config = resolved;
    state.config = resolved;
    if (hasUpdate) {
      this.context.emit("internal/update", this, oldConfig);
    }
    if (shouldRestart) state.restart();
  }
};
var MainScope = class extends EffectScope {
  constructor(ctx, plugin, config, error) {
    super(ctx, config);
    this.plugin = plugin;
    if (!plugin) {
      this.name = "root";
      this.isActive = true;
    } else {
      this.setup();
      this.init(error);
    }
  }
  static {
    __name$b(this, "MainScope");
  }
  value;
  runtime = this;
  schema;
  name;
  inject = /* @__PURE__ */ Object.create(null);
  forkables = [];
  children = [];
  isReusable = false;
  isReactive = false;
  get isForkable() {
    return this.forkables.length > 0;
  }
  fork(parent, config, error) {
    return new ForkScope(parent, this, config, error);
  }
  dispose() {
    this.uid = null;
    this.reset();
    this.context.emit("internal/runtime", this);
    return true;
  }
  setup() {
    const { name } = this.plugin;
    if (name && name !== "apply") this.name = name;
    this.schema = this.plugin["Config"] || this.plugin["schema"];
    this.inject = Inject.resolve(this.plugin["using"] || this.plugin["inject"]);
    this.isReusable = this.plugin["reusable"];
    this.isReactive = this.plugin["reactive"];
    this.context.emit("internal/runtime", this);
    if (this.isReusable) {
      this.forkables.push(this.apply);
    }
  }
  apply = /* @__PURE__ */ __name$b((context, config) => {
    if (typeof this.plugin !== "function") {
      return this.plugin.apply(context, config);
    } else if (isConstructor(this.plugin)) {
      const instance = new this.plugin(context, config);
      const name = instance[Context.expose];
      if (name) {
        context.set(name, instance);
      }
      if (instance["fork"]) {
        this.forkables.push(instance["fork"].bind(instance));
      }
      return instance;
    } else {
      return this.plugin(context, config);
    }
  }, "apply");
  reset() {
    super.reset();
    for (const fork of this.children) {
      fork.reset();
    }
  }
  start() {
    if (super.start()) return true;
    if (!this.isReusable && this.plugin) {
      this.ensure(async () => this.value = this.apply(this.ctx, this._config));
    }
    for (const fork of this.children) {
      fork.start();
    }
  }
  update(config, forced) {
    if (this.isForkable) {
      const warning = new Error(`attempting to update forkable plugin "${this.plugin.name}", which may lead to unexpected behavior`);
      this.context.emit(this.ctx, "internal/warning", warning);
    }
    const oldConfig = this.config;
    let resolved;
    try {
      resolved = resolveConfig(this.runtime.plugin || this.context.constructor, config);
    } catch (error) {
      this.context.emit("internal/error", error);
      return this.cancel(error);
    }
    const [hasUpdate, shouldRestart] = this.checkUpdate(resolved, forced);
    const state = this.children.find((fork) => fork.config === oldConfig);
    this.config = resolved;
    if (state) {
      this.context.emit("internal/before-update", state, config);
      state.config = resolved;
      if (hasUpdate) {
        this.context.emit("internal/update", state, oldConfig);
      }
    }
    if (shouldRestart) this.restart();
  }
};
function isApplicable(object) {
  return object && typeof object === "object" && typeof object.apply === "function";
}
__name$b(isApplicable, "isApplicable");
function Inject(inject) {
  return function(value, ctx) {
    if (ctx.kind === "class") {
      value.inject = inject;
    } else if (ctx.kind === "method") {
      ctx.addInitializer(function() {
        const property = this[symbols.tracker]?.property;
        if (!property) throw new Error("missing context tracker");
        this[property].inject(inject, (ctx2) => {
          value.call(withProps(this, { [property]: ctx2 }));
        });
      });
    } else {
      throw new Error("@Inject can only be used on class or class methods");
    }
  };
}
__name$b(Inject, "Inject");
((Inject2) => {
  function resolve2(inject) {
    if (!inject) return {};
    if (Array.isArray(inject)) {
      return Object.fromEntries(inject.map((name) => [name, { required: true }]));
    }
    const { required, optional, ...rest } = inject;
    if (Array.isArray(required)) {
      Object.assign(rest, Object.fromEntries(required.map((name) => [name, { required: true }])));
    }
    if (Array.isArray(optional)) {
      Object.assign(rest, Object.fromEntries(optional.map((name) => [name, { required: false }])));
    }
    return rest;
  }
  Inject2.resolve = resolve2;
  __name$b(resolve2, "resolve");
})(Inject || (Inject = {}));
var Registry = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    defineProperty(this, symbols.tracker, {
      associate: "registry",
      property: "ctx"
    });
    this.context = ctx;
    const runtime = new MainScope(ctx, null, config);
    ctx.scope = runtime;
    runtime.ctx = ctx;
    this.set(null, runtime);
  }
  static {
    __name$b(this, "Registry");
  }
  _counter = 0;
  _internal = /* @__PURE__ */ new Map();
  context;
  get counter() {
    return ++this._counter;
  }
  get size() {
    return this._internal.size;
  }
  resolve(plugin, assert = false) {
    if (plugin === null) return plugin;
    if (typeof plugin === "function") return plugin;
    if (isApplicable(plugin)) return plugin.apply;
    if (assert) throw new Error('invalid plugin, expect function or object with an "apply" method, received ' + typeof plugin);
  }
  get(plugin) {
    const key2 = this.resolve(plugin);
    return key2 && this._internal.get(key2);
  }
  has(plugin) {
    const key2 = this.resolve(plugin);
    return !!key2 && this._internal.has(key2);
  }
  set(plugin, state) {
    const key2 = this.resolve(plugin);
    this._internal.set(key2, state);
  }
  delete(plugin) {
    const key2 = this.resolve(plugin);
    const runtime = key2 && this._internal.get(key2);
    if (!runtime) return;
    this._internal.delete(key2);
    runtime.dispose();
    return runtime;
  }
  keys() {
    return this._internal.keys();
  }
  values() {
    return this._internal.values();
  }
  entries() {
    return this._internal.entries();
  }
  forEach(callback) {
    return this._internal.forEach(callback);
  }
  using(inject, callback) {
    return this.inject(inject, callback);
  }
  inject(inject, callback) {
    return this.plugin({ inject, apply: callback, name: callback.name });
  }
  plugin(plugin, config, error) {
    this.resolve(plugin, true);
    this.ctx.scope.assertActive();
    if (!error) {
      try {
        config = resolveConfig(plugin, config);
      } catch (reason) {
        this.context.emit(this.ctx, "internal/error", reason);
        error = reason;
        config = null;
      }
    }
    let runtime = this.get(plugin);
    if (runtime) {
      if (!runtime.isForkable) {
        this.context.emit(this.ctx, "internal/warning", new Error(`duplicate plugin detected: ${plugin.name}`));
      }
      return runtime.fork(this.ctx, config, error);
    }
    runtime = new MainScope(this.ctx, plugin, config, error);
    this.set(plugin, runtime);
    return runtime.fork(this.ctx, config, error);
  }
};
var registry_default = Registry;
var Context = class _Context {
  static {
    __name$b(this, "Context");
  }
  static store = symbols.store;
  static events = symbols.events;
  static static = symbols.static;
  static filter = symbols.filter;
  static expose = symbols.expose;
  static isolate = symbols.isolate;
  static internal = symbols.internal;
  static intercept = symbols.intercept;
  static origin = "ctx";
  static current = "ctx";
  static is(value) {
    return !!value?.[_Context.is];
  }
  static {
    _Context.is[Symbol.toPrimitive] = () => Symbol.for("cordis.is");
    _Context.prototype[_Context.is] = true;
  }
  /** @deprecated use `Service.traceable` instead */
  static associate(object, name) {
    return object;
  }
  constructor(config) {
    config = resolveConfig(this.constructor, config);
    this[symbols.store] = /* @__PURE__ */ Object.create(null);
    this[symbols.isolate] = /* @__PURE__ */ Object.create(null);
    this[symbols.internal] = /* @__PURE__ */ Object.create(null);
    this[symbols.intercept] = /* @__PURE__ */ Object.create(null);
    const self2 = new Proxy(this, reflect_default.handler);
    self2.root = self2;
    self2.reflect = new reflect_default(self2);
    self2.registry = new registry_default(self2, config);
    self2.lifecycle = new events_default(self2);
    const attach = /* @__PURE__ */ __name$b((internal2) => {
      if (!internal2) return;
      attach(Object.getPrototypeOf(internal2));
      for (const key2 of Object.getOwnPropertyNames(internal2)) {
        const constructor = internal2[key2]["prototype"]?.constructor;
        if (!constructor) continue;
        self2[internal2[key2]["key"]] = new constructor(self2, config);
        defineProperty(self2[internal2[key2]["key"]], "ctx", self2);
      }
    }, "attach");
    attach(this[symbols.internal]);
    return self2;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Context <${this.name}>`;
  }
  get name() {
    let runtime = this.runtime;
    while (runtime && !runtime.name) {
      runtime = runtime.parent.runtime;
    }
    return runtime?.name;
  }
  get events() {
    return this.lifecycle;
  }
  /** @deprecated */
  get state() {
    return this.scope;
  }
  extend(meta = {}) {
    const source2 = Reflect.getOwnPropertyDescriptor(this, symbols.shadow)?.value;
    const self2 = Object.assign(Object.create(getTraceable(this, this)), meta);
    if (!source2) return self2;
    return Object.assign(Object.create(self2), { [symbols.shadow]: source2 });
  }
  isolate(name, label) {
    const shadow = Object.create(this[symbols.isolate]);
    shadow[name] = label ?? Symbol(name);
    return this.extend({ [symbols.isolate]: shadow });
  }
  intercept(name, config) {
    const intercept = Object.create(this[symbols.intercept]);
    intercept[name] = config;
    return this.extend({ [symbols.intercept]: intercept });
  }
};
Context.prototype[Context.internal] = /* @__PURE__ */ Object.create(null);
var Service = class _Service {
  static {
    __name$b(this, "Service");
  }
  static setup = symbols.setup;
  static invoke = symbols.invoke;
  static extend = symbols.extend;
  static tracker = symbols.tracker;
  static provide = symbols.provide;
  static immediate = symbols.immediate;
  start() {
  }
  stop() {
  }
  ctx;
  name;
  config;
  constructor(...args) {
    let _ctx, name, immediate, config;
    if (Context.is(args[0])) {
      _ctx = args[0];
      if (typeof args[1] === "string") {
        name = args[1];
        immediate = args[2];
      } else {
        config = args[1];
      }
    } else {
      config = args[0];
    }
    name ??= this.constructor[symbols.provide];
    immediate ??= this.constructor[symbols.immediate];
    let self2 = this;
    const tracker = {
      associate: name,
      property: "ctx"
    };
    if (self2[symbols.invoke]) {
      self2 = createCallable(name, joinPrototype(Object.getPrototypeOf(this), Function.prototype), tracker);
    }
    if (_ctx) {
      self2.ctx = _ctx;
    } else {
      self2[symbols.setup]();
    }
    self2.name = name;
    self2.config = config;
    defineProperty(self2, symbols.tracker, tracker);
    self2.ctx.provide(name);
    self2.ctx.runtime.name = name;
    if (immediate) {
      if (_ctx) self2[symbols.expose] = name;
      else self2.ctx.set(name, self2);
    }
    self2.ctx.on("ready", async () => {
      await Promise.resolve();
      await self2.start();
      if (!immediate) self2.ctx.set(name, self2);
    });
    self2.ctx.on("dispose", () => self2.stop());
    return self2;
  }
  [symbols.filter](ctx) {
    return ctx[symbols.isolate][this.name] === this.ctx[symbols.isolate][this.name];
  }
  [symbols.setup]() {
    this.ctx = new Context();
  }
  [symbols.extend](props) {
    let self2;
    if (this[_Service.invoke]) {
      self2 = createCallable(this.name, this, this[symbols.tracker]);
    } else {
      self2 = Object.create(this);
    }
    return Object.assign(self2, props);
  }
  static [Symbol.hasInstance](instance) {
    let constructor = instance.constructor;
    while (constructor) {
      constructor = constructor.prototype?.constructor;
      if (constructor === this) return true;
      constructor = Object.getPrototypeOf(constructor);
    }
    return false;
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os2 = require$$0$5;
  const tty = require$$1$1;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min2;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var supportsColorExports = requireSupportsColor();
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$4 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect) return objectInspect;
  hasRequiredObjectInspect = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int = num < 0 ? -$floor(-num) : $floor(num);
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = require$$0$4;
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    "double": '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    "double": /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect2(value, from2, noIndent) {
      if (from2) {
        seen = $arrSlice.call(seen);
        seen.push(from2);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
      var name = nameOf(obj);
      var keys = arrObjKeys(obj, inspect2);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0; i < attrs.length; i++) {
        s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect2);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect2);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key2) {
          mapParts.push(inspect2(key2, obj, true) + " => " + inspect2(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect2(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber(obj)) {
      return markBoxed(inspect2(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect2(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
      return markBoxed(inspect2(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect2);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
  }
  function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
  }
  function isArray(obj) {
    return toStr(obj) === "[object Array]" && canTrustToString(obj);
  }
  function isDate(obj) {
    return toStr(obj) === "[object Date]" && canTrustToString(obj);
  }
  function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && canTrustToString(obj);
  }
  function isString(obj) {
    return toStr(obj) === "[object String]" && canTrustToString(obj);
  }
  function isNumber(obj) {
    return toStr(obj) === "[object Number]" && canTrustToString(obj);
  }
  function isBoolean(obj) {
    return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
    return key2 in this;
  };
  function has(obj, key2) {
    return hasOwn.call(obj, key2);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c2) {
    var n = c2.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type2) {
    return type2 + " { ? }";
  }
  function collectionOf(type2, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type2 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (indexOf(xs[i], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect2) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0; i < obj.length; i++) {
        xs[i] = has(obj, i) ? inspect2(obj[i], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key2 in obj) {
      if (!has(obj, key2)) {
        continue;
      }
      if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key2)) {
        xs.push(inspect2(key2, obj) + ": " + inspect2(obj[key2], obj));
      } else {
        xs.push(key2 + ": " + inspect2(obj[key2], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect;
}
var objectInspectExports = /* @__PURE__ */ requireObjectInspect();
const inspect = /* @__PURE__ */ getDefaultExportFromCjs(objectInspectExports);
var __create = Object.create;
var __defProp$a = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$2 = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name$a = (target, value) => __defProp$a(target, "name", { value, configurable: true });
var __commonJS$2 = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames$2(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key2 of __getOwnPropNames$2(from2))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp$a(to, key2, { get: () => from2[key2], enumerable: !(desc = __getOwnPropDesc(from2, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  !mod2 || !mod2.__esModule ? __defProp$a(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var require_shared = __commonJS$2({
  "src/shared.ts"(exports, module) {
    var c16 = [6, 2, 3, 4, 5, 1];
    var c256 = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ];
    function isAggregateError(error) {
      return error instanceof Error && Array.isArray(error["errors"]);
    }
    __name$a(isAggregateError, "isAggregateError");
    var Logger2 = class _Logger {
      constructor(name, meta) {
        this.name = name;
        this.meta = meta;
        this.createMethod("success", _Logger.SUCCESS);
        this.createMethod("error", _Logger.ERROR);
        this.createMethod("info", _Logger.INFO);
        this.createMethod("warn", _Logger.WARN);
        this.createMethod("debug", _Logger.DEBUG);
      }
      static {
        __name$a(this, "Logger");
      }
      // log levels
      static SILENT = 0;
      static SUCCESS = 1;
      static ERROR = 1;
      static INFO = 2;
      static WARN = 2;
      static DEBUG = 3;
      // global config
      static id = 0;
      static targets = [{
        colors: supportsColorExports.stdout && supportsColorExports.stdout.level,
        print(text) {
          console.log(text);
        }
      }];
      // global registry
      static formatters = /* @__PURE__ */ Object.create(null);
      static format(name, formatter) {
        this.formatters[name] = formatter;
      }
      static levels = {
        base: 2
      };
      static color(target, code, value, decoration = "") {
        if (!target.colors) return "" + value;
        return `\x1B[3${code < 8 ? code : "8;5;" + code}${target.colors >= 2 ? decoration : ""}m${value}\x1B[0m`;
      }
      static code(name, target) {
        let hash = 0;
        for (let i = 0; i < name.length; i++) {
          hash = (hash << 3) - hash + name.charCodeAt(i) + 13;
          hash |= 0;
        }
        const colors = !target.colors ? [] : target.colors >= 2 ? c256 : c16;
        return colors[Math.abs(hash) % colors.length];
      }
      static render(target, record) {
        const prefix = `[${record.type[0].toUpperCase()}]`;
        const space = " ".repeat(target.label?.margin ?? 1);
        let indent = 3 + space.length, output2 = "";
        if (target.showTime) {
          indent += target.showTime.length + space.length;
          output2 += _Logger.color(target, 8, Time.template(target.showTime)) + space;
        }
        const code = _Logger.code(record.name, target);
        const label = _Logger.color(target, code, record.name, ";1");
        const padLength = (target.label?.width ?? 0) + label.length - record.name.length;
        if (target.label?.align === "right") {
          output2 += label.padStart(padLength) + space + prefix + space;
          indent += (target.label.width ?? 0) + space.length;
        } else {
          output2 += prefix + space + label.padEnd(padLength) + space;
        }
        output2 += record.content.replace(/\n/g, "\n" + " ".repeat(indent));
        if (target.showDiff && target.timestamp) {
          const diff = record.timestamp - target.timestamp;
          output2 += _Logger.color(target, code, " +" + Time.format(diff));
        }
        return output2;
      }
      extend = /* @__PURE__ */ __name$a((namespace) => {
        return new _Logger(`${this.name}:${namespace}`, this.meta);
      }, "extend");
      warning = /* @__PURE__ */ __name$a((format, ...args) => {
        this.warn(format, ...args);
      }, "warning");
      createMethod(type2, level) {
        this[type2] = (...args) => {
          if (args.length === 1 && args[0] instanceof Error) {
            if (args[0].cause) {
              this[type2](args[0].cause);
            } else if (isAggregateError(args[0])) {
              args[0].errors.forEach((error) => this[type2](error));
              return;
            }
          }
          const id = ++_Logger.id;
          const timestamp = Date.now();
          for (const target of _Logger.targets) {
            if (this.getLevel(target) < level) continue;
            const content = this.format(target, ...args);
            const record = { id, type: type2, level, name: this.name, meta: this.meta, content, timestamp };
            if (target.record) {
              target.record(record);
            } else {
              const { print = console.log } = target;
              print(_Logger.render(target, record));
            }
            target.timestamp = timestamp;
          }
        };
      }
      format(target, ...args) {
        if (args[0] instanceof Error) {
          args[0] = args[0].stack || args[0].message;
          args.unshift("%s");
        } else if (typeof args[0] !== "string") {
          args.unshift("%o");
        }
        let format = args.shift();
        format = format.replace(/%([a-zA-Z%])/g, (match, char) => {
          if (match === "%%") return "%";
          const formatter = _Logger.formatters[char];
          if (typeof formatter === "function") {
            const value = args.shift();
            return formatter(value, target, this);
          }
          return match;
        });
        for (let arg of args) {
          if (typeof arg === "object" && arg) {
            arg = _Logger.formatters["o"](arg, target, this);
          }
          format += " " + arg;
        }
        const { maxLength = 10240 } = target;
        return format.split(/\r?\n/g).map((line2) => {
          return line2.slice(0, maxLength) + (line2.length > maxLength ? "..." : "");
        }).join("\n");
      }
      getLevel(target) {
        const paths = this.name.split(":");
        let config = target?.levels || _Logger.levels;
        do {
          config = config[paths.shift()] ?? config["base"];
        } while (paths.length && typeof config === "object");
        return config;
      }
      get level() {
        return this.getLevel();
      }
      set level(value) {
        const paths = this.name.split(":");
        let config = _Logger.levels;
        while (paths.length > 1) {
          const name = paths.shift();
          const value2 = config[name];
          if (typeof value2 === "object") {
            config = value2;
          } else {
            config = config[name] = { base: value2 ?? config.base };
          }
        }
        config[paths[0]] = value;
      }
    };
    Logger2.format("s", (value) => value);
    Logger2.format("d", (value) => +value);
    Logger2.format("j", (value) => JSON.stringify(value));
    Logger2.format("c", (value, target, logger) => {
      return Logger2.color(target, Logger2.code(logger.name, target), value);
    });
    Logger2.format("C", (value, target) => {
      return Logger2.color(target, 15, value, ";1");
    });
    module.exports = Logger2;
  }
});
var require_browser = __commonJS$2({
  "src/browser.ts"(exports, module) {
    var import_shared = __toESM(require_shared());
    import_shared.default.format("o", (value, target) => {
      return inspect(value, { depth: Infinity }).replace(/\s*\n\s*/g, " ");
    });
    module.exports = import_shared.default;
  }
});
const Logger = require_browser();
var __defProp$9 = Object.defineProperty;
var __name$9 = (target, value) => __defProp$9(target, "name", { value, configurable: true });
var LoggerService = class _LoggerService extends Service {
  static {
    __name$9(this, "LoggerService");
  }
  constructor(ctx) {
    super(ctx, "logger", true);
    ctx.on("internal/info", function(format, ...args) {
      this.logger("app").info(format, ...args);
    });
    ctx.on("internal/error", function(format, ...args) {
      this.logger("app").error(format, ...args);
    });
    ctx.on("internal/warning", function(format, ...args) {
      this.logger("app").warn(format, ...args);
    });
  }
  [Service.invoke](name) {
    return new Logger(name, defineProperty({}, "ctx", this.ctx));
  }
  static {
    for (const type2 of ["success", "error", "info", "warn", "debug", "extend"]) {
      _LoggerService.prototype[type2] = function(...args) {
        return this(this.ctx.name)[type2](...args);
      };
    }
  }
};
var __defProp$8 = Object.defineProperty;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __name$8 = (target, value) => __defProp$8(target, "name", { value, configurable: true });
var __commonJS$1 = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames$1(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var require_src = __commonJS$1({
  "src/index.ts"(exports, module) {
    var kSchema = Symbol.for("schemastery");
    var kValidationError = Symbol.for("ValidationError");
    globalThis.__schemastery_index__ ??= 0;
    var ValidationError = class extends TypeError {
      constructor(message, options) {
        let prefix = "$";
        for (const segment of options.path || []) {
          if (typeof segment === "string") {
            prefix += "." + segment;
          } else if (typeof segment === "number") {
            prefix += "[" + segment + "]";
          } else if (typeof segment === "symbol") {
            prefix += `[Symbol(${segment.toString()})]`;
          }
        }
        if (prefix.startsWith(".")) prefix = prefix.slice(1);
        super((prefix === "$" ? "" : `${prefix} `) + message);
        this.options = options;
      }
      static {
        __name$8(this, "ValidationError");
      }
      name = "ValidationError";
      static is(error) {
        return !!error?.[kValidationError];
      }
    };
    Object.defineProperty(ValidationError.prototype, kValidationError, {
      value: true
    });
    var Schema = /* @__PURE__ */ __name$8(function(options) {
      const schema = /* @__PURE__ */ __name$8(function(data, options2 = {}) {
        return Schema.resolve(data, schema, options2)[0];
      }, "schema");
      if (options.refs) {
        const refs2 = mapValues(options.refs, (options2) => new Schema(options2));
        const getRef = /* @__PURE__ */ __name$8((uid) => refs2[uid], "getRef");
        for (const key2 in refs2) {
          const options2 = refs2[key2];
          options2.sKey = getRef(options2.sKey);
          options2.inner = getRef(options2.inner);
          options2.list = options2.list && options2.list.map(getRef);
          options2.dict = options2.dict && mapValues(options2.dict, getRef);
        }
        return refs2[options.uid];
      }
      Object.assign(schema, options);
      if (typeof schema.callback === "string") {
        try {
          schema.callback = new Function("return " + schema.callback)();
        } catch {
        }
      }
      Object.defineProperty(schema, "uid", { value: globalThis.__schemastery_index__++ });
      Object.setPrototypeOf(schema, Schema.prototype);
      schema.meta ||= {};
      schema.toString = schema.toString.bind(schema);
      return schema;
    }, "Schema");
    Schema.prototype = Object.create(Function.prototype);
    Schema.prototype[kSchema] = true;
    Schema.ValidationError = ValidationError;
    var refs;
    Schema.prototype.toJSON = /* @__PURE__ */ __name$8(function toJSON() {
      if (refs) {
        refs[this.uid] ??= JSON.parse(JSON.stringify({ ...this }));
        return this.uid;
      }
      refs = { [this.uid]: { ...this } };
      refs[this.uid] = JSON.parse(JSON.stringify({ ...this }));
      const result = { uid: this.uid, refs };
      refs = void 0;
      return result;
    }, "toJSON");
    Schema.prototype.set = /* @__PURE__ */ __name$8(function set(key2, value) {
      this.dict[key2] = value;
      return this;
    }, "set");
    Schema.prototype.push = /* @__PURE__ */ __name$8(function push2(value) {
      this.list.push(value);
      return this;
    }, "push");
    function mergeDesc(original, messages) {
      const result = typeof original === "string" ? { "": original } : { ...original };
      for (const locale in messages) {
        const value = messages[locale];
        if (value?.$description || value?.$desc) {
          result[locale] = value.$description || value.$desc;
        } else if (typeof value === "string") {
          result[locale] = value;
        }
      }
      return result;
    }
    __name$8(mergeDesc, "mergeDesc");
    function getInner(value) {
      return value?.$value ?? value?.$inner;
    }
    __name$8(getInner, "getInner");
    function extractKeys(data) {
      return filterKeys(data ?? {}, (key2) => !key2.startsWith("$"));
    }
    __name$8(extractKeys, "extractKeys");
    Schema.prototype.i18n = /* @__PURE__ */ __name$8(function i18n(messages) {
      const schema = Schema(this);
      const desc = mergeDesc(schema.meta.description, messages);
      if (Object.keys(desc).length) schema.meta.description = desc;
      if (schema.dict) {
        schema.dict = mapValues(schema.dict, (inner, key2) => {
          return inner.i18n(mapValues(messages, (data) => getInner(data)?.[key2] ?? data?.[key2]));
        });
      }
      if (schema.list) {
        schema.list = schema.list.map((inner, index) => {
          return inner.i18n(mapValues(messages, (data = {}) => {
            if (Array.isArray(getInner(data))) return getInner(data)[index];
            if (Array.isArray(data)) return data[index];
            return extractKeys(data);
          }));
        });
      }
      if (schema.inner) {
        schema.inner = schema.inner.i18n(mapValues(messages, (data) => {
          if (getInner(data)) return getInner(data);
          return extractKeys(data);
        }));
      }
      if (schema.sKey) {
        schema.sKey = schema.sKey.i18n(mapValues(messages, (data) => data?.$key));
      }
      return schema;
    }, "i18n");
    Schema.prototype.extra = /* @__PURE__ */ __name$8(function extra(key2, value) {
      const schema = Schema(this);
      schema.meta = { ...schema.meta, [key2]: value };
      return schema;
    }, "extra");
    for (const key2 of ["required", "disabled", "collapse", "hidden", "loose"]) {
      Object.assign(Schema.prototype, {
        [key2](value = true) {
          const schema = Schema(this);
          schema.meta = { ...schema.meta, [key2]: value };
          return schema;
        }
      });
    }
    Schema.prototype.deprecated = /* @__PURE__ */ __name$8(function deprecated() {
      const schema = Schema(this);
      schema.meta.badges ||= [];
      schema.meta.badges.push({ text: "deprecated", type: "danger" });
      return schema;
    }, "deprecated");
    Schema.prototype.experimental = /* @__PURE__ */ __name$8(function experimental() {
      const schema = Schema(this);
      schema.meta.badges ||= [];
      schema.meta.badges.push({ text: "experimental", type: "warning" });
      return schema;
    }, "experimental");
    Schema.prototype.pattern = /* @__PURE__ */ __name$8(function pattern2(regexp) {
      const schema = Schema(this);
      const pattern22 = pick(regexp, ["source", "flags"]);
      schema.meta = { ...schema.meta, pattern: pattern22 };
      return schema;
    }, "pattern");
    Schema.prototype.simplify = /* @__PURE__ */ __name$8(function simplify(value) {
      if (deepEqual(value, this.meta.default, this.type === "dict")) return null;
      if (isNullable(value)) return value;
      if (this.type === "object" || this.type === "dict") {
        const result = {};
        for (const key2 in value) {
          const schema = this.type === "object" ? this.dict[key2] : this.inner;
          const item = schema?.simplify(value[key2]);
          if (this.type === "dict" || !isNullable(item)) result[key2] = item;
        }
        if (deepEqual(result, this.meta.default, this.type === "dict")) return null;
        return result;
      } else if (this.type === "array" || this.type === "tuple") {
        const result = [];
        value.forEach((value2, index) => {
          const schema = this.type === "array" ? this.inner : this.list[index];
          const item = schema ? schema.simplify(value2) : value2;
          result.push(item);
        });
        return result;
      } else if (this.type === "intersect") {
        const result = {};
        for (const item of this.list) {
          Object.assign(result, item.simplify(value));
        }
        return result;
      } else if (this.type === "union") {
        for (const schema of this.list) {
          try {
            Schema.resolve(value, schema, {});
            return schema.simplify(value);
          } catch {
          }
        }
      }
      return value;
    }, "simplify");
    Schema.prototype.toString = /* @__PURE__ */ __name$8(function toString(inline) {
      return formatters[this.type]?.(this, inline) ?? `Schema<${this.type}>`;
    }, "toString");
    Schema.prototype.role = /* @__PURE__ */ __name$8(function role(role, extra) {
      const schema = Schema(this);
      schema.meta = { ...schema.meta, role, extra };
      return schema;
    }, "role");
    for (const key2 of ["default", "link", "comment", "description", "max", "min", "step"]) {
      Object.assign(Schema.prototype, {
        [key2](value) {
          const schema = Schema(this);
          schema.meta = { ...schema.meta, [key2]: value };
          return schema;
        }
      });
    }
    var resolvers = {};
    Schema.extend = /* @__PURE__ */ __name$8(function extend(type2, resolve2) {
      resolvers[type2] = resolve2;
    }, "extend");
    Schema.resolve = /* @__PURE__ */ __name$8(function resolve2(data, schema, options = {}, strict = false) {
      if (!schema) return [data];
      if (options.ignore?.(data, schema)) return [data];
      if (isNullable(data) && schema.type !== "lazy") {
        if (schema.meta.required) throw new ValidationError(`missing required value`, options);
        let current = schema;
        let fallback = schema.meta.default;
        while (current?.type === "intersect" && isNullable(fallback)) {
          current = current.list[0];
          fallback = current?.meta.default;
        }
        if (isNullable(fallback)) return [data];
        data = clone(fallback);
      }
      const callback = resolvers[schema.type];
      if (!callback) throw new ValidationError(`unsupported type "${schema.type}"`, options);
      try {
        return callback(data, schema, options, strict);
      } catch (error) {
        if (!schema.meta.loose) throw error;
        return [schema.meta.default];
      }
    }, "resolve");
    Schema.from = /* @__PURE__ */ __name$8(function from2(source2) {
      if (isNullable(source2)) {
        return Schema.any();
      } else if (["string", "number", "boolean"].includes(typeof source2)) {
        return Schema.const(source2).required();
      } else if (source2[kSchema]) {
        return source2;
      } else if (typeof source2 === "function") {
        switch (source2) {
          case String:
            return Schema.string().required();
          case Number:
            return Schema.number().required();
          case Boolean:
            return Schema.boolean().required();
          case Function:
            return Schema.function().required();
          default:
            return Schema.is(source2).required();
        }
      } else {
        throw new TypeError(`cannot infer schema from ${source2}`);
      }
    }, "from");
    Schema.lazy = /* @__PURE__ */ __name$8(function lazy(builder) {
      const toJSON = /* @__PURE__ */ __name$8(() => {
        if (!schema.inner[kSchema]) {
          schema.inner = schema.builder();
          schema.inner.meta = { ...schema.meta, ...schema.inner.meta };
        }
        return schema.inner.toJSON();
      }, "toJSON");
      const schema = new Schema({ type: "lazy", builder, inner: { toJSON } });
      return schema;
    }, "lazy");
    Schema.natural = /* @__PURE__ */ __name$8(function natural() {
      return Schema.number().step(1).min(0);
    }, "natural");
    Schema.percent = /* @__PURE__ */ __name$8(function percent() {
      return Schema.number().step(0.01).min(0).max(1).role("slider");
    }, "percent");
    Schema.date = /* @__PURE__ */ __name$8(function date() {
      return Schema.union([
        Schema.is(Date),
        Schema.transform(Schema.string().role("datetime"), (value, options) => {
          const date2 = new Date(value);
          if (isNaN(+date2)) throw new ValidationError(`invalid date "${value}"`, options);
          return date2;
        }, true)
      ]);
    }, "date");
    Schema.regExp = /* @__PURE__ */ __name$8(function regExp(flag = "") {
      return Schema.union([
        Schema.is(RegExp),
        Schema.transform(Schema.string().role("regexp", { flag }), (value, options) => {
          try {
            return new RegExp(value, flag);
          } catch (e) {
            throw new ValidationError(e.message, options);
          }
        }, true)
      ]);
    }, "regExp");
    Schema.arrayBuffer = /* @__PURE__ */ __name$8(function arrayBuffer(encoding2) {
      return Schema.union([
        Schema.is(ArrayBuffer),
        Schema.is(SharedArrayBuffer),
        Schema.transform(Schema.any(), (value, options) => {
          if (Binary.isSource(value)) return Binary.fromSource(value);
          throw new ValidationError(`expected ArrayBufferSource but got ${value}`, options);
        }, true),
        ...encoding2 ? [Schema.transform(Schema.string(), (value, options) => {
          try {
            return encoding2 === "base64" ? Binary.fromBase64(value) : Binary.fromHex(value);
          } catch (e) {
            throw new ValidationError(e.message, options);
          }
        }, true)] : []
      ]);
    }, "arrayBuffer");
    Schema.extend("lazy", (data, schema, options, strict) => {
      if (!schema.inner[kSchema]) {
        schema.inner = schema.builder();
        schema.inner.meta = { ...schema.meta, ...schema.inner.meta };
      }
      return Schema.resolve(data, schema.inner, options, strict);
    });
    Schema.extend("any", (data) => {
      return [data];
    });
    Schema.extend("never", (data, _, options) => {
      throw new ValidationError(`expected nullable but got ${data}`, options);
    });
    Schema.extend("const", (data, { value }, options) => {
      if (deepEqual(data, value)) return [value];
      throw new ValidationError(`expected ${value} but got ${data}`, options);
    });
    function checkWithinRange(data, meta, description, options, skipMin = false) {
      const { max: max2 = Infinity, min: min2 = -Infinity } = meta;
      if (data > max2) throw new ValidationError(`expected ${description} <= ${max2} but got ${data}`, options);
      if (data < min2 && !skipMin) throw new ValidationError(`expected ${description} >= ${min2} but got ${data}`, options);
    }
    __name$8(checkWithinRange, "checkWithinRange");
    Schema.extend("string", (data, { meta }, options) => {
      if (typeof data !== "string") throw new ValidationError(`expected string but got ${data}`, options);
      if (meta.pattern) {
        const regexp = new RegExp(meta.pattern.source, meta.pattern.flags);
        if (!regexp.test(data)) throw new ValidationError(`expect string to match regexp ${regexp}`, options);
      }
      checkWithinRange(data.length, meta, "string length", options);
      return [data];
    });
    function decimalShift(data, digits) {
      const str = data.toString();
      if (str.includes("e")) return data * Math.pow(10, digits);
      const index = str.indexOf(".");
      if (index === -1) return data * Math.pow(10, digits);
      const frac = str.slice(index + 1);
      const integer = str.slice(0, index);
      if (frac.length <= digits) return +(integer + frac.padEnd(digits, "0"));
      return +(integer + frac.slice(0, digits) + "." + frac.slice(digits));
    }
    __name$8(decimalShift, "decimalShift");
    function isMultipleOf(data, min2, step) {
      step = Math.abs(step);
      if (!/^\d+\.\d+$/.test(step.toString())) {
        return (data - min2) % step === 0;
      }
      const index = step.toString().indexOf(".");
      const digits = step.toString().slice(index + 1).length;
      return Math.abs(decimalShift(data, digits) - decimalShift(min2, digits)) % decimalShift(step, digits) === 0;
    }
    __name$8(isMultipleOf, "isMultipleOf");
    Schema.extend("number", (data, { meta }, options) => {
      if (typeof data !== "number") throw new ValidationError(`expected number but got ${data}`, options);
      checkWithinRange(data, meta, "number", options);
      const { step } = meta;
      if (step && !isMultipleOf(data, meta.min ?? 0, step)) {
        throw new ValidationError(`expected number multiple of ${step} but got ${data}`, options);
      }
      return [data];
    });
    Schema.extend("boolean", (data, _, options) => {
      if (typeof data === "boolean") return [data];
      throw new ValidationError(`expected boolean but got ${data}`, options);
    });
    Schema.extend("bitset", (data, { bits, meta }, options) => {
      let value = 0, keys = [];
      if (typeof data === "number") {
        value = data;
        for (const key2 in bits) {
          if (data & bits[key2]) {
            keys.push(key2);
          }
        }
      } else if (Array.isArray(data)) {
        keys = data;
        for (const key2 of keys) {
          if (typeof key2 !== "string") throw new ValidationError(`expected string but got ${key2}`, options);
          if (key2 in bits) value |= bits[key2];
        }
      } else {
        throw new ValidationError(`expected number or array but got ${data}`, options);
      }
      if (value === meta.default) return [value];
      return [value, keys];
    });
    Schema.extend("function", (data, _, options) => {
      if (typeof data === "function") return [data];
      throw new ValidationError(`expected function but got ${data}`, options);
    });
    Schema.extend("is", (data, { callback }, options) => {
      if (data instanceof callback) return [data];
      throw new ValidationError(`expected ${callback.name} but got ${data}`, options);
    });
    function property(data, key2, schema, options) {
      try {
        const [value, adapted] = Schema.resolve(data[key2], schema, {
          ...options,
          path: [...options.path || [], key2]
        });
        if (adapted !== void 0) data[key2] = adapted;
        return value;
      } catch (e) {
        if (!options?.autofix) throw e;
        delete data[key2];
        return schema.meta.default;
      }
    }
    __name$8(property, "property");
    Schema.extend("array", (data, { inner, meta }, options) => {
      if (!Array.isArray(data)) throw new ValidationError(`expected array but got ${data}`, options);
      checkWithinRange(data.length, meta, "array length", options, !isNullable(inner.meta.default));
      return [data.map((_, index) => property(data, index, inner, options))];
    });
    Schema.extend("dict", (data, { inner, sKey }, options, strict) => {
      if (!isPlainObject(data)) throw new ValidationError(`expected object but got ${data}`, options);
      const result = {};
      for (const key2 in data) {
        let rKey;
        try {
          rKey = Schema.resolve(key2, sKey, options)[0];
        } catch (error) {
          if (strict) continue;
          throw error;
        }
        result[rKey] = property(data, key2, inner, options);
        data[rKey] = data[key2];
        if (key2 !== rKey) delete data[key2];
      }
      return [result];
    });
    Schema.extend("tuple", (data, { list }, options, strict) => {
      if (!Array.isArray(data)) throw new ValidationError(`expected array but got ${data}`, options);
      const result = list.map((inner, index) => property(data, index, inner, options));
      if (strict) return [result];
      result.push(...data.slice(list.length));
      return [result];
    });
    function merge(result, data) {
      for (const key2 in data) {
        if (key2 in result) continue;
        result[key2] = data[key2];
      }
    }
    __name$8(merge, "merge");
    Schema.extend("object", (data, { dict }, options, strict) => {
      if (!isPlainObject(data)) throw new ValidationError(`expected object but got ${data}`, options);
      const result = {};
      for (const key2 in dict) {
        const value = property(data, key2, dict[key2], options);
        if (!isNullable(value) || key2 in data) {
          result[key2] = value;
        }
      }
      if (!strict) merge(result, data);
      return [result];
    });
    Schema.extend("union", (data, { list, toString }, options, strict) => {
      for (const inner of list) {
        try {
          return Schema.resolve(data, inner, options, strict);
        } catch (error) {
        }
      }
      throw new ValidationError(`expected ${toString()} but got ${JSON.stringify(data)}`, options);
    });
    Schema.extend("intersect", (data, { list, toString }, options, strict) => {
      let result;
      for (const inner of list) {
        const value = Schema.resolve(data, inner, options, true)[0];
        if (isNullable(value)) continue;
        if (isNullable(result)) {
          result = value;
        } else if (typeof result !== typeof value) {
          throw new ValidationError(`expected ${toString()} but got ${JSON.stringify(data)}`, options);
        } else if (typeof value === "object") {
          merge(result ??= {}, value);
        } else if (result !== value) {
          throw new ValidationError(`expected ${toString()} but got ${JSON.stringify(data)}`, options);
        }
      }
      if (!strict && isPlainObject(data)) merge(result, data);
      return [result];
    });
    Schema.extend("transform", (data, { inner, callback, preserve }, options) => {
      const [result, adapted = data] = Schema.resolve(data, inner, options, true);
      if (preserve) {
        return [callback(result)];
      } else {
        return [callback(result), callback(adapted)];
      }
    });
    var formatters = {};
    function defineMethod(name, keys, format) {
      formatters[name] = format;
      Object.assign(Schema, {
        [name](...args) {
          const schema = new Schema({ type: name });
          keys.forEach((key2, index) => {
            switch (key2) {
              case "sKey":
                schema.sKey = args[index] ?? Schema.string();
                break;
              case "inner":
                schema.inner = Schema.from(args[index]);
                break;
              case "list":
                schema.list = args[index].map(Schema.from);
                break;
              case "dict":
                schema.dict = mapValues(args[index], Schema.from);
                break;
              case "bits": {
                schema.bits = {};
                for (const key22 in args[index]) {
                  if (typeof args[index][key22] !== "number") continue;
                  schema.bits[key22] = args[index][key22];
                }
                break;
              }
              case "callback": {
                schema.callback = args[index];
                schema.callback["toJSON"] ||= () => schema.callback.toString();
                break;
              }
              default:
                schema[key2] = args[index];
            }
          });
          if (name === "object" || name === "dict") {
            schema.meta.default = {};
          } else if (name === "array" || name === "tuple") {
            schema.meta.default = [];
          } else if (name === "bitset") {
            schema.meta.default = 0;
          }
          return schema;
        }
      });
    }
    __name$8(defineMethod, "defineMethod");
    defineMethod("is", ["callback"], ({ callback }) => callback.name);
    defineMethod("any", [], () => "any");
    defineMethod("never", [], () => "never");
    defineMethod("const", ["value"], ({ value }) => typeof value === "string" ? JSON.stringify(value) : value);
    defineMethod("string", [], () => "string");
    defineMethod("number", [], () => "number");
    defineMethod("boolean", [], () => "boolean");
    defineMethod("bitset", ["bits"], () => "bitset");
    defineMethod("function", [], () => "function");
    defineMethod("array", ["inner"], ({ inner }) => `${inner.toString(true)}[]`);
    defineMethod("dict", ["inner", "sKey"], ({ inner, sKey }) => `{ [key: ${sKey.toString()}]: ${inner.toString()} }`);
    defineMethod("tuple", ["list"], ({ list }) => `[${list.map((inner) => inner.toString()).join(", ")}]`);
    defineMethod("object", ["dict"], ({ dict }) => {
      if (Object.keys(dict).length === 0) return "{}";
      return `{ ${Object.entries(dict).map(([key2, inner]) => {
        return `${key2}${inner.meta.required ? "" : "?"}: ${inner.toString()}`;
      }).join(", ")} }`;
    });
    defineMethod("union", ["list"], ({ list }, inline) => {
      const result = list.map(({ toString: format }) => format()).join(" | ");
      return inline ? `(${result})` : result;
    });
    defineMethod("intersect", ["list"], ({ list }) => {
      return `${list.map((inner) => inner.toString(true)).join(" & ")}`;
    });
    defineMethod("transform", ["inner", "callback", "preserve"], ({ inner }, isInner) => inner.toString(isInner));
    module.exports = Schema;
  }
});
const z = require_src();
var __defProp$7 = Object.defineProperty;
var __name$7 = (target, value) => __defProp$7(target, "name", { value, configurable: true });
var kSchemaOrder = Symbol("cordis.schema.order");
var SchemaService = class {
  constructor(ctx) {
    this.ctx = ctx;
    defineProperty(this, Service.tracker, {
      property: "ctx"
    });
  }
  static {
    __name$7(this, "SchemaService");
  }
  _data = z.intersect([]);
  extend(schema, order = 0) {
    const index = this._data.list.findIndex((a) => a[kSchemaOrder] < order);
    schema[kSchemaOrder] = order;
    return this.ctx.effect(() => {
      if (index >= 0) {
        this._data.list.splice(index, 0, schema);
      } else {
        this._data.list.push(schema);
      }
      this.ctx.emit("internal/service-schema");
      return () => {
        remove(this._data.list, schema);
        this.ctx.emit("internal/service-schema");
      };
    });
  }
  toJSON() {
    return this._data.toJSON();
  }
};
var __defProp$6 = Object.defineProperty;
var __name$6 = (target, value) => __defProp$6(target, "name", { value, configurable: true });
var TimerService = class extends Service {
  static {
    __name$6(this, "TimerService");
  }
  constructor(ctx) {
    super(ctx, "timer", true);
    ctx.mixin("timer", ["setTimeout", "setInterval", "sleep", "throttle", "debounce"]);
  }
  setTimeout(callback, delay) {
    const dispose = this[Context.current].effect(() => {
      const timer = setTimeout(() => {
        dispose();
        callback();
      }, delay);
      return () => clearTimeout(timer);
    });
    return dispose;
  }
  setInterval(callback, delay) {
    return this[Context.current].effect(() => {
      const timer = setInterval(callback, delay);
      return () => clearInterval(timer);
    });
  }
  sleep(delay) {
    const caller = this[Context.current];
    return new Promise((resolve2, reject) => {
      const dispose1 = this.setTimeout(() => {
        dispose1();
        dispose2();
        resolve2();
      }, delay);
      const dispose2 = caller.on("dispose", () => {
        dispose1();
        dispose2();
        reject(new Error("Context has been disposed"));
      });
    });
  }
  createWrapper(callback, isDisposed = false) {
    const caller = this[Context.current];
    caller.scope.assertActive();
    let timer;
    const dispose = /* @__PURE__ */ __name$6(() => {
      isDisposed = true;
      remove(caller.scope.disposables, dispose);
      clearTimeout(timer);
    }, "dispose");
    const wrapper = /* @__PURE__ */ __name$6((...args) => {
      clearTimeout(timer);
      timer = callback(args, () => !isDisposed && caller.scope.isActive);
    }, "wrapper");
    wrapper.dispose = dispose;
    caller.scope.disposables.push(dispose);
    return wrapper;
  }
  throttle(callback, delay, noTrailing) {
    let lastCall = -Infinity;
    const execute = /* @__PURE__ */ __name$6((...args) => {
      lastCall = Date.now();
      callback(...args);
    }, "execute");
    return this.createWrapper((args, isActive) => {
      const now = Date.now();
      const remaining = delay - (now - lastCall);
      if (remaining <= 0) {
        execute(...args);
      } else if (isActive()) {
        return setTimeout(execute, remaining, ...args);
      }
    }, noTrailing);
  }
  debounce(callback, delay) {
    return this.createWrapper((args, isActive) => {
      if (!isActive())
        return;
      return setTimeout(callback, delay, ...args);
    });
  }
};
var __defProp$5 = Object.defineProperty;
var __name$5 = (target, value) => __defProp$5(target, "name", { value, configurable: true });
var Context2 = class extends Context {
  static {
    __name$5(this, "Context");
  }
  baseDir;
  constructor(config) {
    super(config);
    this.baseDir = globalThis.process?.cwd?.() || "";
    this.provide("logger", void 0, true);
    this.provide("timer", void 0, true);
    this.plugin(LoggerService);
    this.plugin(TimerService);
  }
};
var Service2 = class extends Service {
  static {
    __name$5(this, "Service");
  }
  /** @deprecated use `this.ctx.logger` instead */
  logger;
  schema;
  constructor(...args) {
    super(...args);
    this.logger = this.ctx.logger(this.name);
    this.schema = new SchemaService(this.ctx);
  }
  [Service.setup]() {
    this.ctx = new Context2();
  }
};
function src_default$2() {
}
__name$5(src_default$2, "default");
const llonebotError = {
  ffmpegError: "",
  httpServerError: "",
  wsServerError: "",
  otherError: "LLOneBot "
};
const DATA_DIR = path__default.resolve("data");
const TEMP_DIR = path__default.join(DATA_DIR, "temp");
const LOG_DIR = path__default.join(DATA_DIR, "logs");
function getFixedDataDir() {
  let dataDir = "";
  if (process.platform === "win32") {
    dataDir = path__default.join(process.env["LOCALAPPDATA"], "llonebot");
  } else {
    dataDir = path__default.join(os.homedir(), ".llonebot");
  }
  if (!fs$1.existsSync(dataDir)) {
    try {
      fs$1.mkdirSync(dataDir);
    } catch (e) {
    }
  }
  return dataDir;
}
const selfInfo = {
  uid: "",
  uin: "",
  nick: "",
  online: true
};
class Log {
  static name = "logger";
  constructor(ctx, cfg) {
    Logger.targets.splice(0, Logger.targets.length);
    let enable = cfg.enable;
    const file = path__default.join(LOG_DIR, cfg.filename);
    const target = {
      colors: 0,
      record: (record) => {
        const dateTime = new Date(record.timestamp);
        const dateTimeStr = `${dateTime.getFullYear()}-${(dateTime.getMonth() + 1).toString().padStart(2, "0")}-${dateTime.getDate().toString().padStart(2, "0")} ${dateTime.getHours().toString().padStart(2, "0")}:${dateTime.getMinutes().toString().padStart(2, "0")}:${dateTime.getSeconds().toString().padStart(2, "0")}`;
        let content = `${dateTimeStr} | ${record.content}

`;
        console.log(content);
        if (!enable) {
          return;
        }
        content = `[${record.type}] | ${content}`;
        appendFile(file, content, noop);
      }
    };
    Logger.targets.push(target);
    ctx.on("llob/config-updated", (input) => {
      enable = input.log;
    });
  }
}
var indexMinimal = {};
var minimal$1 = {};
var aspromise;
var hasRequiredAspromise;
function requireAspromise() {
  if (hasRequiredAspromise) return aspromise;
  hasRequiredAspromise = 1;
  aspromise = asPromise;
  function asPromise(fn, ctx) {
    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while (index < arguments.length)
      params[offset++] = arguments[index++];
    return new Promise(function executor(resolve2, reject) {
      params[offset] = function callback(err) {
        if (pending) {
          pending = false;
          if (err)
            reject(err);
          else {
            var params2 = new Array(arguments.length - 1), offset2 = 0;
            while (offset2 < params2.length)
              params2[offset2++] = arguments[offset2];
            resolve2.apply(null, params2);
          }
        }
      };
      try {
        fn.apply(ctx || null, params);
      } catch (err) {
        if (pending) {
          pending = false;
          reject(err);
        }
      }
    });
  }
  return aspromise;
}
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  (function(exports) {
    var base642 = exports;
    base642.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (var i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    base642.encode = function encode2(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode2(string, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c2 = string.charCodeAt(i2++);
        if (c2 === 61 && j > 1)
          break;
        if ((c2 = s64[c2]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c2;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c2 & 48) >> 4;
            t = c2;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c2 & 60) >> 2;
            t = c2;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c2;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  })(base64);
  return base64;
}
var eventemitter;
var hasRequiredEventemitter;
function requireEventemitter() {
  if (hasRequiredEventemitter) return eventemitter;
  hasRequiredEventemitter = 1;
  eventemitter = EventEmitter;
  function EventEmitter() {
    this._listeners = {};
  }
  EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
      fn,
      ctx: ctx || this
    });
    return this;
  };
  EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === void 0)
      this._listeners = {};
    else {
      if (fn === void 0)
        this._listeners[evt] = [];
      else {
        var listeners = this._listeners[evt];
        for (var i = 0; i < listeners.length; )
          if (listeners[i].fn === fn)
            listeners.splice(i, 1);
          else
            ++i;
      }
    }
    return this;
  };
  EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
      var args = [], i = 1;
      for (; i < arguments.length; )
        args.push(arguments[i++]);
      for (i = 0; i < listeners.length; )
        listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
  };
  return eventemitter;
}
var float;
var hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat) return float;
  hasRequiredFloat = 1;
  float = factory(factory);
  function factory(exports) {
    if (typeof Float32Array !== "undefined") (function() {
      var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
      function writeFloat_f32_cpy(val, buf, pos2) {
        f32[0] = val;
        buf[pos2] = f8b[0];
        buf[pos2 + 1] = f8b[1];
        buf[pos2 + 2] = f8b[2];
        buf[pos2 + 3] = f8b[3];
      }
      function writeFloat_f32_rev(val, buf, pos2) {
        f32[0] = val;
        buf[pos2] = f8b[3];
        buf[pos2 + 1] = f8b[2];
        buf[pos2 + 2] = f8b[1];
        buf[pos2 + 3] = f8b[0];
      }
      exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
      exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
      function readFloat_f32_cpy(buf, pos2) {
        f8b[0] = buf[pos2];
        f8b[1] = buf[pos2 + 1];
        f8b[2] = buf[pos2 + 2];
        f8b[3] = buf[pos2 + 3];
        return f32[0];
      }
      function readFloat_f32_rev(buf, pos2) {
        f8b[3] = buf[pos2];
        f8b[2] = buf[pos2 + 1];
        f8b[1] = buf[pos2 + 2];
        f8b[0] = buf[pos2 + 3];
        return f32[0];
      }
      exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
      exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    })();
    else (function() {
      function writeFloat_ieee754(writeUint, val, buf, pos2) {
        var sign2 = val < 0 ? 1 : 0;
        if (sign2)
          val = -val;
        if (val === 0)
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf, pos2);
        else if (isNaN(val))
          writeUint(2143289344, buf, pos2);
        else if (val > 34028234663852886e22)
          writeUint((sign2 << 31 | 2139095040) >>> 0, buf, pos2);
        else if (val < 11754943508222875e-54)
          writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos2);
        else {
          var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
          writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos2);
        }
      }
      exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
      exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
      function readFloat_ieee754(readUint, buf, pos2) {
        var uint = readUint(buf, pos2), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
        return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
      }
      exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
      exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
    if (typeof Float64Array !== "undefined") (function() {
      var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
      function writeDouble_f64_cpy(val, buf, pos2) {
        f64[0] = val;
        buf[pos2] = f8b[0];
        buf[pos2 + 1] = f8b[1];
        buf[pos2 + 2] = f8b[2];
        buf[pos2 + 3] = f8b[3];
        buf[pos2 + 4] = f8b[4];
        buf[pos2 + 5] = f8b[5];
        buf[pos2 + 6] = f8b[6];
        buf[pos2 + 7] = f8b[7];
      }
      function writeDouble_f64_rev(val, buf, pos2) {
        f64[0] = val;
        buf[pos2] = f8b[7];
        buf[pos2 + 1] = f8b[6];
        buf[pos2 + 2] = f8b[5];
        buf[pos2 + 3] = f8b[4];
        buf[pos2 + 4] = f8b[3];
        buf[pos2 + 5] = f8b[2];
        buf[pos2 + 6] = f8b[1];
        buf[pos2 + 7] = f8b[0];
      }
      exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
      exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
      function readDouble_f64_cpy(buf, pos2) {
        f8b[0] = buf[pos2];
        f8b[1] = buf[pos2 + 1];
        f8b[2] = buf[pos2 + 2];
        f8b[3] = buf[pos2 + 3];
        f8b[4] = buf[pos2 + 4];
        f8b[5] = buf[pos2 + 5];
        f8b[6] = buf[pos2 + 6];
        f8b[7] = buf[pos2 + 7];
        return f64[0];
      }
      function readDouble_f64_rev(buf, pos2) {
        f8b[7] = buf[pos2];
        f8b[6] = buf[pos2 + 1];
        f8b[5] = buf[pos2 + 2];
        f8b[4] = buf[pos2 + 3];
        f8b[3] = buf[pos2 + 4];
        f8b[2] = buf[pos2 + 5];
        f8b[1] = buf[pos2 + 6];
        f8b[0] = buf[pos2 + 7];
        return f64[0];
      }
      exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
      exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    })();
    else (function() {
      function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos2) {
        var sign2 = val < 0 ? 1 : 0;
        if (sign2)
          val = -val;
        if (val === 0) {
          writeUint(0, buf, pos2 + off0);
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf, pos2 + off1);
        } else if (isNaN(val)) {
          writeUint(0, buf, pos2 + off0);
          writeUint(2146959360, buf, pos2 + off1);
        } else if (val > 17976931348623157e292) {
          writeUint(0, buf, pos2 + off0);
          writeUint((sign2 << 31 | 2146435072) >>> 0, buf, pos2 + off1);
        } else {
          var mantissa;
          if (val < 22250738585072014e-324) {
            mantissa = val / 5e-324;
            writeUint(mantissa >>> 0, buf, pos2 + off0);
            writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf, pos2 + off1);
          } else {
            var exponent = Math.floor(Math.log(val) / Math.LN2);
            if (exponent === 1024)
              exponent = 1023;
            mantissa = val * Math.pow(2, -exponent);
            writeUint(mantissa * 4503599627370496 >>> 0, buf, pos2 + off0);
            writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos2 + off1);
          }
        }
      }
      exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
      exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
      function readDouble_ieee754(readUint, off0, off1, buf, pos2) {
        var lo = readUint(buf, pos2 + off0), hi = readUint(buf, pos2 + off1);
        var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
        return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
      }
      exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
      exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
    return exports;
  }
  function writeUintLE(val, buf, pos2) {
    buf[pos2] = val & 255;
    buf[pos2 + 1] = val >>> 8 & 255;
    buf[pos2 + 2] = val >>> 16 & 255;
    buf[pos2 + 3] = val >>> 24;
  }
  function writeUintBE(val, buf, pos2) {
    buf[pos2] = val >>> 24;
    buf[pos2 + 1] = val >>> 16 & 255;
    buf[pos2 + 2] = val >>> 8 & 255;
    buf[pos2 + 3] = val & 255;
  }
  function readUintLE(buf, pos2) {
    return (buf[pos2] | buf[pos2 + 1] << 8 | buf[pos2 + 2] << 16 | buf[pos2 + 3] << 24) >>> 0;
  }
  function readUintBE(buf, pos2) {
    return (buf[pos2] << 24 | buf[pos2 + 1] << 16 | buf[pos2 + 2] << 8 | buf[pos2 + 3]) >>> 0;
  }
  return float;
}
var inquire_1;
var hasRequiredInquire;
function requireInquire() {
  if (hasRequiredInquire) return inquire_1;
  hasRequiredInquire = 1;
  inquire_1 = inquire;
  function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (e) {
    }
    return null;
  }
  return inquire_1;
}
var utf8 = {};
var hasRequiredUtf8;
function requireUtf8() {
  if (hasRequiredUtf8) return utf8;
  hasRequiredUtf8 = 1;
  (function(exports) {
    var utf82 = exports;
    utf82.length = function utf8_length(string) {
      var len = 0, c2 = 0;
      for (var i = 0; i < string.length; ++i) {
        c2 = string.charCodeAt(i);
        if (c2 < 128)
          len += 1;
        else if (c2 < 2048)
          len += 2;
        else if ((c2 & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf82.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf82.write = function utf8_write(string, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  })(utf8);
  return utf8;
}
var pool_1;
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool) return pool_1;
  hasRequiredPool = 1;
  pool_1 = pool;
  function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size2) {
      if (size2 < 1 || size2 > MAX)
        return alloc(size2);
      if (offset + size2 > SIZE) {
        slab = alloc(SIZE);
        offset = 0;
      }
      var buf = slice.call(slab, offset, offset += size2);
      if (offset & 7)
        offset = (offset | 7) + 1;
      return buf;
    };
  }
  return pool_1;
}
var longbits;
var hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits) return longbits;
  hasRequiredLongbits = 1;
  longbits = LongBits;
  var util2 = requireMinimal$1();
  function LongBits(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero = LongBits.zero = new LongBits(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign2 = value < 0;
    if (sign2)
      value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign2) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits(lo, hi);
  };
  LongBits.from = function from2(value) {
    if (typeof value === "number")
      return LongBits.fromNumber(value);
    if (util2.isString(value)) {
      if (util2.Long)
        value = util2.Long.fromString(value);
      else
        return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits.prototype.toLong = function toLong(unsigned) {
    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
      return zero;
    return new LongBits(
      (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
      (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
    );
  };
  LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  };
  LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
  return longbits;
}
var hasRequiredMinimal$1;
function requireMinimal$1() {
  if (hasRequiredMinimal$1) return minimal$1;
  hasRequiredMinimal$1 = 1;
  (function(exports) {
    var util2 = exports;
    util2.asPromise = requireAspromise();
    util2.base64 = requireBase64();
    util2.EventEmitter = requireEventemitter();
    util2.float = requireFloat();
    util2.inquire = requireInquire();
    util2.utf8 = requireUtf8();
    util2.pool = requirePool();
    util2.LongBits = requireLongbits();
    util2.isNode = Boolean(typeof commonjsGlobal !== "undefined" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);
    util2.global = util2.isNode && commonjsGlobal || typeof window !== "undefined" && window || typeof self !== "undefined" && self || minimal$1;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util2.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util2.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util2.LongBits.fromHash(hash);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util2.merge = merge;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get2() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding2) {
        return new Buffer2(value, encoding2);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  })(minimal$1);
  return minimal$1;
}
var writer;
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter) return writer;
  hasRequiredWriter = 1;
  writer = Writer;
  var util2 = requireMinimal$1();
  var BufferWriter;
  var LongBits = util2.LongBits, base642 = util2.base64, utf82 = util2.utf8;
  function Op(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
  function noop2() {
  }
  function State2(writer2) {
    this.head = writer2.head;
    this.tail = writer2.tail;
    this.len = writer2.len;
    this.next = writer2.states;
  }
  function Writer() {
    this.len = 0;
    this.head = new Op(noop2, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  var create = function create2() {
    return util2.Buffer ? function create_buffer_setup() {
      return (Writer.create = function create_buffer() {
        return new BufferWriter();
      })();
    } : function create_array() {
      return new Writer();
    };
  };
  Writer.create = create();
  Writer.alloc = function alloc(size) {
    return new util2.Array(size);
  };
  if (util2.Array !== Array)
    Writer.alloc = util2.pool(Writer.alloc, util2.Array.prototype.subarray);
  Writer.prototype._push = function push2(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  };
  function writeByte(val, buf, pos2) {
    buf[pos2] = val & 255;
  }
  function writeVarint32(val, buf, pos2) {
    while (val > 127) {
      buf[pos2++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos2] = val;
  }
  function VarintOp(len, val) {
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp(
      (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
      value
    )).len;
    return this;
  };
  Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  };
  Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };
  function writeVarint64(val, buf, pos2) {
    while (val.hi) {
      buf[pos2++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos2++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos2++] = val.lo;
  }
  Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.int64 = Writer.prototype.uint64;
  Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  };
  function writeFixed32(val, buf, pos2) {
    buf[pos2] = val & 255;
    buf[pos2 + 1] = val >>> 8 & 255;
    buf[pos2 + 2] = val >>> 16 & 255;
    buf[pos2 + 3] = val >>> 24;
  }
  Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  };
  Writer.prototype.sfixed32 = Writer.prototype.fixed32;
  Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };
  Writer.prototype.sfixed64 = Writer.prototype.fixed64;
  Writer.prototype.float = function write_float(value) {
    return this._push(util2.float.writeFloatLE, 4, value);
  };
  Writer.prototype.double = function write_double(value) {
    return this._push(util2.float.writeDoubleLE, 8, value);
  };
  var writeBytes = util2.Array.prototype.set ? function writeBytes_set(val, buf, pos2) {
    buf.set(val, pos2);
  } : function writeBytes_for(val, buf, pos2) {
    for (var i = 0; i < val.length; ++i)
      buf[pos2 + i] = val[i];
  };
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util2.isString(value)) {
      var buf = Writer.alloc(len = base642.length(value));
      base642.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };
  Writer.prototype.string = function write_string(value) {
    var len = utf82.length(value);
    return len ? this.uint32(len)._push(utf82.write, len, value) : this._push(writeByte, 1, 0);
  };
  Writer.prototype.fork = function fork() {
    this.states = new State2(this);
    this.head = this.tail = new Op(noop2, 0, 0);
    this.len = 0;
    return this;
  };
  Writer.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  };
  Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos2 = 0;
    while (head) {
      head.fn(head.val, buf, pos2);
      pos2 += head.len;
      head = head.next;
    }
    return buf;
  };
  Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
  };
  return writer;
}
var writer_buffer;
var hasRequiredWriter_buffer;
function requireWriter_buffer() {
  if (hasRequiredWriter_buffer) return writer_buffer;
  hasRequiredWriter_buffer = 1;
  writer_buffer = BufferWriter;
  var Writer = requireWriter();
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
  var util2 = requireMinimal$1();
  function BufferWriter() {
    Writer.call(this);
  }
  BufferWriter._configure = function() {
    BufferWriter.alloc = util2._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos2) {
      buf.set(val, pos2);
    } : function writeBytesBuffer_copy(val, buf, pos2) {
      if (val.copy)
        val.copy(buf, pos2, 0, val.length);
      else for (var i = 0; i < val.length; )
        buf[pos2++] = val[i++];
    };
  };
  BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util2.isString(value))
      value = util2._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
      this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
  };
  function writeStringBuffer(val, buf, pos2) {
    if (val.length < 40)
      util2.utf8.write(val, buf, pos2);
    else if (buf.utf8Write)
      buf.utf8Write(val, pos2);
    else
      buf.write(val, pos2);
  }
  BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util2.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
      this._push(writeStringBuffer, len, value);
    return this;
  };
  BufferWriter._configure();
  return writer_buffer;
}
var reader;
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  reader = Reader;
  var util2 = requireMinimal$1();
  var BufferReader;
  var LongBits = util2.LongBits, utf82 = util2.utf8;
  function indexOutOfRange(reader2, writeLength) {
    return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
  }
  function Reader(buffer2) {
    this.buf = buffer2;
    this.pos = 0;
    this.len = buffer2.length;
  }
  var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
    if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
      return new Reader(buffer2);
    throw Error("illegal buffer");
  } : function create_array2(buffer2) {
    if (Array.isArray(buffer2))
      return new Reader(buffer2);
    throw Error("illegal buffer");
  };
  var create = function create2() {
    return util2.Buffer ? function create_buffer_setup(buffer2) {
      return (Reader.create = function create_buffer(buffer3) {
        return util2.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
      })(buffer2);
    } : create_array;
  };
  Reader.create = create();
  Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
  util2.Array.prototype.slice;
  Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
    var value = 4294967295;
    return function read_uint32() {
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128) return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128) return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128) return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128) return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128) return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    };
  }();
  Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  };
  function readLongVarint() {
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
      for (; i < 4; ++i) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
      i = 0;
    } else {
      for (; i < 3; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (; i < 5; ++i) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    } else {
      for (; i < 5; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    }
    throw Error("invalid varint encoding");
  }
  Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
  };
  function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  }
  Reader.prototype.fixed32 = function read_fixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
  };
  Reader.prototype.sfixed32 = function read_sfixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
  };
  function readFixed64() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }
  Reader.prototype.float = function read_float() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util2.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  };
  Reader.prototype.double = function read_double() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util2.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  };
  Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    if (end > this.len)
      throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf))
      return this.buf.slice(start, end);
    if (start === end) {
      var nativeBuffer = util2.Buffer;
      return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
  };
  Reader.prototype.string = function read_string() {
    var bytes2 = this.bytes();
    return utf82.read(bytes2, 0, bytes2.length);
  };
  Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
      if (this.pos + length > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      /* istanbul ignore next */
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();
    var fn = util2.Long ? "toLong" : (
      /* istanbul ignore next */
      "toNumber"
    );
    util2.merge(Reader.prototype, {
      int64: function read_int64() {
        return readLongVarint.call(this)[fn](false);
      },
      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn](true);
      },
      sint64: function read_sint64() {
        return readLongVarint.call(this).zzDecode()[fn](false);
      },
      fixed64: function read_fixed64() {
        return readFixed64.call(this)[fn](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed64.call(this)[fn](false);
      }
    });
  };
  return reader;
}
var reader_buffer;
var hasRequiredReader_buffer;
function requireReader_buffer() {
  if (hasRequiredReader_buffer) return reader_buffer;
  hasRequiredReader_buffer = 1;
  reader_buffer = BufferReader;
  var Reader = requireReader();
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
  var util2 = requireMinimal$1();
  function BufferReader(buffer2) {
    Reader.call(this, buffer2);
  }
  BufferReader._configure = function() {
    if (util2.Buffer)
      BufferReader.prototype._slice = util2.Buffer.prototype.slice;
  };
  BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
  };
  BufferReader._configure();
  return reader_buffer;
}
var rpc = {};
var service;
var hasRequiredService;
function requireService() {
  if (hasRequiredService) return service;
  hasRequiredService = 1;
  service = Service3;
  var util2 = requireMinimal$1();
  (Service3.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service3;
  function Service3(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util2.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  }
  Service3.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
    if (!request2)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util2.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return void 0;
    }
    try {
      return self2.rpcImpl(
        method,
        requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
        function rpcCallback(err, response2) {
          if (err) {
            self2.emit("error", err, method);
            return callback(err);
          }
          if (response2 === null) {
            self2.end(
              /* endedByRPC */
              true
            );
            return void 0;
          }
          if (!(response2 instanceof responseCtor)) {
            try {
              response2 = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response2);
            } catch (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
          }
          self2.emit("data", response2, method);
          return callback(null, response2);
        }
      );
    } catch (err) {
      self2.emit("error", err, method);
      setTimeout(function() {
        callback(err);
      }, 0);
      return void 0;
    }
  };
  Service3.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
  return service;
}
var hasRequiredRpc;
function requireRpc() {
  if (hasRequiredRpc) return rpc;
  hasRequiredRpc = 1;
  (function(exports) {
    var rpc2 = exports;
    rpc2.Service = requireService();
  })(rpc);
  return rpc;
}
var roots;
var hasRequiredRoots;
function requireRoots() {
  if (hasRequiredRoots) return roots;
  hasRequiredRoots = 1;
  roots = {};
  return roots;
}
var hasRequiredIndexMinimal;
function requireIndexMinimal() {
  if (hasRequiredIndexMinimal) return indexMinimal;
  hasRequiredIndexMinimal = 1;
  (function(exports) {
    var protobuf = exports;
    protobuf.build = "minimal";
    protobuf.Writer = requireWriter();
    protobuf.BufferWriter = requireWriter_buffer();
    protobuf.Reader = requireReader();
    protobuf.BufferReader = requireReader_buffer();
    protobuf.util = requireMinimal$1();
    protobuf.rpc = requireRpc();
    protobuf.roots = requireRoots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  })(indexMinimal);
  return indexMinimal;
}
var minimal;
var hasRequiredMinimal;
function requireMinimal() {
  if (hasRequiredMinimal) return minimal;
  hasRequiredMinimal = 1;
  minimal = requireIndexMinimal();
  return minimal;
}
var minimalExports = requireMinimal();
const $protobuf = /* @__PURE__ */ getDefaultExportFromCjs(minimalExports);
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const SysMsg = $root.SysMsg = (() => {
  const SysMsg2 = {};
  SysMsg2.LikeDetail = function() {
    function LikeDetail(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    LikeDetail.prototype.txt = "";
    LikeDetail.prototype.uin = 0;
    LikeDetail.prototype.nickname = "";
    LikeDetail.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.txt != null && Object.hasOwnProperty.call(message, "txt"))
        writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).string(message.txt);
      if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint32(message.uin);
      if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
        writer2.uint32(
          /* id 5, wireType 2 =*/
          42
        ).string(message.nickname);
      return writer2;
    };
    LikeDetail.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.SysMsg.LikeDetail();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.txt = reader2.string();
            break;
          }
          case 3: {
            message.uin = reader2.uint32();
            break;
          }
          case 5: {
            message.nickname = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    LikeDetail.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/SysMsg.LikeDetail";
    };
    return LikeDetail;
  }();
  SysMsg2.LikeMsg = function() {
    function LikeMsg(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    LikeMsg.prototype.count = 0;
    LikeMsg.prototype.time = 0;
    LikeMsg.prototype.detail = null;
    LikeMsg.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.count != null && Object.hasOwnProperty.call(message, "count"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.count);
      if (message.time != null && Object.hasOwnProperty.call(message, "time"))
        writer2.uint32(
          /* id 2, wireType 0 =*/
          16
        ).uint32(message.time);
      if (message.detail != null && Object.hasOwnProperty.call(message, "detail"))
        $root.SysMsg.LikeDetail.encode(message.detail, writer2.uint32(
          /* id 3, wireType 2 =*/
          26
        ).fork()).ldelim();
      return writer2;
    };
    LikeMsg.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.SysMsg.LikeMsg();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.count = reader2.uint32();
            break;
          }
          case 2: {
            message.time = reader2.uint32();
            break;
          }
          case 3: {
            message.detail = $root.SysMsg.LikeDetail.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    LikeMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/SysMsg.LikeMsg";
    };
    return LikeMsg;
  }();
  SysMsg2.ProfileLikeSubTip = function() {
    function ProfileLikeSubTip(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ProfileLikeSubTip.prototype.msg = null;
    ProfileLikeSubTip.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
        $root.SysMsg.LikeMsg.encode(message.msg, writer2.uint32(
          /* id 14, wireType 2 =*/
          114
        ).fork()).ldelim();
      return writer2;
    };
    ProfileLikeSubTip.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.SysMsg.ProfileLikeSubTip();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 14: {
            message.msg = $root.SysMsg.LikeMsg.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    ProfileLikeSubTip.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/SysMsg.ProfileLikeSubTip";
    };
    return ProfileLikeSubTip;
  }();
  SysMsg2.ProfileLikeTip = function() {
    function ProfileLikeTip(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ProfileLikeTip.prototype.msgType = 0;
    ProfileLikeTip.prototype.subType = 0;
    ProfileLikeTip.prototype.content = null;
    ProfileLikeTip.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.msgType != null && Object.hasOwnProperty.call(message, "msgType"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.msgType);
      if (message.subType != null && Object.hasOwnProperty.call(message, "subType"))
        writer2.uint32(
          /* id 2, wireType 0 =*/
          16
        ).uint32(message.subType);
      if (message.content != null && Object.hasOwnProperty.call(message, "content"))
        $root.SysMsg.ProfileLikeSubTip.encode(message.content, writer2.uint32(
          /* id 203, wireType 2 =*/
          1626
        ).fork()).ldelim();
      return writer2;
    };
    ProfileLikeTip.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.SysMsg.ProfileLikeTip();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.msgType = reader2.uint32();
            break;
          }
          case 2: {
            message.subType = reader2.uint32();
            break;
          }
          case 203: {
            message.content = $root.SysMsg.ProfileLikeSubTip.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    ProfileLikeTip.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/SysMsg.ProfileLikeTip";
    };
    return ProfileLikeTip;
  }();
  SysMsg2.GroupMemberChange = function() {
    function GroupMemberChange(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    GroupMemberChange.prototype.groupCode = 0;
    GroupMemberChange.prototype.memberUid = "";
    GroupMemberChange.prototype.type = 0;
    GroupMemberChange.prototype.adminUid = "";
    GroupMemberChange.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.groupCode != null && Object.hasOwnProperty.call(message, "groupCode"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.groupCode);
      if (message.memberUid != null && Object.hasOwnProperty.call(message, "memberUid"))
        writer2.uint32(
          /* id 3, wireType 2 =*/
          26
        ).string(message.memberUid);
      if (message.type != null && Object.hasOwnProperty.call(message, "type"))
        writer2.uint32(
          /* id 4, wireType 0 =*/
          32
        ).uint32(message.type);
      if (message.adminUid != null && Object.hasOwnProperty.call(message, "adminUid"))
        writer2.uint32(
          /* id 5, wireType 2 =*/
          42
        ).string(message.adminUid);
      return writer2;
    };
    GroupMemberChange.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.SysMsg.GroupMemberChange();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.groupCode = reader2.uint32();
            break;
          }
          case 3: {
            message.memberUid = reader2.string();
            break;
          }
          case 4: {
            message.type = reader2.uint32();
            break;
          }
          case 5: {
            message.adminUid = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    GroupMemberChange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/SysMsg.GroupMemberChange";
    };
    return GroupMemberChange;
  }();
  SysMsg2.GroupInvite = function() {
    function GroupInvite(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    GroupInvite.prototype.groupCode = 0;
    GroupInvite.prototype.operatorUid = "";
    GroupInvite.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.groupCode != null && Object.hasOwnProperty.call(message, "groupCode"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.groupCode);
      if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
        writer2.uint32(
          /* id 5, wireType 2 =*/
          42
        ).string(message.operatorUid);
      return writer2;
    };
    GroupInvite.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.SysMsg.GroupInvite();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.groupCode = reader2.uint32();
            break;
          }
          case 5: {
            message.operatorUid = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    GroupInvite.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/SysMsg.GroupInvite";
    };
    return GroupInvite;
  }();
  return SysMsg2;
})();
const Msg = $root.Msg = (() => {
  const Msg2 = {};
  Msg2.RoutingHead = function() {
    function RoutingHead(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    RoutingHead.prototype.fromUin = null;
    RoutingHead.prototype.fromUid = null;
    RoutingHead.prototype.fromAppid = null;
    RoutingHead.prototype.fromInstid = null;
    RoutingHead.prototype.toUin = null;
    RoutingHead.prototype.toUid = null;
    RoutingHead.prototype.c2c = null;
    RoutingHead.prototype.group = null;
    let $oneOfFields;
    Object.defineProperty(RoutingHead.prototype, "_fromUin", {
      get: $util.oneOfGetter($oneOfFields = ["fromUin"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(RoutingHead.prototype, "_fromUid", {
      get: $util.oneOfGetter($oneOfFields = ["fromUid"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(RoutingHead.prototype, "_fromAppid", {
      get: $util.oneOfGetter($oneOfFields = ["fromAppid"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(RoutingHead.prototype, "_fromInstid", {
      get: $util.oneOfGetter($oneOfFields = ["fromInstid"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(RoutingHead.prototype, "_toUin", {
      get: $util.oneOfGetter($oneOfFields = ["toUin"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(RoutingHead.prototype, "_toUid", {
      get: $util.oneOfGetter($oneOfFields = ["toUid"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(RoutingHead.prototype, "_c2c", {
      get: $util.oneOfGetter($oneOfFields = ["c2c"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(RoutingHead.prototype, "_group", {
      get: $util.oneOfGetter($oneOfFields = ["group"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    RoutingHead.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.fromUin != null && Object.hasOwnProperty.call(message, "fromUin"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint64(message.fromUin);
      if (message.fromUid != null && Object.hasOwnProperty.call(message, "fromUid"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).string(message.fromUid);
      if (message.fromAppid != null && Object.hasOwnProperty.call(message, "fromAppid"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint32(message.fromAppid);
      if (message.fromInstid != null && Object.hasOwnProperty.call(message, "fromInstid"))
        writer2.uint32(
          /* id 4, wireType 0 =*/
          32
        ).uint32(message.fromInstid);
      if (message.toUin != null && Object.hasOwnProperty.call(message, "toUin"))
        writer2.uint32(
          /* id 5, wireType 0 =*/
          40
        ).uint64(message.toUin);
      if (message.toUid != null && Object.hasOwnProperty.call(message, "toUid"))
        writer2.uint32(
          /* id 6, wireType 2 =*/
          50
        ).string(message.toUid);
      if (message.c2c != null && Object.hasOwnProperty.call(message, "c2c"))
        $root.Msg.C2c.encode(message.c2c, writer2.uint32(
          /* id 7, wireType 2 =*/
          58
        ).fork()).ldelim();
      if (message.group != null && Object.hasOwnProperty.call(message, "group"))
        $root.Msg.Group.encode(message.group, writer2.uint32(
          /* id 8, wireType 2 =*/
          66
        ).fork()).ldelim();
      return writer2;
    };
    RoutingHead.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.RoutingHead();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.fromUin = reader2.uint64();
            break;
          }
          case 2: {
            message.fromUid = reader2.string();
            break;
          }
          case 3: {
            message.fromAppid = reader2.uint32();
            break;
          }
          case 4: {
            message.fromInstid = reader2.uint32();
            break;
          }
          case 5: {
            message.toUin = reader2.uint64();
            break;
          }
          case 6: {
            message.toUid = reader2.string();
            break;
          }
          case 7: {
            message.c2c = $root.Msg.C2c.decode(reader2, reader2.uint32());
            break;
          }
          case 8: {
            message.group = $root.Msg.Group.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    RoutingHead.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.RoutingHead";
    };
    return RoutingHead;
  }();
  Msg2.C2c = function() {
    function C2c(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    C2c.prototype.friendName = null;
    let $oneOfFields;
    Object.defineProperty(C2c.prototype, "_friendName", {
      get: $util.oneOfGetter($oneOfFields = ["friendName"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    C2c.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.friendName != null && Object.hasOwnProperty.call(message, "friendName"))
        writer2.uint32(
          /* id 6, wireType 2 =*/
          50
        ).string(message.friendName);
      return writer2;
    };
    C2c.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.C2c();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 6: {
            message.friendName = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    C2c.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.C2c";
    };
    return C2c;
  }();
  Msg2.Group = function() {
    function Group(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Group.prototype.groupCode = null;
    Group.prototype.groupType = null;
    Group.prototype.groupInfoSeq = null;
    Group.prototype.groupCard = null;
    Group.prototype.groupCardType = null;
    Group.prototype.groupLevel = null;
    Group.prototype.groupName = null;
    Group.prototype.extGroupKeyInfo = null;
    Group.prototype.msgFlag = null;
    let $oneOfFields;
    Object.defineProperty(Group.prototype, "_groupCode", {
      get: $util.oneOfGetter($oneOfFields = ["groupCode"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Group.prototype, "_groupType", {
      get: $util.oneOfGetter($oneOfFields = ["groupType"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Group.prototype, "_groupInfoSeq", {
      get: $util.oneOfGetter($oneOfFields = ["groupInfoSeq"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Group.prototype, "_groupCard", {
      get: $util.oneOfGetter($oneOfFields = ["groupCard"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Group.prototype, "_groupCardType", {
      get: $util.oneOfGetter($oneOfFields = ["groupCardType"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Group.prototype, "_groupLevel", {
      get: $util.oneOfGetter($oneOfFields = ["groupLevel"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Group.prototype, "_groupName", {
      get: $util.oneOfGetter($oneOfFields = ["groupName"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Group.prototype, "_extGroupKeyInfo", {
      get: $util.oneOfGetter($oneOfFields = ["extGroupKeyInfo"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Group.prototype, "_msgFlag", {
      get: $util.oneOfGetter($oneOfFields = ["msgFlag"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Group.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.groupCode != null && Object.hasOwnProperty.call(message, "groupCode"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint64(message.groupCode);
      if (message.groupType != null && Object.hasOwnProperty.call(message, "groupType"))
        writer2.uint32(
          /* id 2, wireType 0 =*/
          16
        ).uint32(message.groupType);
      if (message.groupInfoSeq != null && Object.hasOwnProperty.call(message, "groupInfoSeq"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint64(message.groupInfoSeq);
      if (message.groupCard != null && Object.hasOwnProperty.call(message, "groupCard"))
        writer2.uint32(
          /* id 4, wireType 2 =*/
          34
        ).string(message.groupCard);
      if (message.groupCardType != null && Object.hasOwnProperty.call(message, "groupCardType"))
        writer2.uint32(
          /* id 5, wireType 0 =*/
          40
        ).uint32(message.groupCardType);
      if (message.groupLevel != null && Object.hasOwnProperty.call(message, "groupLevel"))
        writer2.uint32(
          /* id 6, wireType 0 =*/
          48
        ).uint32(message.groupLevel);
      if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
        writer2.uint32(
          /* id 7, wireType 2 =*/
          58
        ).string(message.groupName);
      if (message.extGroupKeyInfo != null && Object.hasOwnProperty.call(message, "extGroupKeyInfo"))
        writer2.uint32(
          /* id 8, wireType 2 =*/
          66
        ).string(message.extGroupKeyInfo);
      if (message.msgFlag != null && Object.hasOwnProperty.call(message, "msgFlag"))
        writer2.uint32(
          /* id 9, wireType 0 =*/
          72
        ).uint32(message.msgFlag);
      return writer2;
    };
    Group.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.Group();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.groupCode = reader2.uint64();
            break;
          }
          case 2: {
            message.groupType = reader2.uint32();
            break;
          }
          case 3: {
            message.groupInfoSeq = reader2.uint64();
            break;
          }
          case 4: {
            message.groupCard = reader2.string();
            break;
          }
          case 5: {
            message.groupCardType = reader2.uint32();
            break;
          }
          case 6: {
            message.groupLevel = reader2.uint32();
            break;
          }
          case 7: {
            message.groupName = reader2.string();
            break;
          }
          case 8: {
            message.extGroupKeyInfo = reader2.string();
            break;
          }
          case 9: {
            message.msgFlag = reader2.uint32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    Group.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.Group";
    };
    return Group;
  }();
  Msg2.ContentHead = function() {
    function ContentHead(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ContentHead.prototype.msgType = null;
    ContentHead.prototype.subType = null;
    ContentHead.prototype.c2cCmd = null;
    ContentHead.prototype.random = null;
    ContentHead.prototype.msgSeq = null;
    ContentHead.prototype.msgTime = null;
    ContentHead.prototype.pkgNum = null;
    ContentHead.prototype.pkgIndex = null;
    ContentHead.prototype.divSeq = null;
    ContentHead.prototype.autoReply = null;
    ContentHead.prototype.ntMsgSeq = null;
    ContentHead.prototype.msgUid = null;
    ContentHead.prototype.field15 = null;
    let $oneOfFields;
    Object.defineProperty(ContentHead.prototype, "_msgType", {
      get: $util.oneOfGetter($oneOfFields = ["msgType"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_subType", {
      get: $util.oneOfGetter($oneOfFields = ["subType"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_c2cCmd", {
      get: $util.oneOfGetter($oneOfFields = ["c2cCmd"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_random", {
      get: $util.oneOfGetter($oneOfFields = ["random"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_msgSeq", {
      get: $util.oneOfGetter($oneOfFields = ["msgSeq"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_msgTime", {
      get: $util.oneOfGetter($oneOfFields = ["msgTime"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_pkgNum", {
      get: $util.oneOfGetter($oneOfFields = ["pkgNum"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_pkgIndex", {
      get: $util.oneOfGetter($oneOfFields = ["pkgIndex"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_divSeq", {
      get: $util.oneOfGetter($oneOfFields = ["divSeq"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_autoReply", {
      get: $util.oneOfGetter($oneOfFields = ["autoReply"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_ntMsgSeq", {
      get: $util.oneOfGetter($oneOfFields = ["ntMsgSeq"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_msgUid", {
      get: $util.oneOfGetter($oneOfFields = ["msgUid"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHead.prototype, "_field15", {
      get: $util.oneOfGetter($oneOfFields = ["field15"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    ContentHead.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.msgType != null && Object.hasOwnProperty.call(message, "msgType"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint64(message.msgType);
      if (message.subType != null && Object.hasOwnProperty.call(message, "subType"))
        writer2.uint32(
          /* id 2, wireType 0 =*/
          16
        ).uint64(message.subType);
      if (message.c2cCmd != null && Object.hasOwnProperty.call(message, "c2cCmd"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint32(message.c2cCmd);
      if (message.random != null && Object.hasOwnProperty.call(message, "random"))
        writer2.uint32(
          /* id 4, wireType 0 =*/
          32
        ).uint64(message.random);
      if (message.msgSeq != null && Object.hasOwnProperty.call(message, "msgSeq"))
        writer2.uint32(
          /* id 5, wireType 0 =*/
          40
        ).uint64(message.msgSeq);
      if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
        writer2.uint32(
          /* id 6, wireType 0 =*/
          48
        ).uint64(message.msgTime);
      if (message.pkgNum != null && Object.hasOwnProperty.call(message, "pkgNum"))
        writer2.uint32(
          /* id 7, wireType 0 =*/
          56
        ).uint32(message.pkgNum);
      if (message.pkgIndex != null && Object.hasOwnProperty.call(message, "pkgIndex"))
        writer2.uint32(
          /* id 8, wireType 0 =*/
          64
        ).uint32(message.pkgIndex);
      if (message.divSeq != null && Object.hasOwnProperty.call(message, "divSeq"))
        writer2.uint32(
          /* id 9, wireType 0 =*/
          72
        ).uint32(message.divSeq);
      if (message.autoReply != null && Object.hasOwnProperty.call(message, "autoReply"))
        writer2.uint32(
          /* id 10, wireType 0 =*/
          80
        ).uint32(message.autoReply);
      if (message.ntMsgSeq != null && Object.hasOwnProperty.call(message, "ntMsgSeq"))
        writer2.uint32(
          /* id 11, wireType 0 =*/
          88
        ).uint64(message.ntMsgSeq);
      if (message.msgUid != null && Object.hasOwnProperty.call(message, "msgUid"))
        writer2.uint32(
          /* id 12, wireType 0 =*/
          96
        ).uint64(message.msgUid);
      if (message.field15 != null && Object.hasOwnProperty.call(message, "field15"))
        $root.Msg.ContentHeadField15.encode(message.field15, writer2.uint32(
          /* id 15, wireType 2 =*/
          122
        ).fork()).ldelim();
      return writer2;
    };
    ContentHead.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.ContentHead();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.msgType = reader2.uint64();
            break;
          }
          case 2: {
            message.subType = reader2.uint64();
            break;
          }
          case 3: {
            message.c2cCmd = reader2.uint32();
            break;
          }
          case 4: {
            message.random = reader2.uint64();
            break;
          }
          case 5: {
            message.msgSeq = reader2.uint64();
            break;
          }
          case 6: {
            message.msgTime = reader2.uint64();
            break;
          }
          case 7: {
            message.pkgNum = reader2.uint32();
            break;
          }
          case 8: {
            message.pkgIndex = reader2.uint32();
            break;
          }
          case 9: {
            message.divSeq = reader2.uint32();
            break;
          }
          case 10: {
            message.autoReply = reader2.uint32();
            break;
          }
          case 11: {
            message.ntMsgSeq = reader2.uint64();
            break;
          }
          case 12: {
            message.msgUid = reader2.uint64();
            break;
          }
          case 15: {
            message.field15 = $root.Msg.ContentHeadField15.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    ContentHead.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.ContentHead";
    };
    return ContentHead;
  }();
  Msg2.ContentHeadField15 = function() {
    function ContentHeadField15(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ContentHeadField15.prototype.field1 = null;
    ContentHeadField15.prototype.field2 = null;
    ContentHeadField15.prototype.field3 = null;
    ContentHeadField15.prototype.field4 = null;
    ContentHeadField15.prototype.field5 = null;
    let $oneOfFields;
    Object.defineProperty(ContentHeadField15.prototype, "_field1", {
      get: $util.oneOfGetter($oneOfFields = ["field1"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHeadField15.prototype, "_field2", {
      get: $util.oneOfGetter($oneOfFields = ["field2"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHeadField15.prototype, "_field3", {
      get: $util.oneOfGetter($oneOfFields = ["field3"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHeadField15.prototype, "_field4", {
      get: $util.oneOfGetter($oneOfFields = ["field4"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(ContentHeadField15.prototype, "_field5", {
      get: $util.oneOfGetter($oneOfFields = ["field5"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    ContentHeadField15.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.field1 != null && Object.hasOwnProperty.call(message, "field1"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.field1);
      if (message.field2 != null && Object.hasOwnProperty.call(message, "field2"))
        writer2.uint32(
          /* id 2, wireType 0 =*/
          16
        ).uint32(message.field2);
      if (message.field3 != null && Object.hasOwnProperty.call(message, "field3"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint32(message.field3);
      if (message.field4 != null && Object.hasOwnProperty.call(message, "field4"))
        writer2.uint32(
          /* id 4, wireType 2 =*/
          34
        ).string(message.field4);
      if (message.field5 != null && Object.hasOwnProperty.call(message, "field5"))
        writer2.uint32(
          /* id 5, wireType 2 =*/
          42
        ).string(message.field5);
      return writer2;
    };
    ContentHeadField15.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.ContentHeadField15();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.field1 = reader2.uint32();
            break;
          }
          case 2: {
            message.field2 = reader2.uint32();
            break;
          }
          case 3: {
            message.field3 = reader2.uint32();
            break;
          }
          case 4: {
            message.field4 = reader2.string();
            break;
          }
          case 5: {
            message.field5 = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    ContentHeadField15.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.ContentHeadField15";
    };
    return ContentHeadField15;
  }();
  Msg2.Message = function() {
    function Message(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Message.prototype.routingHead = null;
    Message.prototype.contentHead = null;
    Message.prototype.body = null;
    let $oneOfFields;
    Object.defineProperty(Message.prototype, "_routingHead", {
      get: $util.oneOfGetter($oneOfFields = ["routingHead"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Message.prototype, "_contentHead", {
      get: $util.oneOfGetter($oneOfFields = ["contentHead"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Message.prototype, "_body", {
      get: $util.oneOfGetter($oneOfFields = ["body"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Message.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.routingHead != null && Object.hasOwnProperty.call(message, "routingHead"))
        $root.Msg.RoutingHead.encode(message.routingHead, writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork()).ldelim();
      if (message.contentHead != null && Object.hasOwnProperty.call(message, "contentHead"))
        $root.Msg.ContentHead.encode(message.contentHead, writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).fork()).ldelim();
      if (message.body != null && Object.hasOwnProperty.call(message, "body"))
        $root.Msg.MessageBody.encode(message.body, writer2.uint32(
          /* id 3, wireType 2 =*/
          26
        ).fork()).ldelim();
      return writer2;
    };
    Message.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.Message();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.routingHead = $root.Msg.RoutingHead.decode(reader2, reader2.uint32());
            break;
          }
          case 2: {
            message.contentHead = $root.Msg.ContentHead.decode(reader2, reader2.uint32());
            break;
          }
          case 3: {
            message.body = $root.Msg.MessageBody.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    Message.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.Message";
    };
    return Message;
  }();
  Msg2.MessageBody = function() {
    function MessageBody(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    MessageBody.prototype.richText = null;
    MessageBody.prototype.msgContent = null;
    MessageBody.prototype.msgEncryptContent = null;
    let $oneOfFields;
    Object.defineProperty(MessageBody.prototype, "_richText", {
      get: $util.oneOfGetter($oneOfFields = ["richText"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(MessageBody.prototype, "_msgContent", {
      get: $util.oneOfGetter($oneOfFields = ["msgContent"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(MessageBody.prototype, "_msgEncryptContent", {
      get: $util.oneOfGetter($oneOfFields = ["msgEncryptContent"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    MessageBody.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.richText != null && Object.hasOwnProperty.call(message, "richText"))
        $root.Msg.RichText.encode(message.richText, writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork()).ldelim();
      if (message.msgContent != null && Object.hasOwnProperty.call(message, "msgContent"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).bytes(message.msgContent);
      if (message.msgEncryptContent != null && Object.hasOwnProperty.call(message, "msgEncryptContent"))
        writer2.uint32(
          /* id 3, wireType 2 =*/
          26
        ).bytes(message.msgEncryptContent);
      return writer2;
    };
    MessageBody.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.MessageBody();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.richText = $root.Msg.RichText.decode(reader2, reader2.uint32());
            break;
          }
          case 2: {
            message.msgContent = reader2.bytes();
            break;
          }
          case 3: {
            message.msgEncryptContent = reader2.bytes();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    MessageBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.MessageBody";
    };
    return MessageBody;
  }();
  Msg2.RichText = function() {
    function RichText(properties) {
      this.elems = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    RichText.prototype.attr = null;
    RichText.prototype.elems = $util.emptyArray;
    let $oneOfFields;
    Object.defineProperty(RichText.prototype, "_attr", {
      get: $util.oneOfGetter($oneOfFields = ["attr"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    RichText.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.attr != null && Object.hasOwnProperty.call(message, "attr"))
        $root.Msg.Attr.encode(message.attr, writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork()).ldelim();
      if (message.elems != null && message.elems.length)
        for (let i = 0; i < message.elems.length; ++i)
          $root.Msg.Elem.encode(message.elems[i], writer2.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
      return writer2;
    };
    RichText.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.RichText();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.attr = $root.Msg.Attr.decode(reader2, reader2.uint32());
            break;
          }
          case 2: {
            if (!(message.elems && message.elems.length))
              message.elems = [];
            message.elems.push($root.Msg.Elem.decode(reader2, reader2.uint32()));
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    RichText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.RichText";
    };
    return RichText;
  }();
  Msg2.Elem = function() {
    function Elem(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Elem.prototype.text = null;
    Elem.prototype.face = null;
    Elem.prototype.lightApp = null;
    Elem.prototype.commonElem = null;
    let $oneOfFields;
    Object.defineProperty(Elem.prototype, "_text", {
      get: $util.oneOfGetter($oneOfFields = ["text"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Elem.prototype, "_face", {
      get: $util.oneOfGetter($oneOfFields = ["face"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Elem.prototype, "_lightApp", {
      get: $util.oneOfGetter($oneOfFields = ["lightApp"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Elem.prototype, "_commonElem", {
      get: $util.oneOfGetter($oneOfFields = ["commonElem"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Elem.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.text != null && Object.hasOwnProperty.call(message, "text"))
        $root.Msg.Text.encode(message.text, writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork()).ldelim();
      if (message.face != null && Object.hasOwnProperty.call(message, "face"))
        $root.Msg.Face.encode(message.face, writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).fork()).ldelim();
      if (message.lightApp != null && Object.hasOwnProperty.call(message, "lightApp"))
        $root.Msg.LightAppElem.encode(message.lightApp, writer2.uint32(
          /* id 51, wireType 2 =*/
          410
        ).fork()).ldelim();
      if (message.commonElem != null && Object.hasOwnProperty.call(message, "commonElem"))
        $root.Msg.CommonElem.encode(message.commonElem, writer2.uint32(
          /* id 53, wireType 2 =*/
          426
        ).fork()).ldelim();
      return writer2;
    };
    Elem.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.Elem();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.text = $root.Msg.Text.decode(reader2, reader2.uint32());
            break;
          }
          case 2: {
            message.face = $root.Msg.Face.decode(reader2, reader2.uint32());
            break;
          }
          case 51: {
            message.lightApp = $root.Msg.LightAppElem.decode(reader2, reader2.uint32());
            break;
          }
          case 53: {
            message.commonElem = $root.Msg.CommonElem.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    Elem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.Elem";
    };
    return Elem;
  }();
  Msg2.Text = function() {
    function Text(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Text.prototype.str = null;
    Text.prototype.link = null;
    Text.prototype.attr6Buf = null;
    Text.prototype.attr7Buf = null;
    Text.prototype.buf = null;
    Text.prototype.pbReserve = null;
    let $oneOfFields;
    Object.defineProperty(Text.prototype, "_str", {
      get: $util.oneOfGetter($oneOfFields = ["str"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Text.prototype, "_link", {
      get: $util.oneOfGetter($oneOfFields = ["link"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Text.prototype, "_attr6Buf", {
      get: $util.oneOfGetter($oneOfFields = ["attr6Buf"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Text.prototype, "_attr7Buf", {
      get: $util.oneOfGetter($oneOfFields = ["attr7Buf"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Text.prototype, "_buf", {
      get: $util.oneOfGetter($oneOfFields = ["buf"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Text.prototype, "_pbReserve", {
      get: $util.oneOfGetter($oneOfFields = ["pbReserve"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Text.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.str != null && Object.hasOwnProperty.call(message, "str"))
        writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).string(message.str);
      if (message.link != null && Object.hasOwnProperty.call(message, "link"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).string(message.link);
      if (message.attr6Buf != null && Object.hasOwnProperty.call(message, "attr6Buf"))
        writer2.uint32(
          /* id 3, wireType 2 =*/
          26
        ).bytes(message.attr6Buf);
      if (message.attr7Buf != null && Object.hasOwnProperty.call(message, "attr7Buf"))
        writer2.uint32(
          /* id 4, wireType 2 =*/
          34
        ).bytes(message.attr7Buf);
      if (message.buf != null && Object.hasOwnProperty.call(message, "buf"))
        writer2.uint32(
          /* id 11, wireType 2 =*/
          90
        ).bytes(message.buf);
      if (message.pbReserve != null && Object.hasOwnProperty.call(message, "pbReserve"))
        writer2.uint32(
          /* id 12, wireType 2 =*/
          98
        ).bytes(message.pbReserve);
      return writer2;
    };
    Text.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.Text();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.str = reader2.string();
            break;
          }
          case 2: {
            message.link = reader2.string();
            break;
          }
          case 3: {
            message.attr6Buf = reader2.bytes();
            break;
          }
          case 4: {
            message.attr7Buf = reader2.bytes();
            break;
          }
          case 11: {
            message.buf = reader2.bytes();
            break;
          }
          case 12: {
            message.pbReserve = reader2.bytes();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    Text.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.Text";
    };
    return Text;
  }();
  Msg2.Face = function() {
    function Face(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Face.prototype.index = null;
    Face.prototype.old = null;
    Face.prototype.buf = null;
    let $oneOfFields;
    Object.defineProperty(Face.prototype, "_index", {
      get: $util.oneOfGetter($oneOfFields = ["index"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Face.prototype, "_old", {
      get: $util.oneOfGetter($oneOfFields = ["old"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Face.prototype, "_buf", {
      get: $util.oneOfGetter($oneOfFields = ["buf"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Face.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.index != null && Object.hasOwnProperty.call(message, "index"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.index);
      if (message.old != null && Object.hasOwnProperty.call(message, "old"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).bytes(message.old);
      if (message.buf != null && Object.hasOwnProperty.call(message, "buf"))
        writer2.uint32(
          /* id 11, wireType 2 =*/
          90
        ).bytes(message.buf);
      return writer2;
    };
    Face.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.Face();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.index = reader2.uint32();
            break;
          }
          case 2: {
            message.old = reader2.bytes();
            break;
          }
          case 11: {
            message.buf = reader2.bytes();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    Face.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.Face";
    };
    return Face;
  }();
  Msg2.LightAppElem = function() {
    function LightAppElem(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    LightAppElem.prototype.data = null;
    LightAppElem.prototype.msgResid = null;
    let $oneOfFields;
    Object.defineProperty(LightAppElem.prototype, "_data", {
      get: $util.oneOfGetter($oneOfFields = ["data"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(LightAppElem.prototype, "_msgResid", {
      get: $util.oneOfGetter($oneOfFields = ["msgResid"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    LightAppElem.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.data != null && Object.hasOwnProperty.call(message, "data"))
        writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).bytes(message.data);
      if (message.msgResid != null && Object.hasOwnProperty.call(message, "msgResid"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).bytes(message.msgResid);
      return writer2;
    };
    LightAppElem.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.LightAppElem();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.data = reader2.bytes();
            break;
          }
          case 2: {
            message.msgResid = reader2.bytes();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    LightAppElem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.LightAppElem";
    };
    return LightAppElem;
  }();
  Msg2.CommonElem = function() {
    function CommonElem(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    CommonElem.prototype.serviceType = 0;
    CommonElem.prototype.pbElem = null;
    CommonElem.prototype.businessType = null;
    let $oneOfFields;
    Object.defineProperty(CommonElem.prototype, "_pbElem", {
      get: $util.oneOfGetter($oneOfFields = ["pbElem"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(CommonElem.prototype, "_businessType", {
      get: $util.oneOfGetter($oneOfFields = ["businessType"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    CommonElem.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.serviceType != null && Object.hasOwnProperty.call(message, "serviceType"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.serviceType);
      if (message.pbElem != null && Object.hasOwnProperty.call(message, "pbElem"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).bytes(message.pbElem);
      if (message.businessType != null && Object.hasOwnProperty.call(message, "businessType"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint32(message.businessType);
      return writer2;
    };
    CommonElem.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.CommonElem();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.serviceType = reader2.uint32();
            break;
          }
          case 2: {
            message.pbElem = reader2.bytes();
            break;
          }
          case 3: {
            message.businessType = reader2.uint32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    CommonElem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.CommonElem";
    };
    return CommonElem;
  }();
  Msg2.Attr = function() {
    function Attr(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Attr.prototype.codePage = null;
    Attr.prototype.time = null;
    Attr.prototype.random = null;
    Attr.prototype.color = null;
    Attr.prototype.size = null;
    Attr.prototype.effect = null;
    Attr.prototype.charSet = null;
    Attr.prototype.pitchAndFamily = null;
    Attr.prototype.fontName = null;
    Attr.prototype.reserveData = null;
    let $oneOfFields;
    Object.defineProperty(Attr.prototype, "_codePage", {
      get: $util.oneOfGetter($oneOfFields = ["codePage"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Attr.prototype, "_time", {
      get: $util.oneOfGetter($oneOfFields = ["time"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Attr.prototype, "_random", {
      get: $util.oneOfGetter($oneOfFields = ["random"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Attr.prototype, "_color", {
      get: $util.oneOfGetter($oneOfFields = ["color"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Attr.prototype, "_size", {
      get: $util.oneOfGetter($oneOfFields = ["size"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Attr.prototype, "_effect", {
      get: $util.oneOfGetter($oneOfFields = ["effect"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Attr.prototype, "_charSet", {
      get: $util.oneOfGetter($oneOfFields = ["charSet"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Attr.prototype, "_pitchAndFamily", {
      get: $util.oneOfGetter($oneOfFields = ["pitchAndFamily"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Attr.prototype, "_fontName", {
      get: $util.oneOfGetter($oneOfFields = ["fontName"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(Attr.prototype, "_reserveData", {
      get: $util.oneOfGetter($oneOfFields = ["reserveData"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Attr.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.codePage != null && Object.hasOwnProperty.call(message, "codePage"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).int32(message.codePage);
      if (message.time != null && Object.hasOwnProperty.call(message, "time"))
        writer2.uint32(
          /* id 2, wireType 0 =*/
          16
        ).int32(message.time);
      if (message.random != null && Object.hasOwnProperty.call(message, "random"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).int32(message.random);
      if (message.color != null && Object.hasOwnProperty.call(message, "color"))
        writer2.uint32(
          /* id 4, wireType 0 =*/
          32
        ).int32(message.color);
      if (message.size != null && Object.hasOwnProperty.call(message, "size"))
        writer2.uint32(
          /* id 5, wireType 0 =*/
          40
        ).int32(message.size);
      if (message.effect != null && Object.hasOwnProperty.call(message, "effect"))
        writer2.uint32(
          /* id 6, wireType 0 =*/
          48
        ).int32(message.effect);
      if (message.charSet != null && Object.hasOwnProperty.call(message, "charSet"))
        writer2.uint32(
          /* id 7, wireType 0 =*/
          56
        ).int32(message.charSet);
      if (message.pitchAndFamily != null && Object.hasOwnProperty.call(message, "pitchAndFamily"))
        writer2.uint32(
          /* id 8, wireType 0 =*/
          64
        ).int32(message.pitchAndFamily);
      if (message.fontName != null && Object.hasOwnProperty.call(message, "fontName"))
        writer2.uint32(
          /* id 9, wireType 2 =*/
          74
        ).string(message.fontName);
      if (message.reserveData != null && Object.hasOwnProperty.call(message, "reserveData"))
        writer2.uint32(
          /* id 10, wireType 2 =*/
          82
        ).bytes(message.reserveData);
      return writer2;
    };
    Attr.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.Attr();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.codePage = reader2.int32();
            break;
          }
          case 2: {
            message.time = reader2.int32();
            break;
          }
          case 3: {
            message.random = reader2.int32();
            break;
          }
          case 4: {
            message.color = reader2.int32();
            break;
          }
          case 5: {
            message.size = reader2.int32();
            break;
          }
          case 6: {
            message.effect = reader2.int32();
            break;
          }
          case 7: {
            message.charSet = reader2.int32();
            break;
          }
          case 8: {
            message.pitchAndFamily = reader2.int32();
            break;
          }
          case 9: {
            message.fontName = reader2.string();
            break;
          }
          case 10: {
            message.reserveData = reader2.bytes();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    Attr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.Attr";
    };
    return Attr;
  }();
  Msg2.MarkdownElem = function() {
    function MarkdownElem(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    MarkdownElem.prototype.content = "";
    MarkdownElem.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.content != null && Object.hasOwnProperty.call(message, "content"))
        writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).string(message.content);
      return writer2;
    };
    MarkdownElem.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.MarkdownElem();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.content = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    MarkdownElem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.MarkdownElem";
    };
    return MarkdownElem;
  }();
  Msg2.PbMultiMsgItem = function() {
    function PbMultiMsgItem(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    PbMultiMsgItem.prototype.fileName = "";
    PbMultiMsgItem.prototype.buffer = null;
    PbMultiMsgItem.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
        writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).string(message.fileName);
      if (message.buffer != null && Object.hasOwnProperty.call(message, "buffer"))
        $root.Msg.PbMultiMsgNew.encode(message.buffer, writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).fork()).ldelim();
      return writer2;
    };
    PbMultiMsgItem.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.PbMultiMsgItem();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.fileName = reader2.string();
            break;
          }
          case 2: {
            message.buffer = $root.Msg.PbMultiMsgNew.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    PbMultiMsgItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.PbMultiMsgItem";
    };
    return PbMultiMsgItem;
  }();
  Msg2.PbMultiMsgNew = function() {
    function PbMultiMsgNew(properties) {
      this.msg = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    PbMultiMsgNew.prototype.msg = $util.emptyArray;
    PbMultiMsgNew.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.msg != null && message.msg.length)
        for (let i = 0; i < message.msg.length; ++i)
          $root.Msg.Message.encode(message.msg[i], writer2.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      return writer2;
    };
    PbMultiMsgNew.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.PbMultiMsgNew();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.msg && message.msg.length))
              message.msg = [];
            message.msg.push($root.Msg.Message.decode(reader2, reader2.uint32()));
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    PbMultiMsgNew.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.PbMultiMsgNew";
    };
    return PbMultiMsgNew;
  }();
  Msg2.PbMultiMsgTransmit = function() {
    function PbMultiMsgTransmit(properties) {
      this.msg = [];
      this.pbItemList = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    PbMultiMsgTransmit.prototype.msg = $util.emptyArray;
    PbMultiMsgTransmit.prototype.pbItemList = $util.emptyArray;
    PbMultiMsgTransmit.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.msg != null && message.msg.length)
        for (let i = 0; i < message.msg.length; ++i)
          $root.Msg.Message.encode(message.msg[i], writer2.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      if (message.pbItemList != null && message.pbItemList.length)
        for (let i = 0; i < message.pbItemList.length; ++i)
          $root.Msg.PbMultiMsgItem.encode(message.pbItemList[i], writer2.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
      return writer2;
    };
    PbMultiMsgTransmit.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.PbMultiMsgTransmit();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.msg && message.msg.length))
              message.msg = [];
            message.msg.push($root.Msg.Message.decode(reader2, reader2.uint32()));
            break;
          }
          case 2: {
            if (!(message.pbItemList && message.pbItemList.length))
              message.pbItemList = [];
            message.pbItemList.push($root.Msg.PbMultiMsgItem.decode(reader2, reader2.uint32()));
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    PbMultiMsgTransmit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.PbMultiMsgTransmit";
    };
    return PbMultiMsgTransmit;
  }();
  Msg2.SendMsgRsp = function() {
    function SendMsgRsp(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    SendMsgRsp.prototype.retCode = 0;
    SendMsgRsp.prototype.errMsg = null;
    SendMsgRsp.prototype.groupSeq = null;
    SendMsgRsp.prototype.timestamp = null;
    SendMsgRsp.prototype.privateSeq = null;
    let $oneOfFields;
    Object.defineProperty(SendMsgRsp.prototype, "_errMsg", {
      get: $util.oneOfGetter($oneOfFields = ["errMsg"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(SendMsgRsp.prototype, "_groupSeq", {
      get: $util.oneOfGetter($oneOfFields = ["groupSeq"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(SendMsgRsp.prototype, "_timestamp", {
      get: $util.oneOfGetter($oneOfFields = ["timestamp"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Object.defineProperty(SendMsgRsp.prototype, "_privateSeq", {
      get: $util.oneOfGetter($oneOfFields = ["privateSeq"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    SendMsgRsp.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.retCode != null && Object.hasOwnProperty.call(message, "retCode"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).int32(message.retCode);
      if (message.errMsg != null && Object.hasOwnProperty.call(message, "errMsg"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).string(message.errMsg);
      if (message.groupSeq != null && Object.hasOwnProperty.call(message, "groupSeq"))
        writer2.uint32(
          /* id 11, wireType 0 =*/
          88
        ).int32(message.groupSeq);
      if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
        writer2.uint32(
          /* id 12, wireType 0 =*/
          96
        ).uint32(message.timestamp);
      if (message.privateSeq != null && Object.hasOwnProperty.call(message, "privateSeq"))
        writer2.uint32(
          /* id 14, wireType 0 =*/
          112
        ).int32(message.privateSeq);
      return writer2;
    };
    SendMsgRsp.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Msg.SendMsgRsp();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.retCode = reader2.int32();
            break;
          }
          case 2: {
            message.errMsg = reader2.string();
            break;
          }
          case 11: {
            message.groupSeq = reader2.int32();
            break;
          }
          case 12: {
            message.timestamp = reader2.uint32();
            break;
          }
          case 14: {
            message.privateSeq = reader2.int32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    SendMsgRsp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Msg.SendMsgRsp";
    };
    return SendMsgRsp;
  }();
  return Msg2;
})();
const RichMedia = $root.RichMedia = (() => {
  const RichMedia2 = {};
  RichMedia2.MsgInfo = function() {
    function MsgInfo(properties) {
      this.msgInfoBody = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    MsgInfo.prototype.msgInfoBody = $util.emptyArray;
    MsgInfo.prototype.extBizInfo = null;
    MsgInfo.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.msgInfoBody != null && message.msgInfoBody.length)
        for (let i = 0; i < message.msgInfoBody.length; ++i)
          $root.RichMedia.MsgInfoBody.encode(message.msgInfoBody[i], writer2.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      if (message.extBizInfo != null && Object.hasOwnProperty.call(message, "extBizInfo"))
        $root.RichMedia.ExtBizInfo.encode(message.extBizInfo, writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).fork()).ldelim();
      return writer2;
    };
    MsgInfo.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.RichMedia.MsgInfo();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.msgInfoBody && message.msgInfoBody.length))
              message.msgInfoBody = [];
            message.msgInfoBody.push($root.RichMedia.MsgInfoBody.decode(reader2, reader2.uint32()));
            break;
          }
          case 2: {
            message.extBizInfo = $root.RichMedia.ExtBizInfo.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    MsgInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/RichMedia.MsgInfo";
    };
    return MsgInfo;
  }();
  RichMedia2.MsgInfoBody = function() {
    function MsgInfoBody(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    MsgInfoBody.prototype.index = null;
    MsgInfoBody.prototype.pic = null;
    MsgInfoBody.prototype.fileExist = false;
    MsgInfoBody.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.index != null && Object.hasOwnProperty.call(message, "index"))
        $root.RichMedia.IndexNode.encode(message.index, writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork()).ldelim();
      if (message.pic != null && Object.hasOwnProperty.call(message, "pic"))
        $root.RichMedia.PicInfo.encode(message.pic, writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).fork()).ldelim();
      if (message.fileExist != null && Object.hasOwnProperty.call(message, "fileExist"))
        writer2.uint32(
          /* id 5, wireType 0 =*/
          40
        ).bool(message.fileExist);
      return writer2;
    };
    MsgInfoBody.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.RichMedia.MsgInfoBody();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.index = $root.RichMedia.IndexNode.decode(reader2, reader2.uint32());
            break;
          }
          case 2: {
            message.pic = $root.RichMedia.PicInfo.decode(reader2, reader2.uint32());
            break;
          }
          case 5: {
            message.fileExist = reader2.bool();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    MsgInfoBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/RichMedia.MsgInfoBody";
    };
    return MsgInfoBody;
  }();
  RichMedia2.IndexNode = function() {
    function IndexNode(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    IndexNode.prototype.info = null;
    IndexNode.prototype.fileUuid = "";
    IndexNode.prototype.storeID = 0;
    IndexNode.prototype.uploadTime = 0;
    IndexNode.prototype.expire = 0;
    IndexNode.prototype.type = 0;
    IndexNode.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.info != null && Object.hasOwnProperty.call(message, "info"))
        $root.RichMedia.FileInfo.encode(message.info, writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork()).ldelim();
      if (message.fileUuid != null && Object.hasOwnProperty.call(message, "fileUuid"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).string(message.fileUuid);
      if (message.storeID != null && Object.hasOwnProperty.call(message, "storeID"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint32(message.storeID);
      if (message.uploadTime != null && Object.hasOwnProperty.call(message, "uploadTime"))
        writer2.uint32(
          /* id 4, wireType 0 =*/
          32
        ).uint32(message.uploadTime);
      if (message.expire != null && Object.hasOwnProperty.call(message, "expire"))
        writer2.uint32(
          /* id 5, wireType 0 =*/
          40
        ).uint32(message.expire);
      if (message.type != null && Object.hasOwnProperty.call(message, "type"))
        writer2.uint32(
          /* id 6, wireType 0 =*/
          48
        ).uint32(message.type);
      return writer2;
    };
    IndexNode.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.RichMedia.IndexNode();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.info = $root.RichMedia.FileInfo.decode(reader2, reader2.uint32());
            break;
          }
          case 2: {
            message.fileUuid = reader2.string();
            break;
          }
          case 3: {
            message.storeID = reader2.uint32();
            break;
          }
          case 4: {
            message.uploadTime = reader2.uint32();
            break;
          }
          case 5: {
            message.expire = reader2.uint32();
            break;
          }
          case 6: {
            message.type = reader2.uint32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    IndexNode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/RichMedia.IndexNode";
    };
    return IndexNode;
  }();
  RichMedia2.FileInfo = function() {
    function FileInfo(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    FileInfo.prototype.fileSize = 0;
    FileInfo.prototype.md5HexStr = "";
    FileInfo.prototype.sha1HexStr = "";
    FileInfo.prototype.fileName = "";
    FileInfo.prototype.fileType = null;
    FileInfo.prototype.width = 0;
    FileInfo.prototype.height = 0;
    FileInfo.prototype.time = 0;
    FileInfo.prototype.original = 0;
    FileInfo.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.fileSize != null && Object.hasOwnProperty.call(message, "fileSize"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.fileSize);
      if (message.md5HexStr != null && Object.hasOwnProperty.call(message, "md5HexStr"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).string(message.md5HexStr);
      if (message.sha1HexStr != null && Object.hasOwnProperty.call(message, "sha1HexStr"))
        writer2.uint32(
          /* id 3, wireType 2 =*/
          26
        ).string(message.sha1HexStr);
      if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
        writer2.uint32(
          /* id 4, wireType 2 =*/
          34
        ).string(message.fileName);
      if (message.fileType != null && Object.hasOwnProperty.call(message, "fileType"))
        $root.RichMedia.FileType.encode(message.fileType, writer2.uint32(
          /* id 5, wireType 2 =*/
          42
        ).fork()).ldelim();
      if (message.width != null && Object.hasOwnProperty.call(message, "width"))
        writer2.uint32(
          /* id 6, wireType 0 =*/
          48
        ).uint32(message.width);
      if (message.height != null && Object.hasOwnProperty.call(message, "height"))
        writer2.uint32(
          /* id 7, wireType 0 =*/
          56
        ).uint32(message.height);
      if (message.time != null && Object.hasOwnProperty.call(message, "time"))
        writer2.uint32(
          /* id 8, wireType 0 =*/
          64
        ).uint32(message.time);
      if (message.original != null && Object.hasOwnProperty.call(message, "original"))
        writer2.uint32(
          /* id 9, wireType 0 =*/
          72
        ).uint32(message.original);
      return writer2;
    };
    FileInfo.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.RichMedia.FileInfo();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.fileSize = reader2.uint32();
            break;
          }
          case 2: {
            message.md5HexStr = reader2.string();
            break;
          }
          case 3: {
            message.sha1HexStr = reader2.string();
            break;
          }
          case 4: {
            message.fileName = reader2.string();
            break;
          }
          case 5: {
            message.fileType = $root.RichMedia.FileType.decode(reader2, reader2.uint32());
            break;
          }
          case 6: {
            message.width = reader2.uint32();
            break;
          }
          case 7: {
            message.height = reader2.uint32();
            break;
          }
          case 8: {
            message.time = reader2.uint32();
            break;
          }
          case 9: {
            message.original = reader2.uint32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    FileInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/RichMedia.FileInfo";
    };
    return FileInfo;
  }();
  RichMedia2.FileType = function() {
    function FileType(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    FileType.prototype.type = 0;
    FileType.prototype.picFormat = 0;
    FileType.prototype.videoFormat = 0;
    FileType.prototype.pttFormat = 0;
    FileType.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.type != null && Object.hasOwnProperty.call(message, "type"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.type);
      if (message.picFormat != null && Object.hasOwnProperty.call(message, "picFormat"))
        writer2.uint32(
          /* id 2, wireType 0 =*/
          16
        ).uint32(message.picFormat);
      if (message.videoFormat != null && Object.hasOwnProperty.call(message, "videoFormat"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint32(message.videoFormat);
      if (message.pttFormat != null && Object.hasOwnProperty.call(message, "pttFormat"))
        writer2.uint32(
          /* id 4, wireType 0 =*/
          32
        ).uint32(message.pttFormat);
      return writer2;
    };
    FileType.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.RichMedia.FileType();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.type = reader2.uint32();
            break;
          }
          case 2: {
            message.picFormat = reader2.uint32();
            break;
          }
          case 3: {
            message.videoFormat = reader2.uint32();
            break;
          }
          case 4: {
            message.pttFormat = reader2.uint32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    FileType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/RichMedia.FileType";
    };
    return FileType;
  }();
  RichMedia2.PicInfo = function() {
    function PicInfo(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    PicInfo.prototype.urlPath = "";
    PicInfo.prototype.ext = null;
    PicInfo.prototype.domain = "";
    PicInfo.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.urlPath != null && Object.hasOwnProperty.call(message, "urlPath"))
        writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).string(message.urlPath);
      if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
        $root.RichMedia.PicUrlExtParams.encode(message.ext, writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).fork()).ldelim();
      if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
        writer2.uint32(
          /* id 3, wireType 2 =*/
          26
        ).string(message.domain);
      return writer2;
    };
    PicInfo.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.RichMedia.PicInfo();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.urlPath = reader2.string();
            break;
          }
          case 2: {
            message.ext = $root.RichMedia.PicUrlExtParams.decode(reader2, reader2.uint32());
            break;
          }
          case 3: {
            message.domain = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    PicInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/RichMedia.PicInfo";
    };
    return PicInfo;
  }();
  RichMedia2.PicUrlExtParams = function() {
    function PicUrlExtParams(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    PicUrlExtParams.prototype.originalParam = "";
    PicUrlExtParams.prototype.bigParam = "";
    PicUrlExtParams.prototype.thumbParam = "";
    PicUrlExtParams.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.originalParam != null && Object.hasOwnProperty.call(message, "originalParam"))
        writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).string(message.originalParam);
      if (message.bigParam != null && Object.hasOwnProperty.call(message, "bigParam"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).string(message.bigParam);
      if (message.thumbParam != null && Object.hasOwnProperty.call(message, "thumbParam"))
        writer2.uint32(
          /* id 3, wireType 2 =*/
          26
        ).string(message.thumbParam);
      return writer2;
    };
    PicUrlExtParams.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.RichMedia.PicUrlExtParams();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.originalParam = reader2.string();
            break;
          }
          case 2: {
            message.bigParam = reader2.string();
            break;
          }
          case 3: {
            message.thumbParam = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    PicUrlExtParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/RichMedia.PicUrlExtParams";
    };
    return PicUrlExtParams;
  }();
  RichMedia2.ExtBizInfo = function() {
    function ExtBizInfo(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ExtBizInfo.prototype.pic = null;
    ExtBizInfo.prototype.video = null;
    ExtBizInfo.prototype.busiType = 0;
    ExtBizInfo.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.pic != null && Object.hasOwnProperty.call(message, "pic"))
        $root.RichMedia.PicExtBizInfo.encode(message.pic, writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork()).ldelim();
      if (message.video != null && Object.hasOwnProperty.call(message, "video"))
        $root.RichMedia.VideoExtBizInfo.encode(message.video, writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).fork()).ldelim();
      if (message.busiType != null && Object.hasOwnProperty.call(message, "busiType"))
        writer2.uint32(
          /* id 10, wireType 0 =*/
          80
        ).uint32(message.busiType);
      return writer2;
    };
    ExtBizInfo.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.RichMedia.ExtBizInfo();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.pic = $root.RichMedia.PicExtBizInfo.decode(reader2, reader2.uint32());
            break;
          }
          case 2: {
            message.video = $root.RichMedia.VideoExtBizInfo.decode(reader2, reader2.uint32());
            break;
          }
          case 10: {
            message.busiType = reader2.uint32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    ExtBizInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/RichMedia.ExtBizInfo";
    };
    return ExtBizInfo;
  }();
  RichMedia2.PicExtBizInfo = function() {
    function PicExtBizInfo(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    PicExtBizInfo.prototype.bizType = 0;
    PicExtBizInfo.prototype.summary = "";
    PicExtBizInfo.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.bizType != null && Object.hasOwnProperty.call(message, "bizType"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.bizType);
      if (message.summary != null && Object.hasOwnProperty.call(message, "summary"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).string(message.summary);
      return writer2;
    };
    PicExtBizInfo.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.RichMedia.PicExtBizInfo();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.bizType = reader2.uint32();
            break;
          }
          case 2: {
            message.summary = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    PicExtBizInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/RichMedia.PicExtBizInfo";
    };
    return PicExtBizInfo;
  }();
  RichMedia2.VideoExtBizInfo = function() {
    function VideoExtBizInfo(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    VideoExtBizInfo.prototype.pbReserve = $util.newBuffer([]);
    VideoExtBizInfo.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.pbReserve != null && Object.hasOwnProperty.call(message, "pbReserve"))
        writer2.uint32(
          /* id 3, wireType 2 =*/
          26
        ).bytes(message.pbReserve);
      return writer2;
    };
    VideoExtBizInfo.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.RichMedia.VideoExtBizInfo();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 3: {
            message.pbReserve = reader2.bytes();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    VideoExtBizInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/RichMedia.VideoExtBizInfo";
    };
    return VideoExtBizInfo;
  }();
  RichMedia2.PicFileIdInfo = function() {
    function PicFileIdInfo(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    PicFileIdInfo.prototype.sha1 = $util.newBuffer([]);
    PicFileIdInfo.prototype.size = 0;
    PicFileIdInfo.prototype.appid = 0;
    PicFileIdInfo.prototype.time = 0;
    PicFileIdInfo.prototype.expire = 0;
    PicFileIdInfo.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.sha1 != null && Object.hasOwnProperty.call(message, "sha1"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).bytes(message.sha1);
      if (message.size != null && Object.hasOwnProperty.call(message, "size"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint32(message.size);
      if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
        writer2.uint32(
          /* id 4, wireType 0 =*/
          32
        ).uint32(message.appid);
      if (message.time != null && Object.hasOwnProperty.call(message, "time"))
        writer2.uint32(
          /* id 5, wireType 0 =*/
          40
        ).uint32(message.time);
      if (message.expire != null && Object.hasOwnProperty.call(message, "expire"))
        writer2.uint32(
          /* id 10, wireType 0 =*/
          80
        ).uint32(message.expire);
      return writer2;
    };
    PicFileIdInfo.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.RichMedia.PicFileIdInfo();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 2: {
            message.sha1 = reader2.bytes();
            break;
          }
          case 3: {
            message.size = reader2.uint32();
            break;
          }
          case 4: {
            message.appid = reader2.uint32();
            break;
          }
          case 5: {
            message.time = reader2.uint32();
            break;
          }
          case 10: {
            message.expire = reader2.uint32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    PicFileIdInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/RichMedia.PicFileIdInfo";
    };
    return PicFileIdInfo;
  }();
  return RichMedia2;
})();
const Oidb = $root.Oidb = (() => {
  const Oidb2 = {};
  Oidb2.Base = function() {
    function Base(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Base.prototype.command = 0;
    Base.prototype.subCommand = 0;
    Base.prototype.errorCode = 0;
    Base.prototype.body = $util.newBuffer([]);
    Base.prototype.errorMsg = "";
    Base.prototype.isReserved = 0;
    Base.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.command != null && Object.hasOwnProperty.call(message, "command"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.command);
      if (message.subCommand != null && Object.hasOwnProperty.call(message, "subCommand"))
        writer2.uint32(
          /* id 2, wireType 0 =*/
          16
        ).uint32(message.subCommand);
      if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint32(message.errorCode);
      if (message.body != null && Object.hasOwnProperty.call(message, "body"))
        writer2.uint32(
          /* id 4, wireType 2 =*/
          34
        ).bytes(message.body);
      if (message.errorMsg != null && Object.hasOwnProperty.call(message, "errorMsg"))
        writer2.uint32(
          /* id 5, wireType 2 =*/
          42
        ).string(message.errorMsg);
      if (message.isReserved != null && Object.hasOwnProperty.call(message, "isReserved"))
        writer2.uint32(
          /* id 12, wireType 0 =*/
          96
        ).uint32(message.isReserved);
      return writer2;
    };
    Base.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Oidb.Base();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.command = reader2.uint32();
            break;
          }
          case 2: {
            message.subCommand = reader2.uint32();
            break;
          }
          case 3: {
            message.errorCode = reader2.uint32();
            break;
          }
          case 4: {
            message.body = reader2.bytes();
            break;
          }
          case 5: {
            message.errorMsg = reader2.string();
            break;
          }
          case 12: {
            message.isReserved = reader2.uint32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    Base.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Oidb.Base";
    };
    return Base;
  }();
  Oidb2.SendPoke = function() {
    function SendPoke(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    SendPoke.prototype.toUin = 0;
    SendPoke.prototype.groupCode = 0;
    SendPoke.prototype.friendUin = 0;
    SendPoke.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.toUin != null && Object.hasOwnProperty.call(message, "toUin"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.toUin);
      if (message.groupCode != null && Object.hasOwnProperty.call(message, "groupCode"))
        writer2.uint32(
          /* id 2, wireType 0 =*/
          16
        ).uint32(message.groupCode);
      if (message.friendUin != null && Object.hasOwnProperty.call(message, "friendUin"))
        writer2.uint32(
          /* id 5, wireType 0 =*/
          40
        ).uint32(message.friendUin);
      return writer2;
    };
    SendPoke.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Oidb.SendPoke();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.toUin = reader2.uint32();
            break;
          }
          case 2: {
            message.groupCode = reader2.uint32();
            break;
          }
          case 5: {
            message.friendUin = reader2.uint32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    SendPoke.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Oidb.SendPoke";
    };
    return SendPoke;
  }();
  Oidb2.SetSpecialTitleBody = function() {
    function SetSpecialTitleBody(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    SetSpecialTitleBody.prototype.targetUid = "";
    SetSpecialTitleBody.prototype.specialTitle = "";
    SetSpecialTitleBody.prototype.expireTime = 0;
    SetSpecialTitleBody.prototype.uidName = "";
    SetSpecialTitleBody.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
        writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).string(message.targetUid);
      if (message.specialTitle != null && Object.hasOwnProperty.call(message, "specialTitle"))
        writer2.uint32(
          /* id 5, wireType 2 =*/
          42
        ).string(message.specialTitle);
      if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
        writer2.uint32(
          /* id 6, wireType 0 =*/
          48
        ).int32(message.expireTime);
      if (message.uidName != null && Object.hasOwnProperty.call(message, "uidName"))
        writer2.uint32(
          /* id 7, wireType 2 =*/
          58
        ).string(message.uidName);
      return writer2;
    };
    SetSpecialTitleBody.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Oidb.SetSpecialTitleBody();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.targetUid = reader2.string();
            break;
          }
          case 5: {
            message.specialTitle = reader2.string();
            break;
          }
          case 6: {
            message.expireTime = reader2.int32();
            break;
          }
          case 7: {
            message.uidName = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    SetSpecialTitleBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Oidb.SetSpecialTitleBody";
    };
    return SetSpecialTitleBody;
  }();
  Oidb2.SetSpecialTitle = function() {
    function SetSpecialTitle(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    SetSpecialTitle.prototype.groupCode = 0;
    SetSpecialTitle.prototype.body = null;
    SetSpecialTitle.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.groupCode != null && Object.hasOwnProperty.call(message, "groupCode"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.groupCode);
      if (message.body != null && Object.hasOwnProperty.call(message, "body"))
        $root.Oidb.SetSpecialTitleBody.encode(message.body, writer2.uint32(
          /* id 3, wireType 2 =*/
          26
        ).fork()).ldelim();
      return writer2;
    };
    SetSpecialTitle.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Oidb.SetSpecialTitle();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.groupCode = reader2.uint32();
            break;
          }
          case 3: {
            message.body = $root.Oidb.SetSpecialTitleBody.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    SetSpecialTitle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Oidb.SetSpecialTitle";
    };
    return SetSpecialTitle;
  }();
  Oidb2.GetRKeyResponseItem = function() {
    function GetRKeyResponseItem(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    GetRKeyResponseItem.prototype.rkey = "";
    GetRKeyResponseItem.prototype.createTime = 0;
    GetRKeyResponseItem.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.rkey != null && Object.hasOwnProperty.call(message, "rkey"))
        writer2.uint32(
          /* id 1, wireType 2 =*/
          10
        ).string(message.rkey);
      if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
        writer2.uint32(
          /* id 4, wireType 0 =*/
          32
        ).uint32(message.createTime);
      return writer2;
    };
    GetRKeyResponseItem.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Oidb.GetRKeyResponseItem();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.rkey = reader2.string();
            break;
          }
          case 4: {
            message.createTime = reader2.uint32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    GetRKeyResponseItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Oidb.GetRKeyResponseItem";
    };
    return GetRKeyResponseItem;
  }();
  Oidb2.GetRKeyResponseItems = function() {
    function GetRKeyResponseItems(properties) {
      this.rkeyItems = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    GetRKeyResponseItems.prototype.rkeyItems = $util.emptyArray;
    GetRKeyResponseItems.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.rkeyItems != null && message.rkeyItems.length)
        for (let i = 0; i < message.rkeyItems.length; ++i)
          $root.Oidb.GetRKeyResponseItem.encode(message.rkeyItems[i], writer2.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      return writer2;
    };
    GetRKeyResponseItems.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Oidb.GetRKeyResponseItems();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.rkeyItems && message.rkeyItems.length))
              message.rkeyItems = [];
            message.rkeyItems.push($root.Oidb.GetRKeyResponseItem.decode(reader2, reader2.uint32()));
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    GetRKeyResponseItems.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Oidb.GetRKeyResponseItems";
    };
    return GetRKeyResponseItems;
  }();
  Oidb2.GetRKeyResponseBody = function() {
    function GetRKeyResponseBody(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    GetRKeyResponseBody.prototype.result = null;
    GetRKeyResponseBody.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.result != null && Object.hasOwnProperty.call(message, "result"))
        $root.Oidb.GetRKeyResponseItems.encode(message.result, writer2.uint32(
          /* id 4, wireType 2 =*/
          34
        ).fork()).ldelim();
      return writer2;
    };
    GetRKeyResponseBody.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Oidb.GetRKeyResponseBody();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 4: {
            message.result = $root.Oidb.GetRKeyResponseItems.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    GetRKeyResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Oidb.GetRKeyResponseBody";
    };
    return GetRKeyResponseBody;
  }();
  return Oidb2;
})();
const Action = $root.Action = (() => {
  const Action2 = {};
  Action2.SendLongMsgReq = function() {
    function SendLongMsgReq(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    SendLongMsgReq.prototype.info = null;
    SendLongMsgReq.prototype.settings = null;
    SendLongMsgReq.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.info != null && Object.hasOwnProperty.call(message, "info"))
        $root.Action.SendLongMsgInfo.encode(message.info, writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).fork()).ldelim();
      if (message.settings != null && Object.hasOwnProperty.call(message, "settings"))
        $root.Action.LongMsgSettings.encode(message.settings, writer2.uint32(
          /* id 15, wireType 2 =*/
          122
        ).fork()).ldelim();
      return writer2;
    };
    SendLongMsgReq.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Action.SendLongMsgReq();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 2: {
            message.info = $root.Action.SendLongMsgInfo.decode(reader2, reader2.uint32());
            break;
          }
          case 15: {
            message.settings = $root.Action.LongMsgSettings.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    SendLongMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Action.SendLongMsgReq";
    };
    return SendLongMsgReq;
  }();
  Action2.SendLongMsgInfo = function() {
    function SendLongMsgInfo(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    SendLongMsgInfo.prototype.type = 0;
    SendLongMsgInfo.prototype.peer = null;
    SendLongMsgInfo.prototype.groupCode = 0;
    SendLongMsgInfo.prototype.payload = $util.newBuffer([]);
    SendLongMsgInfo.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.type != null && Object.hasOwnProperty.call(message, "type"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.type);
      if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
        $root.Action.LongMsgPeer.encode(message.peer, writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).fork()).ldelim();
      if (message.groupCode != null && Object.hasOwnProperty.call(message, "groupCode"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint32(message.groupCode);
      if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
        writer2.uint32(
          /* id 4, wireType 2 =*/
          34
        ).bytes(message.payload);
      return writer2;
    };
    SendLongMsgInfo.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Action.SendLongMsgInfo();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.type = reader2.uint32();
            break;
          }
          case 2: {
            message.peer = $root.Action.LongMsgPeer.decode(reader2, reader2.uint32());
            break;
          }
          case 3: {
            message.groupCode = reader2.uint32();
            break;
          }
          case 4: {
            message.payload = reader2.bytes();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    SendLongMsgInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Action.SendLongMsgInfo";
    };
    return SendLongMsgInfo;
  }();
  Action2.LongMsgPeer = function() {
    function LongMsgPeer(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    LongMsgPeer.prototype.uid = "";
    LongMsgPeer.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
        writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).string(message.uid);
      return writer2;
    };
    LongMsgPeer.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Action.LongMsgPeer();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 2: {
            message.uid = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    LongMsgPeer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Action.LongMsgPeer";
    };
    return LongMsgPeer;
  }();
  Action2.LongMsgSettings = function() {
    function LongMsgSettings(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    LongMsgSettings.prototype.field1 = 0;
    LongMsgSettings.prototype.field2 = 0;
    LongMsgSettings.prototype.field3 = 0;
    LongMsgSettings.prototype.field4 = 0;
    LongMsgSettings.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.field1 != null && Object.hasOwnProperty.call(message, "field1"))
        writer2.uint32(
          /* id 1, wireType 0 =*/
          8
        ).uint32(message.field1);
      if (message.field2 != null && Object.hasOwnProperty.call(message, "field2"))
        writer2.uint32(
          /* id 2, wireType 0 =*/
          16
        ).uint32(message.field2);
      if (message.field3 != null && Object.hasOwnProperty.call(message, "field3"))
        writer2.uint32(
          /* id 3, wireType 0 =*/
          24
        ).uint32(message.field3);
      if (message.field4 != null && Object.hasOwnProperty.call(message, "field4"))
        writer2.uint32(
          /* id 4, wireType 0 =*/
          32
        ).uint32(message.field4);
      return writer2;
    };
    LongMsgSettings.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Action.LongMsgSettings();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 1: {
            message.field1 = reader2.uint32();
            break;
          }
          case 2: {
            message.field2 = reader2.uint32();
            break;
          }
          case 3: {
            message.field3 = reader2.uint32();
            break;
          }
          case 4: {
            message.field4 = reader2.uint32();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    LongMsgSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Action.LongMsgSettings";
    };
    return LongMsgSettings;
  }();
  Action2.SendLongMsgResp = function() {
    function SendLongMsgResp(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    SendLongMsgResp.prototype.result = null;
    SendLongMsgResp.prototype.settings = null;
    SendLongMsgResp.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.result != null && Object.hasOwnProperty.call(message, "result"))
        $root.Action.SendLongMsgResult.encode(message.result, writer2.uint32(
          /* id 2, wireType 2 =*/
          18
        ).fork()).ldelim();
      if (message.settings != null && Object.hasOwnProperty.call(message, "settings"))
        $root.Action.LongMsgSettings.encode(message.settings, writer2.uint32(
          /* id 15, wireType 2 =*/
          122
        ).fork()).ldelim();
      return writer2;
    };
    SendLongMsgResp.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Action.SendLongMsgResp();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 2: {
            message.result = $root.Action.SendLongMsgResult.decode(reader2, reader2.uint32());
            break;
          }
          case 15: {
            message.settings = $root.Action.LongMsgSettings.decode(reader2, reader2.uint32());
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    SendLongMsgResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Action.SendLongMsgResp";
    };
    return SendLongMsgResp;
  }();
  Action2.SendLongMsgResult = function() {
    function SendLongMsgResult(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    SendLongMsgResult.prototype.resId = "";
    SendLongMsgResult.encode = function encode2(message, writer2) {
      if (!writer2)
        writer2 = $Writer.create();
      if (message.resId != null && Object.hasOwnProperty.call(message, "resId"))
        writer2.uint32(
          /* id 3, wireType 2 =*/
          26
        ).string(message.resId);
      return writer2;
    };
    SendLongMsgResult.decode = function decode2(reader2, length, error) {
      if (!(reader2 instanceof $Reader))
        reader2 = $Reader.create(reader2);
      let end = length === void 0 ? reader2.len : reader2.pos + length, message = new $root.Action.SendLongMsgResult();
      while (reader2.pos < end) {
        let tag = reader2.uint32();
        if (tag === error)
          break;
        switch (tag >>> 3) {
          case 3: {
            message.resId = reader2.string();
            break;
          }
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    SendLongMsgResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Action.SendLongMsgResult";
    };
    return SendLongMsgResult;
  }();
  return Action2;
})();
function deepStringifyMap(obj) {
  if (typeof obj !== "object" || obj === null) return obj;
  if (Array.isArray(obj)) {
    return obj.map((item) => deepStringifyMap(item));
  }
  if (obj instanceof Map) {
    return {
      __dataType: "Map",
      data: Array.from(obj.entries()).map(([k, v]) => [
        deepStringifyMap(k),
        //  key
        deepStringifyMap(v)
        //  value
      ])
    };
  }
  const convertedObj = {};
  for (const key2 in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key2)) {
      convertedObj[key2] = deepStringifyMap(obj[key2]);
    }
  }
  return convertedObj;
}
function deepConvertMap(obj) {
  if (typeof obj !== "object" || obj === null) return obj;
  if (Array.isArray(obj)) {
    return obj.map((item) => deepConvertMap(item));
  }
  const potentialMap = obj;
  if (potentialMap.__dataType === "Map" && "data" in potentialMap) {
    const entries = Array.isArray(potentialMap.data) ? potentialMap.data.map(([k, v]) => [
      deepConvertMap(k),
      deepConvertMap(v)
    ]) : [];
    return new Map(entries);
  }
  const convertedObj = {};
  for (const key2 in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key2)) {
      convertedObj[key2] = deepConvertMap(obj[key2]);
    }
  }
  return convertedObj;
}
var ElementType = /* @__PURE__ */ ((ElementType2) => {
  ElementType2[ElementType2["Text"] = 1] = "Text";
  ElementType2[ElementType2["Pic"] = 2] = "Pic";
  ElementType2[ElementType2["File"] = 3] = "File";
  ElementType2[ElementType2["Ptt"] = 4] = "Ptt";
  ElementType2[ElementType2["Video"] = 5] = "Video";
  ElementType2[ElementType2["Face"] = 6] = "Face";
  ElementType2[ElementType2["Reply"] = 7] = "Reply";
  ElementType2[ElementType2["GrayTip"] = 8] = "GrayTip";
  ElementType2[ElementType2["Ark"] = 10] = "Ark";
  ElementType2[ElementType2["MarketFace"] = 11] = "MarketFace";
  ElementType2[ElementType2["LiveGift"] = 12] = "LiveGift";
  ElementType2[ElementType2["StructLongMsg"] = 13] = "StructLongMsg";
  ElementType2[ElementType2["Markdown"] = 14] = "Markdown";
  ElementType2[ElementType2["Giphy"] = 15] = "Giphy";
  ElementType2[ElementType2["MultiForward"] = 16] = "MultiForward";
  ElementType2[ElementType2["InlineKeyboard"] = 17] = "InlineKeyboard";
  ElementType2[ElementType2["Calendar"] = 19] = "Calendar";
  ElementType2[ElementType2["YoloGameResult"] = 20] = "YoloGameResult";
  ElementType2[ElementType2["AvRecord"] = 21] = "AvRecord";
  ElementType2[ElementType2["TofuRecord"] = 23] = "TofuRecord";
  ElementType2[ElementType2["FaceBubble"] = 27] = "FaceBubble";
  ElementType2[ElementType2["ShareLocation"] = 28] = "ShareLocation";
  ElementType2[ElementType2["TaskTopMsg"] = 29] = "TaskTopMsg";
  ElementType2[ElementType2["RecommendedMsg"] = 43] = "RecommendedMsg";
  ElementType2[ElementType2["ActionBar"] = 44] = "ActionBar";
  return ElementType2;
})(ElementType || {});
var AtType = /* @__PURE__ */ ((AtType2) => {
  AtType2[AtType2["Unknown"] = 0] = "Unknown";
  AtType2[AtType2["All"] = 1] = "All";
  AtType2[AtType2["One"] = 2] = "One";
  return AtType2;
})(AtType || {});
const IMAGE_HTTP_HOST = "https://gchat.qpic.cn";
const IMAGE_HTTP_HOST_NT = "https://multimedia.nt.qq.com.cn";
var PicType = /* @__PURE__ */ ((PicType2) => {
  PicType2[PicType2["GIF"] = 2e3] = "GIF";
  PicType2[PicType2["JPEG"] = 1e3] = "JPEG";
  return PicType2;
})(PicType || {});
var TipGroupElementType = /* @__PURE__ */ ((TipGroupElementType2) => {
  TipGroupElementType2[TipGroupElementType2["MemberIncrease"] = 1] = "MemberIncrease";
  TipGroupElementType2[TipGroupElementType2["Kicked"] = 3] = "Kicked";
  TipGroupElementType2[TipGroupElementType2["Ban"] = 8] = "Ban";
  return TipGroupElementType2;
})(TipGroupElementType || {});
var GrayTipElementSubType = /* @__PURE__ */ ((GrayTipElementSubType2) => {
  GrayTipElementSubType2[GrayTipElementSubType2["Revoke"] = 1] = "Revoke";
  GrayTipElementSubType2[GrayTipElementSubType2["Proclamation"] = 2] = "Proclamation";
  GrayTipElementSubType2[GrayTipElementSubType2["EmojiReply"] = 3] = "EmojiReply";
  GrayTipElementSubType2[GrayTipElementSubType2["Group"] = 4] = "Group";
  GrayTipElementSubType2[GrayTipElementSubType2["Buddy"] = 5] = "Buddy";
  GrayTipElementSubType2[GrayTipElementSubType2["Feed"] = 6] = "Feed";
  GrayTipElementSubType2[GrayTipElementSubType2["Essence"] = 7] = "Essence";
  GrayTipElementSubType2[GrayTipElementSubType2["GroupNotify"] = 8] = "GroupNotify";
  GrayTipElementSubType2[GrayTipElementSubType2["BuddyNotify"] = 9] = "BuddyNotify";
  GrayTipElementSubType2[GrayTipElementSubType2["File"] = 10] = "File";
  GrayTipElementSubType2[GrayTipElementSubType2["FeedChannelMsg"] = 11] = "FeedChannelMsg";
  GrayTipElementSubType2[GrayTipElementSubType2["XmlMsg"] = 12] = "XmlMsg";
  GrayTipElementSubType2[GrayTipElementSubType2["LocalMsg"] = 13] = "LocalMsg";
  GrayTipElementSubType2[GrayTipElementSubType2["Block"] = 14] = "Block";
  GrayTipElementSubType2[GrayTipElementSubType2["AioOp"] = 15] = "AioOp";
  GrayTipElementSubType2[GrayTipElementSubType2["Wallet"] = 16] = "Wallet";
  GrayTipElementSubType2[GrayTipElementSubType2["JSON"] = 17] = "JSON";
  return GrayTipElementSubType2;
})(GrayTipElementSubType || {});
var FaceIndex = /* @__PURE__ */ ((FaceIndex2) => {
  FaceIndex2[FaceIndex2["Dice"] = 358] = "Dice";
  FaceIndex2[FaceIndex2["RPS"] = 359] = "RPS";
  return FaceIndex2;
})(FaceIndex || {});
var ChatType = /* @__PURE__ */ ((ChatType2) => {
  ChatType2[ChatType2["C2C"] = 1] = "C2C";
  ChatType2[ChatType2["Group"] = 2] = "Group";
  ChatType2[ChatType2["TempC2CFromGroup"] = 100] = "TempC2CFromGroup";
  return ChatType2;
})(ChatType || {});
class PMHQ {
  reconnectTimer;
  httpUrl = "http://127.0.0.1:13000";
  wsUrl = "ws://127.0.0.1:13000/ws";
  ws;
  resListeners = /* @__PURE__ */ new Map();
  constructor() {
    console.log(process.argv);
    const { pmhqHost, pmhqPort } = this.getPMHQHostPort();
    this.httpUrl = `http://${pmhqHost}:${pmhqPort}/`;
    this.wsUrl = `ws://${pmhqHost}:${pmhqPort}/ws`;
    this.connectWebSocket().then();
  }
  getPMHQHostPort() {
    let pmhqPort = "13000";
    let pmhqHost = "127.0.0.1";
    for (const pArg of process.argv) {
      if (pArg.startsWith("--pmhq-port=")) {
        pmhqPort = pArg.replace("--pmhq-port=", "");
      } else if (pArg.startsWith("--pmhq-host=")) {
        pmhqHost = pArg.replace("--pmhq-host=", "");
      }
    }
    return { pmhqPort, pmhqHost };
  }
  addResListener(listener) {
    const listenerId = randomUUID();
    this.resListeners.set(listenerId, listener);
    return listenerId;
  }
  removeResListener(listenerId) {
    this.resListeners.delete(listenerId);
  }
  async connectWebSocket() {
    const reconnect = () => {
      this.ws = void 0;
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = void 0;
      }
      this.reconnectTimer = setTimeout(() => {
        this.connectWebSocket();
      }, 999);
    };
    try {
      this.ws = new WebSocket$1(this.wsUrl);
    } catch (e) {
      return reconnect();
    }
    this.ws.onmessage = async (event) => {
      let data;
      try {
        data = JSON.parse(event.data.toString());
      } catch (e) {
        console.error(" PMHQ ", event.data, e);
        return;
      }
      data = deepConvertMap(data);
      for (const func of this.resListeners.values()) {
        setImmediate(() => {
          try {
            func(data);
          } catch (e) {
            console.error("PMHQ res listener error", e);
          }
        });
      }
    };
    this.ws.onerror = (error) => {
      console.error("PMHQ WebSocket ", "...");
      reconnect();
    };
    this.ws.onclose = () => {
      console.info("PMHQ WebSocket ...");
      reconnect();
    };
    this.ws.onopen = () => {
      console.info("PMHQ WebSocket ");
    };
  }
  async call(func, args, timeout2 = 1e4) {
    const payload = {
      type: "call",
      data: {
        func,
        args
      }
    };
    const result = (await this.wsSend(payload, timeout2)).data?.result;
    return result;
  }
  async waitConnected() {
    return new Promise((resolve2, reject) => {
      const check = () => {
        if (this.ws && this.ws.readyState === WebSocket$1.OPEN) {
          resolve2(true);
        } else {
          setTimeout(check, 1e3);
        }
      };
      check();
    });
  }
  async wsSend(data, timeout2 = 1e4) {
    await this.waitConnected();
    let echo = data.data?.echo;
    if (!data.data?.echo) {
      echo = randomUUID();
      data.data.echo = echo;
    }
    const payload = JSON.stringify(deepStringifyMap(data));
    const p = new Promise((resolve2, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error("pmhq ws send: wait result timeout"));
        this.removeResListener(listenerId);
      }, timeout2);
      const listenerId = this.addResListener((res) => {
        if (!res.data) {
          console.error(`PMHQ WS send error: payload ${data}, response ${res}`);
        }
        if (res.data?.echo == echo) {
          resolve2(res);
          clearTimeout(timeoutId);
          this.removeResListener(listenerId);
        }
      });
    });
    this.ws.send(payload);
    return p;
  }
  async httpSend(data) {
    const payload = JSON.stringify(deepStringifyMap(data));
    const response2 = await fetch(this.httpUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: payload
    });
    if (!response2.ok) {
      const errorBody = await response2.text();
      throw new Error(`PMHQPMHQ ${response2.status} - ${errorBody}`);
    }
    let result = await response2.json();
    result = deepConvertMap(result);
    return result;
  }
  async httpSendPB(cmd, pb) {
    return (await this.httpSend({
      type: "send",
      data: {
        cmd,
        pb: Buffer.from(pb).toString("hex")
      }
    })).data;
  }
  async wsSendPB(cmd, pb) {
    return (await this.wsSend({
      type: "send",
      data: {
        cmd,
        pb: Buffer.from(pb).toString("hex")
      }
    })).data;
  }
  async sendPB(cmd, hex) {
    return (await this.wsSend({
      type: "send",
      data: {
        cmd,
        pb: hex
      }
    })).data;
  }
  async sendFriendPoke(uin) {
    const body = Oidb.SendPoke.encode({
      toUin: uin,
      friendUin: uin
    }).finish();
    const data = Oidb.Base.encode({
      command: 3795,
      subCommand: 1,
      body
    }).finish();
    return await this.wsSendPB("OidbSvcTrpcTcp.0xed3_1", data);
  }
  async sendGroupPoke(groupCode, memberUin) {
    const body = Oidb.SendPoke.encode({
      toUin: memberUin,
      groupCode
    }).finish();
    const data = Oidb.Base.encode({
      command: 3795,
      subCommand: 1,
      body
    }).finish();
    return await this.wsSendPB("OidbSvcTrpcTcp.0xed3_1", data);
  }
  async setSpecialTitle(groupCode, memberUid, title) {
    const body = Oidb.SetSpecialTitle.encode({
      groupCode,
      body: {
        targetUid: memberUid,
        uidName: title,
        specialTitle: title,
        expireTime: -1
      }
    }).finish();
    const data = Oidb.Base.encode({
      command: 2300,
      subCommand: 2,
      body
    }).finish();
    return await this.httpSendPB("OidbSvcTrpcTcp.0x8fc_2", data);
  }
  async getRKey() {
    const hexStr = "08e7a00210ca01221c0a130a05080110ca011206a80602b006011a02080122050a030a1400";
    const data = Buffer.from(hexStr, "hex");
    const resp = await this.wsSendPB("OidbSvcTrpcTcp.0xed3_1", data);
    const rkeyBody = Oidb.Base.decode(Buffer.from(resp.pb, "hex")).body;
    const rkeyItems = Oidb.GetRKeyResponseBody.decode(rkeyBody).result?.rkeyItems;
    return {
      privateRKey: rkeyItems[0]?.rkey,
      groupRKey: rkeyItems[1]?.rkey
    };
  }
  async uploadForward(peer, items) {
    const transmit = Msg.PbMultiMsgTransmit.encode({ pbItemList: items }).finish();
    const isGroup = peer.chatType === ChatType.Group;
    const data = Action.SendLongMsgReq.encode({
      info: {
        type: isGroup ? 3 : 1,
        peer: {
          uid: isGroup ? peer.peerUid : selfInfo.uid
        },
        groupCode: isGroup ? +peer.peerUid : 0,
        payload: gzipSync(transmit)
      },
      settings: {
        field1: 4,
        field2: 1,
        field3: 7,
        field4: 0
      }
    }).finish();
    const res = await this.httpSendPB("trpc.group.long_msg_interface.MsgService.SsoSendLongMsg", data);
    return Action.SendLongMsgResp.decode(Buffer.from(res.pb, "hex")).result.resId;
  }
}
const pmhq = new PMHQ();
var ReceiveCmdS = /* @__PURE__ */ ((ReceiveCmdS2) => {
  ReceiveCmdS2["RECENT_CONTACT"] = "nodeIKernelRecentContactListener/onRecentContactListChangedVer2";
  ReceiveCmdS2["UPDATE_MSG"] = "nodeIKernelMsgListener/onMsgInfoListUpdate";
  ReceiveCmdS2["UPDATE_ACTIVE_MSG"] = "nodeIKernelMsgListener/onActiveMsgInfoUpdate";
  ReceiveCmdS2["NEW_MSG"] = "nodeIKernelMsgListener/onRecvMsg";
  ReceiveCmdS2["NEW_ACTIVE_MSG"] = "nodeIKernelMsgListener/onRecvActiveMsg";
  ReceiveCmdS2["SELF_SEND_MSG"] = "nodeIKernelMsgListener/onAddSendMsg";
  ReceiveCmdS2["USER_INFO"] = "nodeIKernelProfileListener/onProfileSimpleChanged";
  ReceiveCmdS2["USER_DETAIL_INFO"] = "nodeIKernelProfileListener/onProfileDetailInfoChanged";
  ReceiveCmdS2["GROUPS"] = "nodeIKernelGroupListener/onGroupListUpdate";
  ReceiveCmdS2["GROUPS_STORE"] = "onGroupListUpdate";
  ReceiveCmdS2["GROUP_MEMBER_INFO_UPDATE"] = "nodeIKernelGroupListener/onMemberInfoChange";
  ReceiveCmdS2["FRIENDS"] = "nodeIKernelBuddyListener/onBuddyListChange";
  ReceiveCmdS2["MEDIA_DOWNLOAD_COMPLETE"] = "nodeIKernelMsgListener/onRichMediaDownloadComplete";
  ReceiveCmdS2["UNREAD_GROUP_NOTIFY"] = "nodeIKernelGroupListener/onGroupNotifiesUnreadCountUpdated";
  ReceiveCmdS2["GROUP_NOTIFY"] = "nodeIKernelGroupListener/onGroupSingleScreenNotifies";
  ReceiveCmdS2["FRIEND_REQUEST"] = "nodeIKernelBuddyListener/onBuddyReqChange";
  ReceiveCmdS2["SELF_STATUS"] = "nodeIKernelProfileListener/onSelfStatusChanged";
  ReceiveCmdS2["CACHE_SCAN_FINISH"] = "nodeIKernelStorageCleanListener/onFinishScan";
  ReceiveCmdS2["MEDIA_UPLOAD_COMPLETE"] = "nodeIKernelMsgListener/onRichMediaUploadComplete";
  ReceiveCmdS2["FLASH_FILE_DOWNLOAD_STATUS"] = "nodeIKernelFlashTransferListener/onFileSetDownloadTaskStatusChange";
  ReceiveCmdS2["FLASH_FILE_DOWNLOADING"] = "nodeIKernelFlashTransferListener/onFileSetDownloadTaskProgressChanged";
  ReceiveCmdS2["FLASH_FILE_UPLOAD_STATUS"] = "nodeIKernelFlashTransferListener/onFileSetUploadStatusChanged";
  ReceiveCmdS2["FLASH_FILE_UPLOADING"] = "nodeIKernelFlashTransferListener/onFileSetUploadProgressChanged";
  return ReceiveCmdS2;
})(ReceiveCmdS || {});
const receiveHooks = /* @__PURE__ */ new Map();
const NT_RECV_PMHQ_TYPE_TO_NT_METHOD = {
  "on_message": "nodeIKernelMsgListener",
  "on_group": "nodeIKernelGroupListener",
  "on_buddy": "nodeIKernelBuddyListener",
  "on_profile": "nodeIKernelProfileListener",
  "on_flash_file": "nodeIKernelFlashTransferListener"
};
function startHook() {
  pmhq.addResListener((data) => {
    let listenerName = data.type;
    if ("sub_type" in data.data && listenerName in NT_RECV_PMHQ_TYPE_TO_NT_METHOD) {
      const sub_type = data.data.sub_type;
      const ntCmd = NT_RECV_PMHQ_TYPE_TO_NT_METHOD[listenerName] + "/" + sub_type;
      for (const hook of receiveHooks.values()) {
        if (hook.method.includes(ntCmd)) {
          Promise.resolve(hook.hookFunc(data.data.data));
        }
      }
    }
  });
}
function registerReceiveHook(method, hookFunc) {
  const id = randomUUID();
  if (!Array.isArray(method)) {
    method = [method];
  }
  receiveHooks.set(id, {
    method,
    hookFunc
  });
  return id;
}
function removeReceiveHook(id) {
  receiveHooks.delete(id);
}
var Sex = /* @__PURE__ */ ((Sex2) => {
  Sex2[Sex2["Unknown"] = 0] = "Unknown";
  Sex2[Sex2["Male"] = 1] = "Male";
  Sex2[Sex2["Female"] = 2] = "Female";
  Sex2[Sex2["Hidden"] = 255] = "Hidden";
  return Sex2;
})(Sex || {});
var UserDetailSource = /* @__PURE__ */ ((UserDetailSource2) => {
  UserDetailSource2[UserDetailSource2["KDB"] = 0] = "KDB";
  UserDetailSource2[UserDetailSource2["KSERVER"] = 1] = "KSERVER";
  return UserDetailSource2;
})(UserDetailSource || {});
var ProfileBizType = /* @__PURE__ */ ((ProfileBizType2) => {
  ProfileBizType2[ProfileBizType2["KALL"] = 0] = "KALL";
  ProfileBizType2[ProfileBizType2["KBASEEXTEND"] = 1] = "KBASEEXTEND";
  ProfileBizType2[ProfileBizType2["KVAS"] = 2] = "KVAS";
  ProfileBizType2[ProfileBizType2["KQZONE"] = 3] = "KQZONE";
  ProfileBizType2[ProfileBizType2["KOTHER"] = 4] = "KOTHER";
  return ProfileBizType2;
})(ProfileBizType || {});
var GroupMemberRole = /* @__PURE__ */ ((GroupMemberRole2) => {
  GroupMemberRole2[GroupMemberRole2["Normal"] = 2] = "Normal";
  GroupMemberRole2[GroupMemberRole2["Admin"] = 3] = "Admin";
  GroupMemberRole2[GroupMemberRole2["Owner"] = 4] = "Owner";
  return GroupMemberRole2;
})(GroupMemberRole || {});
var GroupNotifyType = /* @__PURE__ */ ((GroupNotifyType2) => {
  GroupNotifyType2[GroupNotifyType2["InvitedByMember"] = 1] = "InvitedByMember";
  GroupNotifyType2[GroupNotifyType2["RefuseInvited"] = 2] = "RefuseInvited";
  GroupNotifyType2[GroupNotifyType2["RefusedByAdminiStrator"] = 3] = "RefusedByAdminiStrator";
  GroupNotifyType2[GroupNotifyType2["AgreedTojoinDirect"] = 4] = "AgreedTojoinDirect";
  GroupNotifyType2[GroupNotifyType2["InvitedNeedAdminiStratorPass"] = 5] = "InvitedNeedAdminiStratorPass";
  GroupNotifyType2[GroupNotifyType2["AgreedToJoinByAdminiStrator"] = 6] = "AgreedToJoinByAdminiStrator";
  GroupNotifyType2[GroupNotifyType2["RequestJoinNeedAdminiStratorPass"] = 7] = "RequestJoinNeedAdminiStratorPass";
  GroupNotifyType2[GroupNotifyType2["SetAdmin"] = 8] = "SetAdmin";
  GroupNotifyType2[GroupNotifyType2["KickMemberNotifyAdmin"] = 9] = "KickMemberNotifyAdmin";
  GroupNotifyType2[GroupNotifyType2["KickMemberNotifyKicked"] = 10] = "KickMemberNotifyKicked";
  GroupNotifyType2[GroupNotifyType2["MemberLeaveNotifyAdmin"] = 11] = "MemberLeaveNotifyAdmin";
  GroupNotifyType2[GroupNotifyType2["CancelAdminNotifyCanceled"] = 12] = "CancelAdminNotifyCanceled";
  GroupNotifyType2[GroupNotifyType2["CancelAdminNotifyAdmin"] = 13] = "CancelAdminNotifyAdmin";
  GroupNotifyType2[GroupNotifyType2["TransferGroupNotifyOldowner"] = 14] = "TransferGroupNotifyOldowner";
  GroupNotifyType2[GroupNotifyType2["TransferGroupNotifyAdmin"] = 15] = "TransferGroupNotifyAdmin";
  return GroupNotifyType2;
})(GroupNotifyType || {});
var GroupNotifyStatus = /* @__PURE__ */ ((GroupNotifyStatus2) => {
  GroupNotifyStatus2[GroupNotifyStatus2["Init"] = 0] = "Init";
  GroupNotifyStatus2[GroupNotifyStatus2["Unhandle"] = 1] = "Unhandle";
  GroupNotifyStatus2[GroupNotifyStatus2["Agreed"] = 2] = "Agreed";
  GroupNotifyStatus2[GroupNotifyStatus2["Refused"] = 3] = "Refused";
  GroupNotifyStatus2[GroupNotifyStatus2["Ignored"] = 4] = "Ignored";
  return GroupNotifyStatus2;
})(GroupNotifyStatus || {});
var GroupRequestOperateTypes = /* @__PURE__ */ ((GroupRequestOperateTypes2) => {
  GroupRequestOperateTypes2[GroupRequestOperateTypes2["Approve"] = 1] = "Approve";
  GroupRequestOperateTypes2[GroupRequestOperateTypes2["Reject"] = 2] = "Reject";
  return GroupRequestOperateTypes2;
})(GroupRequestOperateTypes || {});
var BuddyReqType = /* @__PURE__ */ ((BuddyReqType2) => {
  BuddyReqType2[BuddyReqType2["MsgInfo"] = 12] = "MsgInfo";
  BuddyReqType2[BuddyReqType2["MeInitiatorWaitPeerConfirm"] = 13] = "MeInitiatorWaitPeerConfirm";
  return BuddyReqType2;
})(BuddyReqType || {});
const version = "5.3.0";
async function logSummaryMessage(ctx, message) {
  const direction = message.senderUid == selfInfo.uid ? "" : "";
  let sender = message.sendMemberName || message.sendRemarkName || message.sendNickName;
  const senderUin = message.senderUin;
  let summary = "";
  for (const msgEle of message.elements) {
    switch (msgEle.elementType) {
      case ElementType.Text:
        {
          summary += `${msgEle.textElement?.content}`;
        }
        break;
      case ElementType.Pic:
        {
          summary += `[]${msgEle.picElement?.fileName}
`;
        }
        break;
      case ElementType.Face:
        {
          summary += `[]${msgEle.faceElement?.faceText || ""}
`;
        }
        break;
      case ElementType.Ptt:
        {
          summary += `[](${msgEle.pttElement?.fileName})`;
        }
        break;
      case ElementType.Video:
        {
          summary += `[]${msgEle.videoElement?.fileName}`;
        }
        break;
      case ElementType.File:
        {
          summary += `[]${msgEle.fileElement?.fileName}
`;
        }
        break;
      case ElementType.Ark:
        {
          summary += `[]
`;
        }
        break;
      case ElementType.MultiForward: {
        summary += `[]
`;
      }
    }
  }
  if (!summary) {
    return;
  }
  new Date(parseInt(message.msgTime) * 1e3);
  let peerName = "";
  if (message.chatType == ChatType.Group) {
    peerName = `] ${message.peerName}(${message.peerUid}) ${sender}(${senderUin})`;
  } else if (message.chatType == ChatType.C2C) {
    try {
      const userUid = message.peerUid;
      const userInfo = (await ctx.ntUserApi.getUserDetailInfoWithBizInfo(userUid)).coreInfo;
      sender = userInfo.remark || userInfo.nick;
      peerName = `] ${sender}(${userInfo.uin})`;
    } catch (e) {
      return;
    }
  } else if (message.chatType == ChatType.TempC2CFromGroup) {
    peerName = `] ${message.peerName}(${message.peerUin})`;
  }
  const logMsg = `[${direction}-${peerName}
${summary}`;
  ctx.logger.info(logMsg);
}
var utils$3 = { exports: {} };
var windows;
var hasRequiredWindows;
function requireWindows() {
  if (hasRequiredWindows) return windows;
  hasRequiredWindows = 1;
  windows = isexe;
  isexe.sync = sync;
  var fs2 = fs$1;
  function checkPathExt(path2, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path2.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat2, path2, options) {
    if (!stat2.isSymbolicLink() && !stat2.isFile()) {
      return false;
    }
    return checkPathExt(path2, options);
  }
  function isexe(path2, options, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, path2, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs2.statSync(path2), path2, options);
  }
  return windows;
}
var mode;
var hasRequiredMode;
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1;
  mode = isexe;
  isexe.sync = sync;
  var fs2 = fs$1;
  function isexe(path2, options, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs2.statSync(path2), options);
  }
  function checkStat(stat2, options) {
    return stat2.isFile() && checkMode(stat2, options);
  }
  function checkMode(stat2, options) {
    var mod2 = stat2.mode;
    var uid = stat2.uid;
    var gid = stat2.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
    return ret;
  }
  return mode;
}
var isexe_1;
var hasRequiredIsexe;
function requireIsexe() {
  if (hasRequiredIsexe) return isexe_1;
  hasRequiredIsexe = 1;
  var core;
  if (process.platform === "win32" || commonjsGlobal.TESTING_WINDOWS) {
    core = requireWindows();
  } else {
    core = requireMode();
  }
  isexe_1 = isexe;
  isexe.sync = sync;
  function isexe(path2, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve2, reject) {
        isexe(path2, options || {}, function(er, is2) {
          if (er) {
            reject(er);
          } else {
            resolve2(is2);
          }
        });
      });
    }
    core(path2, options || {}, function(er, is2) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is2 = false;
        }
      }
      cb(er, is2);
    });
  }
  function sync(path2, options) {
    try {
      return core.sync(path2, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
  return isexe_1;
}
var which_1;
var hasRequiredWhich;
function requireWhich() {
  if (hasRequiredWhich) return which_1;
  hasRequiredWhich = 1;
  which_1 = which;
  which.sync = whichSync;
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path2 = require$$1$2;
  var COLON = isWindows ? ";" : ":";
  var isexe = requireIsexe();
  function getNotFoundError(cmd) {
    var er = new Error("not found: " + cmd);
    er.code = "ENOENT";
    return er;
  }
  function getPathInfo(cmd, opt) {
    var colon = opt.colon || COLON;
    var pathEnv = opt.path || process.env.PATH || "";
    var pathExt = [""];
    pathEnv = pathEnv.split(colon);
    var pathExtExe = "";
    if (isWindows) {
      pathEnv.unshift(process.cwd());
      pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
      pathExt = pathExtExe.split(colon);
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
      pathEnv = [""];
    return {
      env: pathEnv,
      ext: pathExt,
      extExe: pathExtExe
    };
  }
  function which(cmd, opt, cb) {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    (function F(i, l) {
      if (i === l) {
        if (opt.all && found.length)
          return cb(null, found);
        else
          return cb(getNotFoundError(cmd));
      }
      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1);
      var p = path2.join(pathPart, cmd);
      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }
      (function E(ii, ll) {
        if (ii === ll) return F(i + 1, l);
        var ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, function(er, is2) {
          if (!er && is2) {
            if (opt.all)
              found.push(p + ext);
            else
              return cb(null, p + ext);
          }
          return E(ii + 1, ll);
        });
      })(0, pathExt.length);
    })(0, pathEnv.length);
  }
  function whichSync(cmd, opt) {
    opt = opt || {};
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    for (var i = 0, l = pathEnv.length; i < l; i++) {
      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1);
      var p = path2.join(pathPart, cmd);
      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }
      for (var j = 0, ll = pathExt.length; j < ll; j++) {
        var cur = p + pathExt[j];
        var is2;
        try {
          is2 = isexe.sync(cur, { pathExt: pathExtExe });
          if (is2) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  }
  return which_1;
}
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3.exports;
  hasRequiredUtils$3 = 1;
  require$$0$6.exec;
  var isWindows = require$$0$5.platform().match(/win(32|64)/);
  var which = requireWhich();
  var nlRegexp = /\r\n|\r|\n/g;
  var streamRegexp = /^\[?(.*?)\]?$/;
  var filterEscapeRegexp = /[,]/;
  var whichCache = {};
  function parseProgressLine(line2) {
    var progress = {};
    line2 = line2.replace(/=\s+/g, "=").trim();
    var progressParts = line2.split(" ");
    for (var i = 0; i < progressParts.length; i++) {
      var progressSplit = progressParts[i].split("=", 2);
      var key2 = progressSplit[0];
      var value = progressSplit[1];
      if (typeof value === "undefined")
        return null;
      progress[key2] = value;
    }
    return progress;
  }
  var utils2 = utils$3.exports = {
    isWindows,
    streamRegexp,
    /**
     * Copy an object keys into another one
     *
     * @param {Object} source source object
     * @param {Object} dest destination object
     * @private
     */
    copy: function(source2, dest) {
      Object.keys(source2).forEach(function(key2) {
        dest[key2] = source2[key2];
      });
    },
    /**
     * Create an argument list
     *
     * Returns a function that adds new arguments to the list.
     * It also has the following methods:
     * - clear() empties the argument list
     * - get() returns the argument list
     * - find(arg, count) finds 'arg' in the list and return the following 'count' items, or undefined if not found
     * - remove(arg, count) remove 'arg' in the list as well as the following 'count' items
     *
     * @private
     */
    args: function() {
      var list = [];
      var argfunc = function() {
        if (arguments.length === 1 && Array.isArray(arguments[0])) {
          list = list.concat(arguments[0]);
        } else {
          list = list.concat([].slice.call(arguments));
        }
      };
      argfunc.clear = function() {
        list = [];
      };
      argfunc.get = function() {
        return list;
      };
      argfunc.find = function(arg, count) {
        var index = list.indexOf(arg);
        if (index !== -1) {
          return list.slice(index + 1, index + 1 + (count || 0));
        }
      };
      argfunc.remove = function(arg, count) {
        var index = list.indexOf(arg);
        if (index !== -1) {
          list.splice(index, (count || 0) + 1);
        }
      };
      argfunc.clone = function() {
        var cloned = utils2.args();
        cloned(list);
        return cloned;
      };
      return argfunc;
    },
    /**
     * Generate filter strings
     *
     * @param {String[]|Object[]} filters filter specifications. When using objects,
     *   each must have the following properties:
     * @param {String} filters.filter filter name
     * @param {String|Array} [filters.inputs] (array of) input stream specifier(s) for the filter,
     *   defaults to ffmpeg automatically choosing the first unused matching streams
     * @param {String|Array} [filters.outputs] (array of) output stream specifier(s) for the filter,
     *   defaults to ffmpeg automatically assigning the output to the output file
     * @param {Object|String|Array} [filters.options] filter options, can be omitted to not set any options
     * @return String[]
     * @private
     */
    makeFilterStrings: function(filters) {
      return filters.map(function(filterSpec) {
        if (typeof filterSpec === "string") {
          return filterSpec;
        }
        var filterString = "";
        if (Array.isArray(filterSpec.inputs)) {
          filterString += filterSpec.inputs.map(function(streamSpec) {
            return streamSpec.replace(streamRegexp, "[$1]");
          }).join("");
        } else if (typeof filterSpec.inputs === "string") {
          filterString += filterSpec.inputs.replace(streamRegexp, "[$1]");
        }
        filterString += filterSpec.filter;
        if (filterSpec.options) {
          if (typeof filterSpec.options === "string" || typeof filterSpec.options === "number") {
            filterString += "=" + filterSpec.options;
          } else if (Array.isArray(filterSpec.options)) {
            filterString += "=" + filterSpec.options.map(function(option) {
              if (typeof option === "string" && option.match(filterEscapeRegexp)) {
                return "'" + option + "'";
              } else {
                return option;
              }
            }).join(":");
          } else if (Object.keys(filterSpec.options).length) {
            filterString += "=" + Object.keys(filterSpec.options).map(function(option) {
              var value = filterSpec.options[option];
              if (typeof value === "string" && value.match(filterEscapeRegexp)) {
                value = "'" + value + "'";
              }
              return option + "=" + value;
            }).join(":");
          }
        }
        if (Array.isArray(filterSpec.outputs)) {
          filterString += filterSpec.outputs.map(function(streamSpec) {
            return streamSpec.replace(streamRegexp, "[$1]");
          }).join("");
        } else if (typeof filterSpec.outputs === "string") {
          filterString += filterSpec.outputs.replace(streamRegexp, "[$1]");
        }
        return filterString;
      });
    },
    /**
     * Search for an executable
     *
     * Uses 'which' or 'where' depending on platform
     *
     * @param {String} name executable name
     * @param {Function} callback callback with signature (err, path)
     * @private
     */
    which: function(name, callback) {
      if (name in whichCache) {
        return callback(null, whichCache[name]);
      }
      which(name, function(err, result) {
        if (err) {
          return callback(null, whichCache[name] = "");
        }
        callback(null, whichCache[name] = result);
      });
    },
    /**
     * Convert a [[hh:]mm:]ss[.xxx] timemark into seconds
     *
     * @param {String} timemark timemark string
     * @return Number
     * @private
     */
    timemarkToSeconds: function(timemark) {
      if (typeof timemark === "number") {
        return timemark;
      }
      if (timemark.indexOf(":") === -1 && timemark.indexOf(".") >= 0) {
        return Number(timemark);
      }
      var parts = timemark.split(":");
      var secs = Number(parts.pop());
      if (parts.length) {
        secs += Number(parts.pop()) * 60;
      }
      if (parts.length) {
        secs += Number(parts.pop()) * 3600;
      }
      return secs;
    },
    /**
     * Extract codec data from ffmpeg stderr and emit 'codecData' event if appropriate
     * Call it with an initially empty codec object once with each line of stderr output until it returns true
     *
     * @param {FfmpegCommand} command event emitter
     * @param {String} stderrLine ffmpeg stderr output line
     * @param {Object} codecObject object used to accumulate codec data between calls
     * @return {Boolean} true if codec data is complete (and event was emitted), false otherwise
     * @private
     */
    extractCodecData: function(command, stderrLine, codecsObject) {
      var inputPattern = /Input #[0-9]+, ([^ ]+),/;
      var durPattern = /Duration\: ([^,]+)/;
      var audioPattern = /Audio\: (.*)/;
      var videoPattern = /Video\: (.*)/;
      if (!("inputStack" in codecsObject)) {
        codecsObject.inputStack = [];
        codecsObject.inputIndex = -1;
        codecsObject.inInput = false;
      }
      var inputStack = codecsObject.inputStack;
      var inputIndex = codecsObject.inputIndex;
      var inInput = codecsObject.inInput;
      var format, dur, audio2, video2;
      if (format = stderrLine.match(inputPattern)) {
        inInput = codecsObject.inInput = true;
        inputIndex = codecsObject.inputIndex = codecsObject.inputIndex + 1;
        inputStack[inputIndex] = { format: format[1], audio: "", video: "", duration: "" };
      } else if (inInput && (dur = stderrLine.match(durPattern))) {
        inputStack[inputIndex].duration = dur[1];
      } else if (inInput && (audio2 = stderrLine.match(audioPattern))) {
        audio2 = audio2[1].split(", ");
        inputStack[inputIndex].audio = audio2[0];
        inputStack[inputIndex].audio_details = audio2;
      } else if (inInput && (video2 = stderrLine.match(videoPattern))) {
        video2 = video2[1].split(", ");
        inputStack[inputIndex].video = video2[0];
        inputStack[inputIndex].video_details = video2;
      } else if (/Output #\d+/.test(stderrLine)) {
        inInput = codecsObject.inInput = false;
      } else if (/Stream mapping:|Press (\[q\]|ctrl-c) to stop/.test(stderrLine)) {
        command.emit.apply(command, ["codecData"].concat(inputStack));
        return true;
      }
      return false;
    },
    /**
     * Extract progress data from ffmpeg stderr and emit 'progress' event if appropriate
     *
     * @param {FfmpegCommand} command event emitter
     * @param {String} stderrLine ffmpeg stderr data
     * @private
     */
    extractProgress: function(command, stderrLine) {
      var progress = parseProgressLine(stderrLine);
      if (progress) {
        var ret = {
          frames: parseInt(progress.frame, 10),
          currentFps: parseInt(progress.fps, 10),
          currentKbps: progress.bitrate ? parseFloat(progress.bitrate.replace("kbits/s", "")) : 0,
          targetSize: parseInt(progress.size || progress.Lsize, 10),
          timemark: progress.time
        };
        if (command._ffprobeData && command._ffprobeData.format && command._ffprobeData.format.duration) {
          var duration = Number(command._ffprobeData.format.duration);
          if (!isNaN(duration))
            ret.percent = utils2.timemarkToSeconds(ret.timemark) / duration * 100;
        }
        command.emit("progress", ret);
      }
    },
    /**
     * Extract error message(s) from ffmpeg stderr
     *
     * @param {String} stderr ffmpeg stderr data
     * @return {String}
     * @private
     */
    extractError: function(stderr) {
      return stderr.split(nlRegexp).reduce(function(messages, message) {
        if (message.charAt(0) === " " || message.charAt(0) === "[") {
          return [];
        } else {
          messages.push(message);
          return messages;
        }
      }, []).join("\n");
    },
    /**
     * Creates a line ring buffer object with the following methods:
     * - append(str) : appends a string or buffer
     * - get() : returns the whole string
     * - close() : prevents further append() calls and does a last call to callbacks
     * - callback(cb) : calls cb for each line (incl. those already in the ring)
     *
     * @param {Number} maxLines maximum number of lines to store (<= 0 for unlimited)
     */
    linesRing: function(maxLines) {
      var cbs = [];
      var lines = [];
      var current = null;
      var closed = false;
      var max2 = maxLines - 1;
      function emit(line2) {
        cbs.forEach(function(cb) {
          cb(line2);
        });
      }
      return {
        callback: function(cb) {
          lines.forEach(function(l) {
            cb(l);
          });
          cbs.push(cb);
        },
        append: function(str) {
          if (closed) return;
          if (str instanceof Buffer) str = "" + str;
          if (!str || str.length === 0) return;
          var newLines = str.split(nlRegexp);
          if (newLines.length === 1) {
            if (current !== null) {
              current = current + newLines.shift();
            } else {
              current = newLines.shift();
            }
          } else {
            if (current !== null) {
              current = current + newLines.shift();
              emit(current);
              lines.push(current);
            }
            current = newLines.pop();
            newLines.forEach(function(l) {
              emit(l);
              lines.push(l);
            });
            if (max2 > -1 && lines.length > max2) {
              lines.splice(0, lines.length - max2);
            }
          }
        },
        get: function() {
          if (current !== null) {
            return lines.concat([current]).join("\n");
          } else {
            return lines.join("\n");
          }
        },
        close: function() {
          if (closed) return;
          if (current !== null) {
            emit(current);
            lines.push(current);
            if (max2 > -1 && lines.length > max2) {
              lines.shift();
            }
            current = null;
          }
          closed = true;
        }
      };
    }
  };
  return utils$3.exports;
}
var inputs;
var hasRequiredInputs;
function requireInputs() {
  if (hasRequiredInputs) return inputs;
  hasRequiredInputs = 1;
  var utils2 = requireUtils$3();
  inputs = function(proto) {
    proto.mergeAdd = proto.addInput = proto.input = function(source2) {
      var isFile = false;
      var isStream = false;
      if (typeof source2 !== "string") {
        if (!("readable" in source2) || !source2.readable) {
          throw new Error("Invalid input");
        }
        var hasInputStream = this._inputs.some(function(input) {
          return input.isStream;
        });
        if (hasInputStream) {
          throw new Error("Only one input stream is supported");
        }
        isStream = true;
        source2.pause();
      } else {
        var protocol = source2.match(/^([a-z]{2,}):/i);
        isFile = !protocol || protocol[0] === "file";
      }
      this._inputs.push(this._currentInput = {
        source: source2,
        isFile,
        isStream,
        options: utils2.args()
      });
      return this;
    };
    proto.withInputFormat = proto.inputFormat = proto.fromFormat = function(format) {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      this._currentInput.options("-f", format);
      return this;
    };
    proto.withInputFps = proto.withInputFPS = proto.withFpsInput = proto.withFPSInput = proto.inputFPS = proto.inputFps = proto.fpsInput = proto.FPSInput = function(fps) {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      this._currentInput.options("-r", fps);
      return this;
    };
    proto.nativeFramerate = proto.withNativeFramerate = proto.native = function() {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      this._currentInput.options("-re");
      return this;
    };
    proto.setStartTime = proto.seekInput = function(seek) {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      this._currentInput.options("-ss", seek);
      return this;
    };
    proto.loop = function(duration) {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      this._currentInput.options("-loop", "1");
      if (typeof duration !== "undefined") {
        this.duration(duration);
      }
      return this;
    };
  };
  return inputs;
}
var audio;
var hasRequiredAudio;
function requireAudio() {
  if (hasRequiredAudio) return audio;
  hasRequiredAudio = 1;
  var utils2 = requireUtils$3();
  audio = function(proto) {
    proto.withNoAudio = proto.noAudio = function() {
      this._currentOutput.audio.clear();
      this._currentOutput.audioFilters.clear();
      this._currentOutput.audio("-an");
      return this;
    };
    proto.withAudioCodec = proto.audioCodec = function(codec) {
      this._currentOutput.audio("-acodec", codec);
      return this;
    };
    proto.withAudioBitrate = proto.audioBitrate = function(bitrate) {
      this._currentOutput.audio("-b:a", ("" + bitrate).replace(/k?$/, "k"));
      return this;
    };
    proto.withAudioChannels = proto.audioChannels = function(channels) {
      this._currentOutput.audio("-ac", channels);
      return this;
    };
    proto.withAudioFrequency = proto.audioFrequency = function(freq) {
      this._currentOutput.audio("-ar", freq);
      return this;
    };
    proto.withAudioQuality = proto.audioQuality = function(quality) {
      this._currentOutput.audio("-aq", quality);
      return this;
    };
    proto.withAudioFilter = proto.withAudioFilters = proto.audioFilter = proto.audioFilters = function(filters) {
      if (arguments.length > 1) {
        filters = [].slice.call(arguments);
      }
      if (!Array.isArray(filters)) {
        filters = [filters];
      }
      this._currentOutput.audioFilters(utils2.makeFilterStrings(filters));
      return this;
    };
  };
  return audio;
}
var video;
var hasRequiredVideo;
function requireVideo() {
  if (hasRequiredVideo) return video;
  hasRequiredVideo = 1;
  var utils2 = requireUtils$3();
  video = function(proto) {
    proto.withNoVideo = proto.noVideo = function() {
      this._currentOutput.video.clear();
      this._currentOutput.videoFilters.clear();
      this._currentOutput.video("-vn");
      return this;
    };
    proto.withVideoCodec = proto.videoCodec = function(codec) {
      this._currentOutput.video("-vcodec", codec);
      return this;
    };
    proto.withVideoBitrate = proto.videoBitrate = function(bitrate, constant) {
      bitrate = ("" + bitrate).replace(/k?$/, "k");
      this._currentOutput.video("-b:v", bitrate);
      if (constant) {
        this._currentOutput.video(
          "-maxrate",
          bitrate,
          "-minrate",
          bitrate,
          "-bufsize",
          "3M"
        );
      }
      return this;
    };
    proto.withVideoFilter = proto.withVideoFilters = proto.videoFilter = proto.videoFilters = function(filters) {
      if (arguments.length > 1) {
        filters = [].slice.call(arguments);
      }
      if (!Array.isArray(filters)) {
        filters = [filters];
      }
      this._currentOutput.videoFilters(utils2.makeFilterStrings(filters));
      return this;
    };
    proto.withOutputFps = proto.withOutputFPS = proto.withFpsOutput = proto.withFPSOutput = proto.withFps = proto.withFPS = proto.outputFPS = proto.outputFps = proto.fpsOutput = proto.FPSOutput = proto.fps = proto.FPS = function(fps) {
      this._currentOutput.video("-r", fps);
      return this;
    };
    proto.takeFrames = proto.withFrames = proto.frames = function(frames) {
      this._currentOutput.video("-vframes", frames);
      return this;
    };
  };
  return video;
}
var videosize;
var hasRequiredVideosize;
function requireVideosize() {
  if (hasRequiredVideosize) return videosize;
  hasRequiredVideosize = 1;
  function getScalePadFilters(width, height, aspect, color) {
    return [
      /*
        In both cases, we first have to scale the input to match the requested size.
        When using computed width/height, we truncate them to multiples of 2
       */
      {
        filter: "scale",
        options: {
          w: "if(gt(a," + aspect + ")," + width + ",trunc(" + height + "*a/2)*2)",
          h: "if(lt(a," + aspect + ")," + height + ",trunc(" + width + "/a/2)*2)"
        }
      },
      /*
        Then we pad the scaled input to match the target size
        (here iw and ih refer to the padding input, i.e the scaled output)
       */
      {
        filter: "pad",
        options: {
          w: width,
          h: height,
          x: "if(gt(a," + aspect + "),0,(" + width + "-iw)/2)",
          y: "if(lt(a," + aspect + "),0,(" + height + "-ih)/2)",
          color
        }
      }
    ];
  }
  function createSizeFilters(output2, key2, value) {
    var data = output2.sizeData = output2.sizeData || {};
    data[key2] = value;
    if (!("size" in data)) {
      return [];
    }
    var fixedSize = data.size.match(/([0-9]+)x([0-9]+)/);
    var fixedWidth = data.size.match(/([0-9]+)x\?/);
    var fixedHeight = data.size.match(/\?x([0-9]+)/);
    var percentRatio = data.size.match(/\b([0-9]{1,3})%/);
    var width, height, aspect;
    if (percentRatio) {
      var ratio = Number(percentRatio[1]) / 100;
      return [{
        filter: "scale",
        options: {
          w: "trunc(iw*" + ratio + "/2)*2",
          h: "trunc(ih*" + ratio + "/2)*2"
        }
      }];
    } else if (fixedSize) {
      width = Math.round(Number(fixedSize[1]) / 2) * 2;
      height = Math.round(Number(fixedSize[2]) / 2) * 2;
      aspect = width / height;
      if (data.pad) {
        return getScalePadFilters(width, height, aspect, data.pad);
      } else {
        return [{ filter: "scale", options: { w: width, h: height } }];
      }
    } else if (fixedWidth || fixedHeight) {
      if ("aspect" in data) {
        width = fixedWidth ? fixedWidth[1] : Math.round(Number(fixedHeight[1]) * data.aspect);
        height = fixedHeight ? fixedHeight[1] : Math.round(Number(fixedWidth[1]) / data.aspect);
        width = Math.round(width / 2) * 2;
        height = Math.round(height / 2) * 2;
        if (data.pad) {
          return getScalePadFilters(width, height, data.aspect, data.pad);
        } else {
          return [{ filter: "scale", options: { w: width, h: height } }];
        }
      } else {
        if (fixedWidth) {
          return [{
            filter: "scale",
            options: {
              w: Math.round(Number(fixedWidth[1]) / 2) * 2,
              h: "trunc(ow/a/2)*2"
            }
          }];
        } else {
          return [{
            filter: "scale",
            options: {
              w: "trunc(oh*a/2)*2",
              h: Math.round(Number(fixedHeight[1]) / 2) * 2
            }
          }];
        }
      }
    } else {
      throw new Error("Invalid size specified: " + data.size);
    }
  }
  videosize = function(proto) {
    proto.keepPixelAspect = // Only for compatibility, this is not about keeping _pixel_ aspect ratio
    proto.keepDisplayAspect = proto.keepDisplayAspectRatio = proto.keepDAR = function() {
      return this.videoFilters([
        {
          filter: "scale",
          options: {
            w: "if(gt(sar,1),iw*sar,iw)",
            h: "if(lt(sar,1),ih/sar,ih)"
          }
        },
        {
          filter: "setsar",
          options: "1"
        }
      ]);
    };
    proto.withSize = proto.setSize = proto.size = function(size) {
      var filters = createSizeFilters(this._currentOutput, "size", size);
      this._currentOutput.sizeFilters.clear();
      this._currentOutput.sizeFilters(filters);
      return this;
    };
    proto.withAspect = proto.withAspectRatio = proto.setAspect = proto.setAspectRatio = proto.aspect = proto.aspectRatio = function(aspect) {
      var a = Number(aspect);
      if (isNaN(a)) {
        var match = aspect.match(/^(\d+):(\d+)$/);
        if (match) {
          a = Number(match[1]) / Number(match[2]);
        } else {
          throw new Error("Invalid aspect ratio: " + aspect);
        }
      }
      var filters = createSizeFilters(this._currentOutput, "aspect", a);
      this._currentOutput.sizeFilters.clear();
      this._currentOutput.sizeFilters(filters);
      return this;
    };
    proto.applyAutopadding = proto.applyAutoPadding = proto.applyAutopad = proto.applyAutoPad = proto.withAutopadding = proto.withAutoPadding = proto.withAutopad = proto.withAutoPad = proto.autoPad = proto.autopad = function(pad, color) {
      if (typeof pad === "string") {
        color = pad;
        pad = true;
      }
      if (typeof pad === "undefined") {
        pad = true;
      }
      var filters = createSizeFilters(this._currentOutput, "pad", pad ? color || "black" : false);
      this._currentOutput.sizeFilters.clear();
      this._currentOutput.sizeFilters(filters);
      return this;
    };
  };
  return videosize;
}
var output;
var hasRequiredOutput;
function requireOutput() {
  if (hasRequiredOutput) return output;
  hasRequiredOutput = 1;
  var utils2 = requireUtils$3();
  output = function(proto) {
    proto.addOutput = proto.output = function(target, pipeopts) {
      var isFile = false;
      if (!target && this._currentOutput) {
        throw new Error("Invalid output");
      }
      if (target && typeof target !== "string") {
        if (!("writable" in target) || !target.writable) {
          throw new Error("Invalid output");
        }
      } else if (typeof target === "string") {
        var protocol = target.match(/^([a-z]{2,}):/i);
        isFile = !protocol || protocol[0] === "file";
      }
      if (target && !("target" in this._currentOutput)) {
        this._currentOutput.target = target;
        this._currentOutput.isFile = isFile;
        this._currentOutput.pipeopts = pipeopts || {};
      } else {
        if (target && typeof target !== "string") {
          var hasOutputStream = this._outputs.some(function(output2) {
            return typeof output2.target !== "string";
          });
          if (hasOutputStream) {
            throw new Error("Only one output stream is supported");
          }
        }
        this._outputs.push(this._currentOutput = {
          target,
          isFile,
          flags: {},
          pipeopts: pipeopts || {}
        });
        var self2 = this;
        ["audio", "audioFilters", "video", "videoFilters", "sizeFilters", "options"].forEach(function(key2) {
          self2._currentOutput[key2] = utils2.args();
        });
        if (!target) {
          delete this._currentOutput.target;
        }
      }
      return this;
    };
    proto.seekOutput = proto.seek = function(seek) {
      this._currentOutput.options("-ss", seek);
      return this;
    };
    proto.withDuration = proto.setDuration = proto.duration = function(duration) {
      this._currentOutput.options("-t", duration);
      return this;
    };
    proto.toFormat = proto.withOutputFormat = proto.outputFormat = proto.format = function(format) {
      this._currentOutput.options("-f", format);
      return this;
    };
    proto.map = function(spec) {
      this._currentOutput.options("-map", spec.replace(utils2.streamRegexp, "[$1]"));
      return this;
    };
    proto.updateFlvMetadata = proto.flvmeta = function() {
      this._currentOutput.flags.flvmeta = true;
      return this;
    };
  };
  return output;
}
var custom;
var hasRequiredCustom;
function requireCustom() {
  if (hasRequiredCustom) return custom;
  hasRequiredCustom = 1;
  var utils2 = requireUtils$3();
  custom = function(proto) {
    proto.addInputOption = proto.addInputOptions = proto.withInputOption = proto.withInputOptions = proto.inputOption = proto.inputOptions = function(options) {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      var doSplit = true;
      if (arguments.length > 1) {
        options = [].slice.call(arguments);
        doSplit = false;
      }
      if (!Array.isArray(options)) {
        options = [options];
      }
      this._currentInput.options(options.reduce(function(options2, option) {
        var split = String(option).split(" ");
        if (doSplit && split.length === 2) {
          options2.push(split[0], split[1]);
        } else {
          options2.push(option);
        }
        return options2;
      }, []));
      return this;
    };
    proto.addOutputOption = proto.addOutputOptions = proto.addOption = proto.addOptions = proto.withOutputOption = proto.withOutputOptions = proto.withOption = proto.withOptions = proto.outputOption = proto.outputOptions = function(options) {
      var doSplit = true;
      if (arguments.length > 1) {
        options = [].slice.call(arguments);
        doSplit = false;
      }
      if (!Array.isArray(options)) {
        options = [options];
      }
      this._currentOutput.options(options.reduce(function(options2, option) {
        var split = String(option).split(" ");
        if (doSplit && split.length === 2) {
          options2.push(split[0], split[1]);
        } else {
          options2.push(option);
        }
        return options2;
      }, []));
      return this;
    };
    proto.filterGraph = proto.complexFilter = function(spec, map) {
      this._complexFilters.clear();
      if (!Array.isArray(spec)) {
        spec = [spec];
      }
      this._complexFilters("-filter_complex", utils2.makeFilterStrings(spec).join(";"));
      if (Array.isArray(map)) {
        var self2 = this;
        map.forEach(function(streamSpec) {
          self2._complexFilters("-map", streamSpec.replace(utils2.streamRegexp, "[$1]"));
        });
      } else if (typeof map === "string") {
        this._complexFilters("-map", map.replace(utils2.streamRegexp, "[$1]"));
      }
      return this;
    };
  };
  return custom;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var misc;
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc) return misc;
  hasRequiredMisc = 1;
  var path2 = require$$1$2;
  misc = function(proto) {
    proto.usingPreset = proto.preset = function(preset) {
      if (typeof preset === "function") {
        preset(this);
      } else {
        try {
          var modulePath = path2.join(this.options.presets, preset);
          var module = commonjsRequire(modulePath);
          if (typeof module.load === "function") {
            module.load(this);
          } else {
            throw new Error("preset " + modulePath + " has no load() function");
          }
        } catch (err) {
          throw new Error("preset " + modulePath + " could not be loaded: " + err.message);
        }
      }
      return this;
    };
  };
  return misc;
}
var async = { exports: {} };
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async.exports;
  hasRequiredAsync = 1;
  (function(module) {
    (function() {
      var async2 = {};
      var root2, previous_async;
      root2 = this;
      if (root2 != null) {
        previous_async = root2.async;
      }
      async2.noConflict = function() {
        root2.async = previous_async;
        return async2;
      };
      function only_once(fn) {
        var called = false;
        return function() {
          if (called) throw new Error("Callback was already called.");
          called = true;
          fn.apply(root2, arguments);
        };
      }
      var _each = function(arr, iterator) {
        if (arr.forEach) {
          return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
          iterator(arr[i], i, arr);
        }
      };
      var _map = function(arr, iterator) {
        if (arr.map) {
          return arr.map(iterator);
        }
        var results = [];
        _each(arr, function(x, i, a) {
          results.push(iterator(x, i, a));
        });
        return results;
      };
      var _reduce = function(arr, iterator, memo) {
        if (arr.reduce) {
          return arr.reduce(iterator, memo);
        }
        _each(arr, function(x, i, a) {
          memo = iterator(memo, x, i, a);
        });
        return memo;
      };
      var _keys = function(obj) {
        if (Object.keys) {
          return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
          if (obj.hasOwnProperty(k)) {
            keys.push(k);
          }
        }
        return keys;
      };
      if (typeof process === "undefined" || !process.nextTick) {
        if (typeof setImmediate === "function") {
          async2.nextTick = function(fn) {
            setImmediate(fn);
          };
          async2.setImmediate = async2.nextTick;
        } else {
          async2.nextTick = function(fn) {
            setTimeout(fn, 0);
          };
          async2.setImmediate = async2.nextTick;
        }
      } else {
        async2.nextTick = process.nextTick;
        if (typeof setImmediate !== "undefined") {
          async2.setImmediate = function(fn) {
            setImmediate(fn);
          };
        } else {
          async2.setImmediate = async2.nextTick;
        }
      }
      async2.each = function(arr, iterator, callback) {
        callback = callback || function() {
        };
        if (!arr.length) {
          return callback();
        }
        var completed = 0;
        _each(arr, function(x) {
          iterator(x, only_once(function(err) {
            if (err) {
              callback(err);
              callback = function() {
              };
            } else {
              completed += 1;
              if (completed >= arr.length) {
                callback(null);
              }
            }
          }));
        });
      };
      async2.forEach = async2.each;
      async2.eachSeries = function(arr, iterator, callback) {
        callback = callback || function() {
        };
        if (!arr.length) {
          return callback();
        }
        var completed = 0;
        var iterate = function() {
          iterator(arr[completed], function(err) {
            if (err) {
              callback(err);
              callback = function() {
              };
            } else {
              completed += 1;
              if (completed >= arr.length) {
                callback(null);
              } else {
                iterate();
              }
            }
          });
        };
        iterate();
      };
      async2.forEachSeries = async2.eachSeries;
      async2.eachLimit = function(arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
      };
      async2.forEachLimit = async2.eachLimit;
      var _eachLimit = function(limit) {
        return function(arr, iterator, callback) {
          callback = callback || function() {
          };
          if (!arr.length || limit <= 0) {
            return callback();
          }
          var completed = 0;
          var started = 0;
          var running = 0;
          (function replenish() {
            if (completed >= arr.length) {
              return callback();
            }
            while (running < limit && started < arr.length) {
              started += 1;
              running += 1;
              iterator(arr[started - 1], function(err) {
                if (err) {
                  callback(err);
                  callback = function() {
                  };
                } else {
                  completed += 1;
                  running -= 1;
                  if (completed >= arr.length) {
                    callback();
                  } else {
                    replenish();
                  }
                }
              });
            }
          })();
        };
      };
      var doParallel = function(fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [async2.each].concat(args));
        };
      };
      var doParallelLimit = function(limit, fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
      };
      var doSeries = function(fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [async2.eachSeries].concat(args));
        };
      };
      var _asyncMap = function(eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function(x, i) {
          return { index: i, value: x };
        });
        eachfn(arr, function(x, callback2) {
          iterator(x.value, function(err, v) {
            results[x.index] = v;
            callback2(err);
          });
        }, function(err) {
          callback(err, results);
        });
      };
      async2.map = doParallel(_asyncMap);
      async2.mapSeries = doSeries(_asyncMap);
      async2.mapLimit = function(arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
      };
      var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
      };
      async2.reduce = function(arr, memo, iterator, callback) {
        async2.eachSeries(arr, function(x, callback2) {
          iterator(memo, x, function(err, v) {
            memo = v;
            callback2(err);
          });
        }, function(err) {
          callback(err, memo);
        });
      };
      async2.inject = async2.reduce;
      async2.foldl = async2.reduce;
      async2.reduceRight = function(arr, memo, iterator, callback) {
        var reversed = _map(arr, function(x) {
          return x;
        }).reverse();
        async2.reduce(reversed, memo, iterator, callback);
      };
      async2.foldr = async2.reduceRight;
      var _filter = function(eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function(x, i) {
          return { index: i, value: x };
        });
        eachfn(arr, function(x, callback2) {
          iterator(x.value, function(v) {
            if (v) {
              results.push(x);
            }
            callback2();
          });
        }, function(err) {
          callback(_map(results.sort(function(a, b) {
            return a.index - b.index;
          }), function(x) {
            return x.value;
          }));
        });
      };
      async2.filter = doParallel(_filter);
      async2.filterSeries = doSeries(_filter);
      async2.select = async2.filter;
      async2.selectSeries = async2.filterSeries;
      var _reject = function(eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function(x, i) {
          return { index: i, value: x };
        });
        eachfn(arr, function(x, callback2) {
          iterator(x.value, function(v) {
            if (!v) {
              results.push(x);
            }
            callback2();
          });
        }, function(err) {
          callback(_map(results.sort(function(a, b) {
            return a.index - b.index;
          }), function(x) {
            return x.value;
          }));
        });
      };
      async2.reject = doParallel(_reject);
      async2.rejectSeries = doSeries(_reject);
      var _detect = function(eachfn, arr, iterator, main_callback) {
        eachfn(arr, function(x, callback) {
          iterator(x, function(result) {
            if (result) {
              main_callback(x);
              main_callback = function() {
              };
            } else {
              callback();
            }
          });
        }, function(err) {
          main_callback();
        });
      };
      async2.detect = doParallel(_detect);
      async2.detectSeries = doSeries(_detect);
      async2.some = function(arr, iterator, main_callback) {
        async2.each(arr, function(x, callback) {
          iterator(x, function(v) {
            if (v) {
              main_callback(true);
              main_callback = function() {
              };
            }
            callback();
          });
        }, function(err) {
          main_callback(false);
        });
      };
      async2.any = async2.some;
      async2.every = function(arr, iterator, main_callback) {
        async2.each(arr, function(x, callback) {
          iterator(x, function(v) {
            if (!v) {
              main_callback(false);
              main_callback = function() {
              };
            }
            callback();
          });
        }, function(err) {
          main_callback(true);
        });
      };
      async2.all = async2.every;
      async2.sortBy = function(arr, iterator, callback) {
        async2.map(arr, function(x, callback2) {
          iterator(x, function(err, criteria) {
            if (err) {
              callback2(err);
            } else {
              callback2(null, { value: x, criteria });
            }
          });
        }, function(err, results) {
          if (err) {
            return callback(err);
          } else {
            var fn = function(left, right) {
              var a = left.criteria, b = right.criteria;
              return a < b ? -1 : a > b ? 1 : 0;
            };
            callback(null, _map(results.sort(fn), function(x) {
              return x.value;
            }));
          }
        });
      };
      async2.auto = function(tasks, callback) {
        callback = callback || function() {
        };
        var keys = _keys(tasks);
        if (!keys.length) {
          return callback(null);
        }
        var results = {};
        var listeners = [];
        var addListener = function(fn) {
          listeners.unshift(fn);
        };
        var removeListener = function(fn) {
          for (var i = 0; i < listeners.length; i += 1) {
            if (listeners[i] === fn) {
              listeners.splice(i, 1);
              return;
            }
          }
        };
        var taskComplete = function() {
          _each(listeners.slice(0), function(fn) {
            fn();
          });
        };
        addListener(function() {
          if (_keys(results).length === keys.length) {
            callback(null, results);
            callback = function() {
            };
          }
        });
        _each(keys, function(k) {
          var task = tasks[k] instanceof Function ? [tasks[k]] : tasks[k];
          var taskCallback = function(err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            if (err) {
              var safeResults = {};
              _each(_keys(results), function(rkey) {
                safeResults[rkey] = results[rkey];
              });
              safeResults[k] = args;
              callback(err, safeResults);
              callback = function() {
              };
            } else {
              results[k] = args;
              async2.setImmediate(taskComplete);
            }
          };
          var requires = task.slice(0, Math.abs(task.length - 1)) || [];
          var ready = function() {
            return _reduce(requires, function(a, x) {
              return a && results.hasOwnProperty(x);
            }, true) && !results.hasOwnProperty(k);
          };
          if (ready()) {
            task[task.length - 1](taskCallback, results);
          } else {
            var listener = function() {
              if (ready()) {
                removeListener(listener);
                task[task.length - 1](taskCallback, results);
              }
            };
            addListener(listener);
          }
        });
      };
      async2.waterfall = function(tasks, callback) {
        callback = callback || function() {
        };
        if (tasks.constructor !== Array) {
          var err = new Error("First argument to waterfall must be an array of functions");
          return callback(err);
        }
        if (!tasks.length) {
          return callback();
        }
        var wrapIterator = function(iterator) {
          return function(err2) {
            if (err2) {
              callback.apply(null, arguments);
              callback = function() {
              };
            } else {
              var args = Array.prototype.slice.call(arguments, 1);
              var next = iterator.next();
              if (next) {
                args.push(wrapIterator(next));
              } else {
                args.push(callback);
              }
              async2.setImmediate(function() {
                iterator.apply(null, args);
              });
            }
          };
        };
        wrapIterator(async2.iterator(tasks))();
      };
      var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function() {
        };
        if (tasks.constructor === Array) {
          eachfn.map(tasks, function(fn, callback2) {
            if (fn) {
              fn(function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                  args = args[0];
                }
                callback2.call(null, err, args);
              });
            }
          }, callback);
        } else {
          var results = {};
          eachfn.each(_keys(tasks), function(k, callback2) {
            tasks[k](function(err) {
              var args = Array.prototype.slice.call(arguments, 1);
              if (args.length <= 1) {
                args = args[0];
              }
              results[k] = args;
              callback2(err);
            });
          }, function(err) {
            callback(err, results);
          });
        }
      };
      async2.parallel = function(tasks, callback) {
        _parallel({ map: async2.map, each: async2.each }, tasks, callback);
      };
      async2.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
      };
      async2.series = function(tasks, callback) {
        callback = callback || function() {
        };
        if (tasks.constructor === Array) {
          async2.mapSeries(tasks, function(fn, callback2) {
            if (fn) {
              fn(function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                  args = args[0];
                }
                callback2.call(null, err, args);
              });
            }
          }, callback);
        } else {
          var results = {};
          async2.eachSeries(_keys(tasks), function(k, callback2) {
            tasks[k](function(err) {
              var args = Array.prototype.slice.call(arguments, 1);
              if (args.length <= 1) {
                args = args[0];
              }
              results[k] = args;
              callback2(err);
            });
          }, function(err) {
            callback(err, results);
          });
        }
      };
      async2.iterator = function(tasks) {
        var makeCallback = function(index) {
          var fn = function() {
            if (tasks.length) {
              tasks[index].apply(null, arguments);
            }
            return fn.next();
          };
          fn.next = function() {
            return index < tasks.length - 1 ? makeCallback(index + 1) : null;
          };
          return fn;
        };
        return makeCallback(0);
      };
      async2.apply = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
          return fn.apply(
            null,
            args.concat(Array.prototype.slice.call(arguments))
          );
        };
      };
      var _concat = function(eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function(x, cb) {
          fn(x, function(err, y) {
            r = r.concat(y || []);
            cb(err);
          });
        }, function(err) {
          callback(err, r);
        });
      };
      async2.concat = doParallel(_concat);
      async2.concatSeries = doSeries(_concat);
      async2.whilst = function(test, iterator, callback) {
        if (test()) {
          iterator(function(err) {
            if (err) {
              return callback(err);
            }
            async2.whilst(test, iterator, callback);
          });
        } else {
          callback();
        }
      };
      async2.doWhilst = function(iterator, test, callback) {
        iterator(function(err) {
          if (err) {
            return callback(err);
          }
          if (test()) {
            async2.doWhilst(iterator, test, callback);
          } else {
            callback();
          }
        });
      };
      async2.until = function(test, iterator, callback) {
        if (!test()) {
          iterator(function(err) {
            if (err) {
              return callback(err);
            }
            async2.until(test, iterator, callback);
          });
        } else {
          callback();
        }
      };
      async2.doUntil = function(iterator, test, callback) {
        iterator(function(err) {
          if (err) {
            return callback(err);
          }
          if (!test()) {
            async2.doUntil(iterator, test, callback);
          } else {
            callback();
          }
        });
      };
      async2.queue = function(worker, concurrency2) {
        if (concurrency2 === void 0) {
          concurrency2 = 1;
        }
        function _insert(q2, data, pos2, callback) {
          if (data.constructor !== Array) {
            data = [data];
          }
          _each(data, function(task) {
            var item = {
              data: task,
              callback: typeof callback === "function" ? callback : null
            };
            if (pos2) {
              q2.tasks.unshift(item);
            } else {
              q2.tasks.push(item);
            }
            if (q2.saturated && q2.tasks.length === concurrency2) {
              q2.saturated();
            }
            async2.setImmediate(q2.process);
          });
        }
        var workers = 0;
        var q = {
          tasks: [],
          concurrency: concurrency2,
          saturated: null,
          empty: null,
          drain: null,
          push: function(data, callback) {
            _insert(q, data, false, callback);
          },
          unshift: function(data, callback) {
            _insert(q, data, true, callback);
          },
          process: function() {
            if (workers < q.concurrency && q.tasks.length) {
              var task = q.tasks.shift();
              if (q.empty && q.tasks.length === 0) {
                q.empty();
              }
              workers += 1;
              var next = function() {
                workers -= 1;
                if (task.callback) {
                  task.callback.apply(task, arguments);
                }
                if (q.drain && q.tasks.length + workers === 0) {
                  q.drain();
                }
                q.process();
              };
              var cb = only_once(next);
              worker(task.data, cb);
            }
          },
          length: function() {
            return q.tasks.length;
          },
          running: function() {
            return workers;
          }
        };
        return q;
      };
      async2.cargo = function(worker, payload) {
        var working = false, tasks = [];
        var cargo = {
          tasks,
          payload,
          saturated: null,
          empty: null,
          drain: null,
          push: function(data, callback) {
            if (data.constructor !== Array) {
              data = [data];
            }
            _each(data, function(task) {
              tasks.push({
                data: task,
                callback: typeof callback === "function" ? callback : null
              });
              if (cargo.saturated && tasks.length === payload) {
                cargo.saturated();
              }
            });
            async2.setImmediate(cargo.process);
          },
          process: function process2() {
            if (working) return;
            if (tasks.length === 0) {
              if (cargo.drain) cargo.drain();
              return;
            }
            var ts = typeof payload === "number" ? tasks.splice(0, payload) : tasks.splice(0);
            var ds = _map(ts, function(task) {
              return task.data;
            });
            if (cargo.empty) cargo.empty();
            working = true;
            worker(ds, function() {
              working = false;
              var args = arguments;
              _each(ts, function(data) {
                if (data.callback) {
                  data.callback.apply(null, args);
                }
              });
              process2();
            });
          },
          length: function() {
            return tasks.length;
          },
          running: function() {
            return working;
          }
        };
        return cargo;
      };
      var _console_fn = function(name) {
        return function(fn) {
          var args = Array.prototype.slice.call(arguments, 1);
          fn.apply(null, args.concat([function(err) {
            var args2 = Array.prototype.slice.call(arguments, 1);
            if (typeof console !== "undefined") {
              if (err) {
                if (console.error) {
                  console.error(err);
                }
              } else if (console[name]) {
                _each(args2, function(x) {
                  console[name](x);
                });
              }
            }
          }]));
        };
      };
      async2.log = _console_fn("log");
      async2.dir = _console_fn("dir");
      async2.memoize = function(fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function(x) {
          return x;
        };
        var memoized = function() {
          var args = Array.prototype.slice.call(arguments);
          var callback = args.pop();
          var key2 = hasher.apply(null, args);
          if (key2 in memo) {
            callback.apply(null, memo[key2]);
          } else if (key2 in queues) {
            queues[key2].push(callback);
          } else {
            queues[key2] = [callback];
            fn.apply(null, args.concat([function() {
              memo[key2] = arguments;
              var q = queues[key2];
              delete queues[key2];
              for (var i = 0, l = q.length; i < l; i++) {
                q[i].apply(null, arguments);
              }
            }]));
          }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      };
      async2.unmemoize = function(fn) {
        return function() {
          return (fn.unmemoized || fn).apply(null, arguments);
        };
      };
      async2.times = function(count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
          counter.push(i);
        }
        return async2.map(counter, iterator, callback);
      };
      async2.timesSeries = function(count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
          counter.push(i);
        }
        return async2.mapSeries(counter, iterator, callback);
      };
      async2.compose = function() {
        var fns = Array.prototype.reverse.call(arguments);
        return function() {
          var that = this;
          var args = Array.prototype.slice.call(arguments);
          var callback = args.pop();
          async2.reduce(
            fns,
            args,
            function(newargs, fn, cb) {
              fn.apply(that, newargs.concat([function() {
                var err = arguments[0];
                var nextargs = Array.prototype.slice.call(arguments, 1);
                cb(err, nextargs);
              }]));
            },
            function(err, results) {
              callback.apply(that, [err].concat(results));
            }
          );
        };
      };
      var _applyEach = function(eachfn, fns) {
        var go = function() {
          var that = this;
          var args2 = Array.prototype.slice.call(arguments);
          var callback = args2.pop();
          return eachfn(
            fns,
            function(fn, cb) {
              fn.apply(that, args2.concat([cb]));
            },
            callback
          );
        };
        if (arguments.length > 2) {
          var args = Array.prototype.slice.call(arguments, 2);
          return go.apply(this, args);
        } else {
          return go;
        }
      };
      async2.applyEach = doParallel(_applyEach);
      async2.applyEachSeries = doSeries(_applyEach);
      async2.forever = function(fn, callback) {
        function next(err) {
          if (err) {
            if (callback) {
              return callback(err);
            }
            throw err;
          }
          fn(next);
        }
        next();
      };
      if (module.exports) {
        module.exports = async2;
      } else {
        root2.async = async2;
      }
    })();
  })(async);
  return async.exports;
}
var processor;
var hasRequiredProcessor;
function requireProcessor() {
  if (hasRequiredProcessor) return processor;
  hasRequiredProcessor = 1;
  var spawn = require$$0$6.spawn;
  var async2 = requireAsync();
  var utils2 = requireUtils$3();
  function runFfprobe(command) {
    const inputProbeIndex = 0;
    if (command._inputs[inputProbeIndex].isStream) {
      return;
    }
    command.ffprobe(inputProbeIndex, function(err, data) {
      command._ffprobeData = data;
    });
  }
  processor = function(proto) {
    proto._spawnFfmpeg = function(args, options, processCB, endCB) {
      if (typeof options === "function") {
        endCB = processCB;
        processCB = options;
        options = {};
      }
      if (typeof endCB === "undefined") {
        endCB = processCB;
        processCB = function() {
        };
      }
      var maxLines = "stdoutLines" in options ? options.stdoutLines : this.options.stdoutLines;
      this._getFfmpegPath(function(err, command) {
        if (err) {
          return endCB(err);
        } else if (!command || command.length === 0) {
          return endCB(new Error("Cannot find ffmpeg"));
        }
        if (options.niceness && options.niceness !== 0 && !utils2.isWindows) {
          args.unshift("-n", options.niceness, command);
          command = "nice";
        }
        var stdoutRing = utils2.linesRing(maxLines);
        var stdoutClosed = false;
        var stderrRing = utils2.linesRing(maxLines);
        var stderrClosed = false;
        var ffmpegProc = spawn(command, args, options);
        if (ffmpegProc.stderr) {
          ffmpegProc.stderr.setEncoding("utf8");
        }
        ffmpegProc.on("error", function(err2) {
          endCB(err2);
        });
        var exitError = null;
        function handleExit(err2) {
          if (err2) {
            exitError = err2;
          }
          if (processExited && (stdoutClosed || !options.captureStdout) && stderrClosed) {
            endCB(exitError, stdoutRing, stderrRing);
          }
        }
        var processExited = false;
        ffmpegProc.on("exit", function(code, signal) {
          processExited = true;
          if (signal) {
            handleExit(new Error("ffmpeg was killed with signal " + signal));
          } else if (code) {
            handleExit(new Error("ffmpeg exited with code " + code));
          } else {
            handleExit();
          }
        });
        if (options.captureStdout) {
          ffmpegProc.stdout.on("data", function(data) {
            stdoutRing.append(data);
          });
          ffmpegProc.stdout.on("close", function() {
            stdoutRing.close();
            stdoutClosed = true;
            handleExit();
          });
        }
        ffmpegProc.stderr.on("data", function(data) {
          stderrRing.append(data);
        });
        ffmpegProc.stderr.on("close", function() {
          stderrRing.close();
          stderrClosed = true;
          handleExit();
        });
        processCB(ffmpegProc, stdoutRing, stderrRing);
      });
    };
    proto._getArguments = function() {
      var complexFilters = this._complexFilters.get();
      var fileOutput = this._outputs.some(function(output2) {
        return output2.isFile;
      });
      return [].concat(
        // Inputs and input options
        this._inputs.reduce(function(args, input) {
          var source2 = typeof input.source === "string" ? input.source : "pipe:0";
          return args.concat(
            input.options.get(),
            ["-i", source2]
          );
        }, []),
        // Global options
        this._global.get(),
        // Overwrite if we have file outputs
        fileOutput ? ["-y"] : [],
        // Complex filters
        complexFilters,
        // Outputs, filters and output options
        this._outputs.reduce(function(args, output2) {
          var sizeFilters = utils2.makeFilterStrings(output2.sizeFilters.get());
          var audioFilters = output2.audioFilters.get();
          var videoFilters = output2.videoFilters.get().concat(sizeFilters);
          var outputArg;
          if (!output2.target) {
            outputArg = [];
          } else if (typeof output2.target === "string") {
            outputArg = [output2.target];
          } else {
            outputArg = ["pipe:1"];
          }
          return args.concat(
            output2.audio.get(),
            audioFilters.length ? ["-filter:a", audioFilters.join(",")] : [],
            output2.video.get(),
            videoFilters.length ? ["-filter:v", videoFilters.join(",")] : [],
            output2.options.get(),
            outputArg
          );
        }, [])
      );
    };
    proto._prepare = function(callback, readMetadata) {
      var self2 = this;
      async2.waterfall([
        // Check codecs and formats
        function(cb) {
          self2._checkCapabilities(cb);
        },
        // Read metadata if required
        function(cb) {
          if (!readMetadata) {
            return cb();
          }
          self2.ffprobe(0, function(err, data) {
            if (!err) {
              self2._ffprobeData = data;
            }
            cb();
          });
        },
        // Check for flvtool2/flvmeta if necessary
        function(cb) {
          var flvmeta = self2._outputs.some(function(output2) {
            if (output2.flags.flvmeta && !output2.isFile) {
              self2.logger.warn("Updating flv metadata is only supported for files");
              output2.flags.flvmeta = false;
            }
            return output2.flags.flvmeta;
          });
          if (flvmeta) {
            self2._getFlvtoolPath(function(err) {
              cb(err);
            });
          } else {
            cb();
          }
        },
        // Build argument list
        function(cb) {
          var args;
          try {
            args = self2._getArguments();
          } catch (e) {
            return cb(e);
          }
          cb(null, args);
        },
        // Add "-strict experimental" option where needed
        function(args, cb) {
          self2.availableEncoders(function(err, encoders) {
            for (var i = 0; i < args.length; i++) {
              if (args[i] === "-acodec" || args[i] === "-vcodec") {
                i++;
                if (args[i] in encoders && encoders[args[i]].experimental) {
                  args.splice(i + 1, 0, "-strict", "experimental");
                  i += 2;
                }
              }
            }
            cb(null, args);
          });
        }
      ], callback);
      if (!readMetadata) {
        if (this.listeners("progress").length > 0) {
          runFfprobe(this);
        } else {
          this.once("newListener", function(event) {
            if (event === "progress") {
              runFfprobe(this);
            }
          });
        }
      }
    };
    proto.exec = proto.execute = proto.run = function() {
      var self2 = this;
      var outputPresent = this._outputs.some(function(output2) {
        return "target" in output2;
      });
      if (!outputPresent) {
        throw new Error("No output specified");
      }
      var outputStream = this._outputs.filter(function(output2) {
        return typeof output2.target !== "string";
      })[0];
      var inputStream = this._inputs.filter(function(input) {
        return typeof input.source !== "string";
      })[0];
      var ended = false;
      function emitEnd(err, stdout, stderr) {
        if (!ended) {
          ended = true;
          if (err) {
            self2.emit("error", err, stdout, stderr);
          } else {
            self2.emit("end", stdout, stderr);
          }
        }
      }
      self2._prepare(function(err, args) {
        if (err) {
          return emitEnd(err);
        }
        self2._spawnFfmpeg(
          args,
          {
            captureStdout: !outputStream,
            niceness: self2.options.niceness,
            cwd: self2.options.cwd,
            windowsHide: true
          },
          function processCB(ffmpegProc, stdoutRing, stderrRing) {
            self2.ffmpegProc = ffmpegProc;
            self2.emit("start", "ffmpeg " + args.join(" "));
            if (inputStream) {
              inputStream.source.on("error", function(err2) {
                var reportingErr = new Error("Input stream error: " + err2.message);
                reportingErr.inputStreamError = err2;
                emitEnd(reportingErr);
                ffmpegProc.kill();
              });
              inputStream.source.resume();
              inputStream.source.pipe(ffmpegProc.stdin);
              ffmpegProc.stdin.on("error", function() {
              });
            }
            if (self2.options.timeout) {
              self2.processTimer = setTimeout(function() {
                var msg = "process ran into a timeout (" + self2.options.timeout + "s)";
                emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());
                ffmpegProc.kill();
              }, self2.options.timeout * 1e3);
            }
            if (outputStream) {
              ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);
              outputStream.target.on("close", function() {
                self2.logger.debug("Output stream closed, scheduling kill for ffmpeg process");
                setTimeout(function() {
                  emitEnd(new Error("Output stream closed"));
                  ffmpegProc.kill();
                }, 20);
              });
              outputStream.target.on("error", function(err2) {
                self2.logger.debug("Output stream error, killing ffmpeg process");
                var reportingErr = new Error("Output stream error: " + err2.message);
                reportingErr.outputStreamError = err2;
                emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());
                ffmpegProc.kill("SIGKILL");
              });
            }
            if (stderrRing) {
              if (self2.listeners("stderr").length) {
                stderrRing.callback(function(line2) {
                  self2.emit("stderr", line2);
                });
              }
              if (self2.listeners("codecData").length) {
                var codecDataSent = false;
                var codecObject = {};
                stderrRing.callback(function(line2) {
                  if (!codecDataSent)
                    codecDataSent = utils2.extractCodecData(self2, line2, codecObject);
                });
              }
              if (self2.listeners("progress").length) {
                stderrRing.callback(function(line2) {
                  utils2.extractProgress(self2, line2);
                });
              }
            }
          },
          function endCB(err2, stdoutRing, stderrRing) {
            clearTimeout(self2.processTimer);
            delete self2.ffmpegProc;
            if (err2) {
              if (err2.message.match(/ffmpeg exited with code/)) {
                err2.message += ": " + utils2.extractError(stderrRing.get());
              }
              emitEnd(err2, stdoutRing.get(), stderrRing.get());
            } else {
              var flvmeta = self2._outputs.filter(function(output2) {
                return output2.flags.flvmeta;
              });
              if (flvmeta.length) {
                self2._getFlvtoolPath(function(err3, flvtool) {
                  if (err3) {
                    return emitEnd(err3);
                  }
                  async2.each(
                    flvmeta,
                    function(output2, cb) {
                      spawn(flvtool, ["-U", output2.target], { windowsHide: true }).on("error", function(err4) {
                        cb(new Error("Error running " + flvtool + " on " + output2.target + ": " + err4.message));
                      }).on("exit", function(code, signal) {
                        if (code !== 0 || signal) {
                          cb(
                            new Error(flvtool + " " + (signal ? "received signal " + signal : "exited with code " + code)) + " when running on " + output2.target
                          );
                        } else {
                          cb();
                        }
                      });
                    },
                    function(err4) {
                      if (err4) {
                        emitEnd(err4);
                      } else {
                        emitEnd(null, stdoutRing.get(), stderrRing.get());
                      }
                    }
                  );
                });
              } else {
                emitEnd(null, stdoutRing.get(), stderrRing.get());
              }
            }
          }
        );
      });
      return this;
    };
    proto.renice = function(niceness) {
      if (!utils2.isWindows) {
        niceness = niceness || 0;
        if (niceness < -20 || niceness > 20) {
          this.logger.warn("Invalid niceness value: " + niceness + ", must be between -20 and 20");
        }
        niceness = Math.min(20, Math.max(-20, niceness));
        this.options.niceness = niceness;
        if (this.ffmpegProc) {
          var logger = this.logger;
          var pid = this.ffmpegProc.pid;
          var renice = spawn("renice", [niceness, "-p", pid], { windowsHide: true });
          renice.on("error", function(err) {
            logger.warn("could not renice process " + pid + ": " + err.message);
          });
          renice.on("exit", function(code, signal) {
            if (signal) {
              logger.warn("could not renice process " + pid + ": renice was killed by signal " + signal);
            } else if (code) {
              logger.warn("could not renice process " + pid + ": renice exited with " + code);
            } else {
              logger.info("successfully reniced process " + pid + " to " + niceness + " niceness");
            }
          });
        }
      }
      return this;
    };
    proto.kill = function(signal) {
      if (!this.ffmpegProc) {
        this.logger.warn("No running ffmpeg process, cannot send signal");
      } else {
        this.ffmpegProc.kill(signal || "SIGKILL");
      }
      return this;
    };
  };
  return processor;
}
var capabilities;
var hasRequiredCapabilities;
function requireCapabilities() {
  if (hasRequiredCapabilities) return capabilities;
  hasRequiredCapabilities = 1;
  var fs2 = fs$1;
  var path2 = require$$1$2;
  var async2 = requireAsync();
  var utils2 = requireUtils$3();
  var avCodecRegexp = /^\s*([D ])([E ])([VAS])([S ])([D ])([T ]) ([^ ]+) +(.*)$/;
  var ffCodecRegexp = /^\s*([D\.])([E\.])([VAS])([I\.])([L\.])([S\.]) ([^ ]+) +(.*)$/;
  var ffEncodersRegexp = /\(encoders:([^\)]+)\)/;
  var ffDecodersRegexp = /\(decoders:([^\)]+)\)/;
  var encodersRegexp = /^\s*([VAS\.])([F\.])([S\.])([X\.])([B\.])([D\.]) ([^ ]+) +(.*)$/;
  var formatRegexp = /^\s*([D ])([E ])\s+([^ ]+)\s+(.*)$/;
  var lineBreakRegexp = /\r\n|\r|\n/;
  var filterRegexp = /^(?: [T\.][S\.][C\.] )?([^ ]+) +(AA?|VV?|\|)->(AA?|VV?|\|) +(.*)$/;
  var cache = {};
  capabilities = function(proto) {
    proto.setFfmpegPath = function(ffmpegPath) {
      cache.ffmpegPath = ffmpegPath;
      return this;
    };
    proto.setFfprobePath = function(ffprobePath) {
      cache.ffprobePath = ffprobePath;
      return this;
    };
    proto.setFlvtoolPath = function(flvtool) {
      cache.flvtoolPath = flvtool;
      return this;
    };
    proto._forgetPaths = function() {
      delete cache.ffmpegPath;
      delete cache.ffprobePath;
      delete cache.flvtoolPath;
    };
    proto._getFfmpegPath = function(callback) {
      if ("ffmpegPath" in cache) {
        return callback(null, cache.ffmpegPath);
      }
      async2.waterfall([
        // Try FFMPEG_PATH
        function(cb) {
          if (process.env.FFMPEG_PATH) {
            fs2.exists(process.env.FFMPEG_PATH, function(exists) {
              if (exists) {
                cb(null, process.env.FFMPEG_PATH);
              } else {
                cb(null, "");
              }
            });
          } else {
            cb(null, "");
          }
        },
        // Search in the PATH
        function(ffmpeg2, cb) {
          if (ffmpeg2.length) {
            return cb(null, ffmpeg2);
          }
          utils2.which("ffmpeg", function(err, ffmpeg22) {
            cb(err, ffmpeg22);
          });
        }
      ], function(err, ffmpeg2) {
        if (err) {
          callback(err);
        } else {
          callback(null, cache.ffmpegPath = ffmpeg2 || "");
        }
      });
    };
    proto._getFfprobePath = function(callback) {
      var self2 = this;
      if ("ffprobePath" in cache) {
        return callback(null, cache.ffprobePath);
      }
      async2.waterfall([
        // Try FFPROBE_PATH
        function(cb) {
          if (process.env.FFPROBE_PATH) {
            fs2.exists(process.env.FFPROBE_PATH, function(exists) {
              cb(null, exists ? process.env.FFPROBE_PATH : "");
            });
          } else {
            cb(null, "");
          }
        },
        // Search in the PATH
        function(ffprobe2, cb) {
          if (ffprobe2.length) {
            return cb(null, ffprobe2);
          }
          utils2.which("ffprobe", function(err, ffprobe22) {
            cb(err, ffprobe22);
          });
        },
        // Search in the same directory as ffmpeg
        function(ffprobe2, cb) {
          if (ffprobe2.length) {
            return cb(null, ffprobe2);
          }
          self2._getFfmpegPath(function(err, ffmpeg2) {
            if (err) {
              cb(err);
            } else if (ffmpeg2.length) {
              var name = utils2.isWindows ? "ffprobe.exe" : "ffprobe";
              var ffprobe22 = path2.join(path2.dirname(ffmpeg2), name);
              fs2.exists(ffprobe22, function(exists) {
                cb(null, exists ? ffprobe22 : "");
              });
            } else {
              cb(null, "");
            }
          });
        }
      ], function(err, ffprobe2) {
        if (err) {
          callback(err);
        } else {
          callback(null, cache.ffprobePath = ffprobe2 || "");
        }
      });
    };
    proto._getFlvtoolPath = function(callback) {
      if ("flvtoolPath" in cache) {
        return callback(null, cache.flvtoolPath);
      }
      async2.waterfall([
        // Try FLVMETA_PATH
        function(cb) {
          if (process.env.FLVMETA_PATH) {
            fs2.exists(process.env.FLVMETA_PATH, function(exists) {
              cb(null, exists ? process.env.FLVMETA_PATH : "");
            });
          } else {
            cb(null, "");
          }
        },
        // Try FLVTOOL2_PATH
        function(flvtool, cb) {
          if (flvtool.length) {
            return cb(null, flvtool);
          }
          if (process.env.FLVTOOL2_PATH) {
            fs2.exists(process.env.FLVTOOL2_PATH, function(exists) {
              cb(null, exists ? process.env.FLVTOOL2_PATH : "");
            });
          } else {
            cb(null, "");
          }
        },
        // Search for flvmeta in the PATH
        function(flvtool, cb) {
          if (flvtool.length) {
            return cb(null, flvtool);
          }
          utils2.which("flvmeta", function(err, flvmeta) {
            cb(err, flvmeta);
          });
        },
        // Search for flvtool2 in the PATH
        function(flvtool, cb) {
          if (flvtool.length) {
            return cb(null, flvtool);
          }
          utils2.which("flvtool2", function(err, flvtool2) {
            cb(err, flvtool2);
          });
        }
      ], function(err, flvtool) {
        if (err) {
          callback(err);
        } else {
          callback(null, cache.flvtoolPath = flvtool || "");
        }
      });
    };
    proto.availableFilters = proto.getAvailableFilters = function(callback) {
      if ("filters" in cache) {
        return callback(null, cache.filters);
      }
      this._spawnFfmpeg(["-filters"], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
        if (err) {
          return callback(err);
        }
        var stdout = stdoutRing.get();
        var lines = stdout.split("\n");
        var data = {};
        var types2 = { A: "audio", V: "video", "|": "none" };
        lines.forEach(function(line2) {
          var match = line2.match(filterRegexp);
          if (match) {
            data[match[1]] = {
              description: match[4],
              input: types2[match[2].charAt(0)],
              multipleInputs: match[2].length > 1,
              output: types2[match[3].charAt(0)],
              multipleOutputs: match[3].length > 1
            };
          }
        });
        callback(null, cache.filters = data);
      });
    };
    proto.availableCodecs = proto.getAvailableCodecs = function(callback) {
      if ("codecs" in cache) {
        return callback(null, cache.codecs);
      }
      this._spawnFfmpeg(["-codecs"], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
        if (err) {
          return callback(err);
        }
        var stdout = stdoutRing.get();
        var lines = stdout.split(lineBreakRegexp);
        var data = {};
        lines.forEach(function(line2) {
          var match = line2.match(avCodecRegexp);
          if (match && match[7] !== "=") {
            data[match[7]] = {
              type: { "V": "video", "A": "audio", "S": "subtitle" }[match[3]],
              description: match[8],
              canDecode: match[1] === "D",
              canEncode: match[2] === "E",
              drawHorizBand: match[4] === "S",
              directRendering: match[5] === "D",
              weirdFrameTruncation: match[6] === "T"
            };
          }
          match = line2.match(ffCodecRegexp);
          if (match && match[7] !== "=") {
            var codecData = data[match[7]] = {
              type: { "V": "video", "A": "audio", "S": "subtitle" }[match[3]],
              description: match[8],
              canDecode: match[1] === "D",
              canEncode: match[2] === "E",
              intraFrameOnly: match[4] === "I",
              isLossy: match[5] === "L",
              isLossless: match[6] === "S"
            };
            var encoders = codecData.description.match(ffEncodersRegexp);
            encoders = encoders ? encoders[1].trim().split(" ") : [];
            var decoders = codecData.description.match(ffDecodersRegexp);
            decoders = decoders ? decoders[1].trim().split(" ") : [];
            if (encoders.length || decoders.length) {
              var coderData = {};
              utils2.copy(codecData, coderData);
              delete coderData.canEncode;
              delete coderData.canDecode;
              encoders.forEach(function(name) {
                data[name] = {};
                utils2.copy(coderData, data[name]);
                data[name].canEncode = true;
              });
              decoders.forEach(function(name) {
                if (name in data) {
                  data[name].canDecode = true;
                } else {
                  data[name] = {};
                  utils2.copy(coderData, data[name]);
                  data[name].canDecode = true;
                }
              });
            }
          }
        });
        callback(null, cache.codecs = data);
      });
    };
    proto.availableEncoders = proto.getAvailableEncoders = function(callback) {
      if ("encoders" in cache) {
        return callback(null, cache.encoders);
      }
      this._spawnFfmpeg(["-encoders"], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
        if (err) {
          return callback(err);
        }
        var stdout = stdoutRing.get();
        var lines = stdout.split(lineBreakRegexp);
        var data = {};
        lines.forEach(function(line2) {
          var match = line2.match(encodersRegexp);
          if (match && match[7] !== "=") {
            data[match[7]] = {
              type: { "V": "video", "A": "audio", "S": "subtitle" }[match[1]],
              description: match[8],
              frameMT: match[2] === "F",
              sliceMT: match[3] === "S",
              experimental: match[4] === "X",
              drawHorizBand: match[5] === "B",
              directRendering: match[6] === "D"
            };
          }
        });
        callback(null, cache.encoders = data);
      });
    };
    proto.availableFormats = proto.getAvailableFormats = function(callback) {
      if ("formats" in cache) {
        return callback(null, cache.formats);
      }
      this._spawnFfmpeg(["-formats"], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
        if (err) {
          return callback(err);
        }
        var stdout = stdoutRing.get();
        var lines = stdout.split(lineBreakRegexp);
        var data = {};
        lines.forEach(function(line2) {
          var match = line2.match(formatRegexp);
          if (match) {
            match[3].split(",").forEach(function(format) {
              if (!(format in data)) {
                data[format] = {
                  description: match[4],
                  canDemux: false,
                  canMux: false
                };
              }
              if (match[1] === "D") {
                data[format].canDemux = true;
              }
              if (match[2] === "E") {
                data[format].canMux = true;
              }
            });
          }
        });
        callback(null, cache.formats = data);
      });
    };
    proto._checkCapabilities = function(callback) {
      var self2 = this;
      async2.waterfall([
        // Get available formats
        function(cb) {
          self2.availableFormats(cb);
        },
        // Check whether specified formats are available
        function(formats2, cb) {
          var unavailable;
          unavailable = self2._outputs.reduce(function(fmts, output2) {
            var format = output2.options.find("-f", 1);
            if (format) {
              if (!(format[0] in formats2) || !formats2[format[0]].canMux) {
                fmts.push(format);
              }
            }
            return fmts;
          }, []);
          if (unavailable.length === 1) {
            return cb(new Error("Output format " + unavailable[0] + " is not available"));
          } else if (unavailable.length > 1) {
            return cb(new Error("Output formats " + unavailable.join(", ") + " are not available"));
          }
          unavailable = self2._inputs.reduce(function(fmts, input) {
            var format = input.options.find("-f", 1);
            if (format) {
              if (!(format[0] in formats2) || !formats2[format[0]].canDemux) {
                fmts.push(format[0]);
              }
            }
            return fmts;
          }, []);
          if (unavailable.length === 1) {
            return cb(new Error("Input format " + unavailable[0] + " is not available"));
          } else if (unavailable.length > 1) {
            return cb(new Error("Input formats " + unavailable.join(", ") + " are not available"));
          }
          cb();
        },
        // Get available codecs
        function(cb) {
          self2.availableEncoders(cb);
        },
        // Check whether specified codecs are available and add strict experimental options if needed
        function(encoders, cb) {
          var unavailable;
          unavailable = self2._outputs.reduce(function(cdcs, output2) {
            var acodec = output2.audio.find("-acodec", 1);
            if (acodec && acodec[0] !== "copy") {
              if (!(acodec[0] in encoders) || encoders[acodec[0]].type !== "audio") {
                cdcs.push(acodec[0]);
              }
            }
            return cdcs;
          }, []);
          if (unavailable.length === 1) {
            return cb(new Error("Audio codec " + unavailable[0] + " is not available"));
          } else if (unavailable.length > 1) {
            return cb(new Error("Audio codecs " + unavailable.join(", ") + " are not available"));
          }
          unavailable = self2._outputs.reduce(function(cdcs, output2) {
            var vcodec = output2.video.find("-vcodec", 1);
            if (vcodec && vcodec[0] !== "copy") {
              if (!(vcodec[0] in encoders) || encoders[vcodec[0]].type !== "video") {
                cdcs.push(vcodec[0]);
              }
            }
            return cdcs;
          }, []);
          if (unavailable.length === 1) {
            return cb(new Error("Video codec " + unavailable[0] + " is not available"));
          } else if (unavailable.length > 1) {
            return cb(new Error("Video codecs " + unavailable.join(", ") + " are not available"));
          }
          cb();
        }
      ], callback);
    };
  };
  return capabilities;
}
var ffprobe;
var hasRequiredFfprobe;
function requireFfprobe() {
  if (hasRequiredFfprobe) return ffprobe;
  hasRequiredFfprobe = 1;
  var spawn = require$$0$6.spawn;
  function legacyTag(key2) {
    return key2.match(/^TAG:/);
  }
  function legacyDisposition(key2) {
    return key2.match(/^DISPOSITION:/);
  }
  function parseFfprobeOutput(out) {
    var lines = out.split(/\r\n|\r|\n/);
    lines = lines.filter(function(line3) {
      return line3.length > 0;
    });
    var data = {
      streams: [],
      format: {},
      chapters: []
    };
    function parseBlock(name) {
      var data2 = {};
      var line3 = lines.shift();
      while (typeof line3 !== "undefined") {
        if (line3.toLowerCase() == "[/" + name + "]") {
          return data2;
        } else if (line3.match(/^\[/)) {
          line3 = lines.shift();
          continue;
        }
        var kv = line3.match(/^([^=]+)=(.*)$/);
        if (kv) {
          if (!kv[1].match(/^TAG:/) && kv[2].match(/^[0-9]+(\.[0-9]+)?$/)) {
            data2[kv[1]] = Number(kv[2]);
          } else {
            data2[kv[1]] = kv[2];
          }
        }
        line3 = lines.shift();
      }
      return data2;
    }
    var line2 = lines.shift();
    while (typeof line2 !== "undefined") {
      if (line2.match(/^\[stream/i)) {
        var stream = parseBlock("stream");
        data.streams.push(stream);
      } else if (line2.match(/^\[chapter/i)) {
        var chapter = parseBlock("chapter");
        data.chapters.push(chapter);
      } else if (line2.toLowerCase() === "[format]") {
        data.format = parseBlock("format");
      }
      line2 = lines.shift();
    }
    return data;
  }
  ffprobe = function(proto) {
    proto.ffprobe = function() {
      var input, index = null, options = [], callback;
      var callback = arguments[arguments.length - 1];
      var ended = false;
      function handleCallback(err, data) {
        if (!ended) {
          ended = true;
          callback(err, data);
        }
      }
      switch (arguments.length) {
        case 3:
          index = arguments[0];
          options = arguments[1];
          break;
        case 2:
          if (typeof arguments[0] === "number") {
            index = arguments[0];
          } else if (Array.isArray(arguments[0])) {
            options = arguments[0];
          }
          break;
      }
      if (index === null) {
        if (!this._currentInput) {
          return handleCallback(new Error("No input specified"));
        }
        input = this._currentInput;
      } else {
        input = this._inputs[index];
        if (!input) {
          return handleCallback(new Error("Invalid input index"));
        }
      }
      this._getFfprobePath(function(err, path2) {
        if (err) {
          return handleCallback(err);
        } else if (!path2) {
          return handleCallback(new Error("Cannot find ffprobe"));
        }
        var stdout = "";
        var stdoutClosed = false;
        var stderr = "";
        var stderrClosed = false;
        var src = input.isStream ? "pipe:0" : input.source;
        var ffprobe2 = spawn(path2, ["-show_streams", "-show_format"].concat(options, src), { windowsHide: true });
        if (input.isStream) {
          ffprobe2.stdin.on("error", function(err2) {
            if (["ECONNRESET", "EPIPE", "EOF"].indexOf(err2.code) >= 0) {
              return;
            }
            handleCallback(err2);
          });
          ffprobe2.stdin.on("close", function() {
            input.source.pause();
            input.source.unpipe(ffprobe2.stdin);
          });
          input.source.pipe(ffprobe2.stdin);
        }
        ffprobe2.on("error", callback);
        var exitError = null;
        function handleExit(err2) {
          if (err2) {
            exitError = err2;
          }
          if (processExited && stdoutClosed && stderrClosed) {
            if (exitError) {
              if (stderr) {
                exitError.message += "\n" + stderr;
              }
              return handleCallback(exitError);
            }
            var data = parseFfprobeOutput(stdout);
            [data.format].concat(data.streams).forEach(function(target) {
              if (target) {
                var legacyTagKeys = Object.keys(target).filter(legacyTag);
                if (legacyTagKeys.length) {
                  target.tags = target.tags || {};
                  legacyTagKeys.forEach(function(tagKey) {
                    target.tags[tagKey.substr(4)] = target[tagKey];
                    delete target[tagKey];
                  });
                }
                var legacyDispositionKeys = Object.keys(target).filter(legacyDisposition);
                if (legacyDispositionKeys.length) {
                  target.disposition = target.disposition || {};
                  legacyDispositionKeys.forEach(function(dispositionKey) {
                    target.disposition[dispositionKey.substr(12)] = target[dispositionKey];
                    delete target[dispositionKey];
                  });
                }
              }
            });
            handleCallback(null, data);
          }
        }
        var processExited = false;
        ffprobe2.on("exit", function(code, signal) {
          processExited = true;
          if (code) {
            handleExit(new Error("ffprobe exited with code " + code));
          } else if (signal) {
            handleExit(new Error("ffprobe was killed with signal " + signal));
          } else {
            handleExit();
          }
        });
        ffprobe2.stdout.on("data", function(data) {
          stdout += data;
        });
        ffprobe2.stdout.on("close", function() {
          stdoutClosed = true;
          handleExit();
        });
        ffprobe2.stderr.on("data", function(data) {
          stderr += data;
        });
        ffprobe2.stderr.on("close", function() {
          stderrClosed = true;
          handleExit();
        });
      });
    };
  };
  return ffprobe;
}
var recipes;
var hasRequiredRecipes;
function requireRecipes() {
  if (hasRequiredRecipes) return recipes;
  hasRequiredRecipes = 1;
  var fs2 = fs$1;
  var path2 = require$$1$2;
  var PassThrough = require$$2$1.PassThrough;
  var async2 = requireAsync();
  var utils2 = requireUtils$3();
  recipes = function recipes2(proto) {
    proto.saveToFile = proto.save = function(output2) {
      this.output(output2).run();
      return this;
    };
    proto.writeToStream = proto.pipe = proto.stream = function(stream, options) {
      if (stream && !("writable" in stream)) {
        options = stream;
        stream = void 0;
      }
      if (!stream) {
        if (process.version.match(/v0\.8\./)) {
          throw new Error("PassThrough stream is not supported on node v0.8");
        }
        stream = new PassThrough();
      }
      this.output(stream, options).run();
      return stream;
    };
    proto.takeScreenshots = proto.thumbnail = proto.thumbnails = proto.screenshot = proto.screenshots = function(config, folder) {
      var self2 = this;
      var source2 = this._currentInput.source;
      config = config || { count: 1 };
      if (typeof config === "number") {
        config = {
          count: config
        };
      }
      if (!("folder" in config)) {
        config.folder = folder || ".";
      }
      if ("timestamps" in config) {
        config.timemarks = config.timestamps;
      }
      if (!("timemarks" in config)) {
        if (!config.count) {
          throw new Error("Cannot take screenshots: neither a count nor a timemark list are specified");
        }
        var interval = 100 / (1 + config.count);
        config.timemarks = [];
        for (var i = 0; i < config.count; i++) {
          config.timemarks.push(interval * (i + 1) + "%");
        }
      }
      if ("size" in config) {
        var fixedSize = config.size.match(/^(\d+)x(\d+)$/);
        var fixedWidth = config.size.match(/^(\d+)x\?$/);
        var fixedHeight = config.size.match(/^\?x(\d+)$/);
        var percentSize = config.size.match(/^(\d+)%$/);
        if (!fixedSize && !fixedWidth && !fixedHeight && !percentSize) {
          throw new Error("Invalid size parameter: " + config.size);
        }
      }
      var metadata;
      function getMetadata(cb) {
        if (metadata) {
          cb(null, metadata);
        } else {
          self2.ffprobe(function(err, meta) {
            metadata = meta;
            cb(err, meta);
          });
        }
      }
      async2.waterfall([
        // Compute percent timemarks if any
        function computeTimemarks(next) {
          if (config.timemarks.some(function(t) {
            return ("" + t).match(/^[\d.]+%$/);
          })) {
            if (typeof source2 !== "string") {
              return next(new Error("Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks"));
            }
            getMetadata(function(err, meta) {
              if (err) {
                next(err);
              } else {
                var vstream = meta.streams.reduce(function(biggest, stream) {
                  if (stream.codec_type === "video" && stream.width * stream.height > biggest.width * biggest.height) {
                    return stream;
                  } else {
                    return biggest;
                  }
                }, { width: 0, height: 0 });
                if (vstream.width === 0) {
                  return next(new Error("No video stream in input, cannot take screenshots"));
                }
                var duration = Number(vstream.duration);
                if (isNaN(duration)) {
                  duration = Number(meta.format.duration);
                }
                if (isNaN(duration)) {
                  return next(new Error("Could not get input duration, please specify fixed timemarks"));
                }
                config.timemarks = config.timemarks.map(function(mark) {
                  if (("" + mark).match(/^([\d.]+)%$/)) {
                    return duration * parseFloat(mark) / 100;
                  } else {
                    return mark;
                  }
                });
                next();
              }
            });
          } else {
            next();
          }
        },
        // Turn all timemarks into numbers and sort them
        function normalizeTimemarks(next) {
          config.timemarks = config.timemarks.map(function(mark) {
            return utils2.timemarkToSeconds(mark);
          }).sort(function(a, b) {
            return a - b;
          });
          next();
        },
        // Add '_%i' to pattern when requesting multiple screenshots and no variable token is present
        function fixPattern(next) {
          var pattern2 = config.filename || "tn.png";
          if (pattern2.indexOf(".") === -1) {
            pattern2 += ".png";
          }
          if (config.timemarks.length > 1 && !pattern2.match(/%(s|0*i)/)) {
            var ext = path2.extname(pattern2);
            pattern2 = path2.join(path2.dirname(pattern2), path2.basename(pattern2, ext) + "_%i" + ext);
          }
          next(null, pattern2);
        },
        // Replace filename tokens (%f, %b) in pattern
        function replaceFilenameTokens(pattern2, next) {
          if (pattern2.match(/%[bf]/)) {
            if (typeof source2 !== "string") {
              return next(new Error("Cannot replace %f or %b when using an input stream"));
            }
            pattern2 = pattern2.replace(/%f/g, path2.basename(source2)).replace(/%b/g, path2.basename(source2, path2.extname(source2)));
          }
          next(null, pattern2);
        },
        // Compute size if needed
        function getSize(pattern2, next) {
          if (pattern2.match(/%[whr]/)) {
            if (fixedSize) {
              return next(null, pattern2, fixedSize[1], fixedSize[2]);
            }
            getMetadata(function(err, meta) {
              if (err) {
                return next(new Error("Could not determine video resolution to replace %w, %h or %r"));
              }
              var vstream = meta.streams.reduce(function(biggest, stream) {
                if (stream.codec_type === "video" && stream.width * stream.height > biggest.width * biggest.height) {
                  return stream;
                } else {
                  return biggest;
                }
              }, { width: 0, height: 0 });
              if (vstream.width === 0) {
                return next(new Error("No video stream in input, cannot replace %w, %h or %r"));
              }
              var width = vstream.width;
              var height = vstream.height;
              if (fixedWidth) {
                height = height * Number(fixedWidth[1]) / width;
                width = Number(fixedWidth[1]);
              } else if (fixedHeight) {
                width = width * Number(fixedHeight[1]) / height;
                height = Number(fixedHeight[1]);
              } else if (percentSize) {
                width = width * Number(percentSize[1]) / 100;
                height = height * Number(percentSize[1]) / 100;
              }
              next(null, pattern2, Math.round(width / 2) * 2, Math.round(height / 2) * 2);
            });
          } else {
            next(null, pattern2, -1, -1);
          }
        },
        // Replace size tokens (%w, %h, %r) in pattern
        function replaceSizeTokens(pattern2, width, height, next) {
          pattern2 = pattern2.replace(/%r/g, "%wx%h").replace(/%w/g, width).replace(/%h/g, height);
          next(null, pattern2);
        },
        // Replace variable tokens in pattern (%s, %i) and generate filename list
        function replaceVariableTokens(pattern2, next) {
          var filenames = config.timemarks.map(function(t, i2) {
            return pattern2.replace(/%s/g, utils2.timemarkToSeconds(t)).replace(/%(0*)i/g, function(match, padding) {
              var idx = "" + (i2 + 1);
              return padding.substr(0, Math.max(0, padding.length + 1 - idx.length)) + idx;
            });
          });
          self2.emit("filenames", filenames);
          next(null, filenames);
        },
        // Create output directory
        function createDirectory(filenames, next) {
          fs2.exists(config.folder, function(exists) {
            if (!exists) {
              fs2.mkdir(config.folder, function(err) {
                if (err) {
                  next(err);
                } else {
                  next(null, filenames);
                }
              });
            } else {
              next(null, filenames);
            }
          });
        }
      ], function runCommand(err, filenames) {
        if (err) {
          return self2.emit("error", err);
        }
        var count = config.timemarks.length;
        var split;
        var filters = [split = {
          filter: "split",
          options: count,
          outputs: []
        }];
        if ("size" in config) {
          self2.size(config.size);
          var sizeFilters = self2._currentOutput.sizeFilters.get().map(function(f, i3) {
            if (i3 > 0) {
              f.inputs = "size" + (i3 - 1);
            }
            f.outputs = "size" + i3;
            return f;
          });
          split.inputs = "size" + (sizeFilters.length - 1);
          filters = sizeFilters.concat(filters);
          self2._currentOutput.sizeFilters.clear();
        }
        var first = 0;
        for (var i2 = 0; i2 < count; i2++) {
          var stream = "screen" + i2;
          split.outputs.push(stream);
          if (i2 === 0) {
            first = config.timemarks[i2];
            self2.seekInput(first);
          }
          self2.output(path2.join(config.folder, filenames[i2])).frames(1).map(stream);
          if (i2 > 0) {
            self2.seek(config.timemarks[i2] - first);
          }
        }
        self2.complexFilter(filters);
        self2.run();
      });
      return this;
    };
    proto.mergeToFile = proto.concatenate = proto.concat = function(target, options) {
      var fileInput = this._inputs.filter(function(input) {
        return !input.isStream;
      })[0];
      var self2 = this;
      this.ffprobe(this._inputs.indexOf(fileInput), function(err, data) {
        if (err) {
          return self2.emit("error", err);
        }
        var hasAudioStreams = data.streams.some(function(stream) {
          return stream.codec_type === "audio";
        });
        var hasVideoStreams = data.streams.some(function(stream) {
          return stream.codec_type === "video";
        });
        self2.output(target, options).complexFilter({
          filter: "concat",
          options: {
            n: self2._inputs.length,
            v: hasVideoStreams ? 1 : 0,
            a: hasAudioStreams ? 1 : 0
          }
        }).run();
      });
      return this;
    };
  };
  return recipes;
}
var fluentFfmpeg$1;
var hasRequiredFluentFfmpeg$1;
function requireFluentFfmpeg$1() {
  if (hasRequiredFluentFfmpeg$1) return fluentFfmpeg$1;
  hasRequiredFluentFfmpeg$1 = 1;
  var path2 = require$$1$2;
  var util2 = require$$1$3;
  var EventEmitter = require$$2$2.EventEmitter;
  var utils2 = requireUtils$3();
  function FfmpegCommand(input, options) {
    if (!(this instanceof FfmpegCommand)) {
      return new FfmpegCommand(input, options);
    }
    EventEmitter.call(this);
    if (typeof input === "object" && !("readable" in input)) {
      options = input;
    } else {
      options = options || {};
      options.source = input;
    }
    this._inputs = [];
    if (options.source) {
      this.input(options.source);
    }
    this._outputs = [];
    this.output();
    var self2 = this;
    ["_global", "_complexFilters"].forEach(function(prop) {
      self2[prop] = utils2.args();
    });
    options.stdoutLines = "stdoutLines" in options ? options.stdoutLines : 100;
    options.presets = options.presets || options.preset || path2.join(__dirname, "presets");
    options.niceness = options.niceness || options.priority || 0;
    this.options = options;
    this.logger = options.logger || {
      debug: function() {
      },
      info: function() {
      },
      warn: function() {
      },
      error: function() {
      }
    };
  }
  util2.inherits(FfmpegCommand, EventEmitter);
  fluentFfmpeg$1 = FfmpegCommand;
  FfmpegCommand.prototype.clone = function() {
    var clone2 = new FfmpegCommand();
    var self2 = this;
    clone2.options = this.options;
    clone2.logger = this.logger;
    clone2._inputs = this._inputs.map(function(input) {
      return {
        source: input.source,
        options: input.options.clone()
      };
    });
    if ("target" in this._outputs[0]) {
      clone2._outputs = [];
      clone2.output();
    } else {
      clone2._outputs = [
        clone2._currentOutput = {
          flags: {}
        }
      ];
      ["audio", "audioFilters", "video", "videoFilters", "sizeFilters", "options"].forEach(function(key2) {
        clone2._currentOutput[key2] = self2._currentOutput[key2].clone();
      });
      if (this._currentOutput.sizeData) {
        clone2._currentOutput.sizeData = {};
        utils2.copy(this._currentOutput.sizeData, clone2._currentOutput.sizeData);
      }
      utils2.copy(this._currentOutput.flags, clone2._currentOutput.flags);
    }
    ["_global", "_complexFilters"].forEach(function(prop) {
      clone2[prop] = self2[prop].clone();
    });
    return clone2;
  };
  requireInputs()(FfmpegCommand.prototype);
  requireAudio()(FfmpegCommand.prototype);
  requireVideo()(FfmpegCommand.prototype);
  requireVideosize()(FfmpegCommand.prototype);
  requireOutput()(FfmpegCommand.prototype);
  requireCustom()(FfmpegCommand.prototype);
  requireMisc()(FfmpegCommand.prototype);
  requireProcessor()(FfmpegCommand.prototype);
  requireCapabilities()(FfmpegCommand.prototype);
  FfmpegCommand.setFfmpegPath = function(path3) {
    new FfmpegCommand().setFfmpegPath(path3);
  };
  FfmpegCommand.setFfprobePath = function(path3) {
    new FfmpegCommand().setFfprobePath(path3);
  };
  FfmpegCommand.setFlvtoolPath = function(path3) {
    new FfmpegCommand().setFlvtoolPath(path3);
  };
  FfmpegCommand.availableFilters = FfmpegCommand.getAvailableFilters = function(callback) {
    new FfmpegCommand().availableFilters(callback);
  };
  FfmpegCommand.availableCodecs = FfmpegCommand.getAvailableCodecs = function(callback) {
    new FfmpegCommand().availableCodecs(callback);
  };
  FfmpegCommand.availableFormats = FfmpegCommand.getAvailableFormats = function(callback) {
    new FfmpegCommand().availableFormats(callback);
  };
  FfmpegCommand.availableEncoders = FfmpegCommand.getAvailableEncoders = function(callback) {
    new FfmpegCommand().availableEncoders(callback);
  };
  requireFfprobe()(FfmpegCommand.prototype);
  FfmpegCommand.ffprobe = function(file) {
    var instance = new FfmpegCommand(file);
    instance.ffprobe.apply(instance, Array.prototype.slice.call(arguments, 1));
  };
  requireRecipes()(FfmpegCommand.prototype);
  return fluentFfmpeg$1;
}
var fluentFfmpeg;
var hasRequiredFluentFfmpeg;
function requireFluentFfmpeg() {
  if (hasRequiredFluentFfmpeg) return fluentFfmpeg;
  hasRequiredFluentFfmpeg = 1;
  fluentFfmpeg = requireFluentFfmpeg$1();
  return fluentFfmpeg;
}
var fluentFfmpegExports = requireFluentFfmpeg();
const ffmpeg = /* @__PURE__ */ getDefaultExportFromCjs(fluentFfmpegExports);
function setFFMpegPath(ffmpegPath) {
  os.platform();
  const paths = [
    ffmpegPath,
    path__default.join(path__default.dirname(fileURLToPath(import.meta.url)), "ffmpeg.exe"),
    process.env["FFMPEG_PATH"] || ""
    // ...envPaths,
  ];
  for (const p of paths) {
    if (fs__default.existsSync(p)) {
      ffmpeg.setFfmpegPath(p);
      console.log("set ffmpeg successfully", p);
      break;
    }
  }
}
class Core extends Service2 {
  constructor(ctx, config) {
    super(ctx, "app", true);
    this.ctx = ctx;
    this.config = config;
    this.pmhq = pmhq;
  }
  static inject = ["ntMsgApi", "ntFriendApi", "ntGroupApi", "store", "ntUserApi", "ntFileApi"];
  startupTime = 0;
  messageReceivedCount = 0;
  messageSentCount = 0;
  lastMessageTime = 0;
  pmhq;
  start() {
    this.startupTime = Math.trunc(Date.now() / 1e3);
    this.registerListener();
    this.ctx.logger.info(`LLOneBot/${version}`);
    this.ctx.on("llob/config-updated", (input) => {
      Object.assign(this.config, input);
      setFFMpegPath(input.ffmpeg || "");
    });
  }
  async sendMessage(ctx, peer, sendElements, deleteAfterSentFiles) {
    if (peer.chatType === ChatType.Group) {
      const info = await ctx.ntGroupApi.getGroupAllInfo(peer.peerUid).catch(() => void 0);
      const shutUpMeTimestamp = info?.shutUpMeTimestamp;
      if (shutUpMeTimestamp && shutUpMeTimestamp * 1e3 > Date.now()) {
        throw new Error("");
      }
    }
    if (!sendElements.length) {
      throw new Error("");
    }
    let totalSize = 0;
    for (const fileElement of sendElements) {
      try {
        if (fileElement.elementType === ElementType.Ptt) {
          totalSize += statSync(fileElement.pttElement.filePath).size;
        } else if (fileElement.elementType === ElementType.File) {
          totalSize += statSync(fileElement.fileElement.filePath).size;
        } else if (fileElement.elementType === ElementType.Video) {
          totalSize += statSync(fileElement.videoElement.filePath).size;
        } else if (fileElement.elementType === ElementType.Pic) {
          totalSize += statSync(fileElement.picElement.sourcePath).size;
        }
      } catch (e) {
        ctx.logger.warn("", e, fileElement);
      }
    }
    const timeout2 = 1e4 + totalSize / 1024 / 256 * 1e3;
    const returnMsg = await ctx.ntMsgApi.sendMsg(peer, sendElements, timeout2);
    if (returnMsg) {
      this.messageSentCount++;
      ctx.logger.info("", peer);
      deleteAfterSentFiles.map((path2) => {
        unlink(path2).then().catch((e) => {
        });
      });
      return returnMsg;
    }
  }
  handleMessage(msgList) {
    for (const message of msgList) {
      const msgTime = parseInt(message.msgTime);
      if (msgTime < this.startupTime) {
        continue;
      }
      if (message.senderUin && message.senderUin !== "0") {
        this.ctx.store.addMsgCache(message);
      }
      this.lastMessageTime = msgTime;
      this.messageReceivedCount++;
      logSummaryMessage(this.ctx, message).then();
      this.ctx.parallel("nt/message-created", message);
    }
    if (!this.config.autoDeleteFile) {
      return;
    }
    const allPaths = [];
    for (const message of msgList) {
      for (const msgElement of message.elements) {
        const picPath = msgElement.picElement?.sourcePath;
        const picThumbPath = [...(msgElement.picElement?.thumbPath ?? []).values()];
        const pttPath = msgElement.pttElement?.filePath;
        const filePath = msgElement.fileElement?.filePath;
        const videoPath = msgElement.videoElement?.filePath;
        const videoThumbPath = [...(msgElement.videoElement?.thumbPath ?? []).values()];
        const pathList = [picPath, ...picThumbPath, pttPath, filePath, videoPath, ...videoThumbPath];
        if (msgElement.picElement) {
          pathList.push(...Object.values(msgElement.picElement.thumbPath));
        }
        allPaths.push(...pathList.filter((path2) => path2 !== void 0 && path2 !== null));
      }
    }
    if (allPaths.length > 0) {
      setTimeout(() => {
        for (const path2 of allPaths) {
          if (path2) {
            unlink(path2).then(() => this.ctx.logger.info("", path2)).catch((e) => {
            });
          }
        }
      }, this.config.autoDeleteFileSecond * 1e3);
    }
  }
  registerListener() {
    registerReceiveHook(ReceiveCmdS.SELF_STATUS, (info) => {
      Object.assign(selfInfo, { online: info.status !== 20 });
    });
    registerReceiveHook(ReceiveCmdS.GROUP_MEMBER_INFO_UPDATE, async (payload) => {
      const groupCode = payload[0];
      const members = Array.from(payload[2].values());
      this.ctx.parallel("nt/group-member-info-updated", { groupCode, members });
    });
    registerReceiveHook(ReceiveCmdS.NEW_MSG, (payload) => {
      this.handleMessage(payload);
    });
    const sentMsgIds = /* @__PURE__ */ new Map();
    const recallMsgIds = [];
    registerReceiveHook([ReceiveCmdS.UPDATE_MSG], (payload) => {
      for (const msg of payload) {
        if (msg.recallTime !== "0" && msg.msgType === 5 && msg.subMsgType === 4 && msg.elements[0]?.grayTipElement?.subElementType === GrayTipElementSubType.Revoke && !recallMsgIds.includes(msg.msgId)) {
          recallMsgIds.push(msg.msgId);
          this.ctx.parallel("nt/message-deleted", msg);
        } else if (sentMsgIds.get(msg.msgId)) {
          if (msg.sendStatus === 2) {
            sentMsgIds.delete(msg.msgId);
            logSummaryMessage(this.ctx, msg).then();
            this.ctx.parallel("nt/message-sent", msg);
          }
        }
      }
      if (recallMsgIds.length > 1e3) {
        recallMsgIds.shift();
      }
      if (sentMsgIds.size > 1e3) {
        const firstKey = sentMsgIds.keys().next().value;
        if (firstKey) {
          sentMsgIds.delete(firstKey);
        }
      }
    });
    registerReceiveHook(ReceiveCmdS.SELF_SEND_MSG, (payload) => {
      sentMsgIds.set(payload.msgId, true);
    });
    const groupNotifyIgnore = [];
    registerReceiveHook(ReceiveCmdS.UNREAD_GROUP_NOTIFY, async (payload) => {
      const [doubt, oldestUnreadSeq, unreadCount] = payload;
      if (unreadCount) {
        let notifies;
        try {
          notifies = await this.ctx.ntGroupApi.getSingleScreenNotifies(doubt, unreadCount);
        } catch (e) {
          return;
        }
        for (const notify of notifies) {
          const notifyTime = Math.trunc(+notify.seq / 1e3 / 1e3);
          if (groupNotifyIgnore.includes(notify.seq) || notifyTime < this.startupTime) {
            continue;
          }
          groupNotifyIgnore.push(notify.seq);
          if (groupNotifyIgnore.length > 1e3) {
            groupNotifyIgnore.shift();
          }
          this.ctx.parallel("nt/group-notify", { notify, doubt });
        }
      }
    });
    registerReceiveHook(ReceiveCmdS.FRIEND_REQUEST, (payload) => {
      for (const req of payload.buddyReqs) {
        if (!!req.isInitiator || req.isDecide && req.reqType !== BuddyReqType.MeInitiatorWaitPeerConfirm) {
          continue;
        }
        if (+req.reqTime < this.startupTime) {
          continue;
        }
        this.ctx.parallel("nt/friend-request", req);
      }
    });
    registerReceiveHook("nodeIKernelMsgListener/onRecvSysMsg", (payload) => {
      this.ctx.parallel("nt/system-message-created", Uint8Array.from(payload));
    });
    registerReceiveHook(ReceiveCmdS.FLASH_FILE_DOWNLOAD_STATUS, (payload) => {
      const [status, errCode, fileSetId] = payload;
      this.ctx.ntFileApi.getFlashFileInfo(fileSetId).then((info) => {
        this.ctx.parallel("nt/flash-file-download-status", {
          status,
          info
        });
      }).catch((err) => {
        this.ctx.logger.error(err, { fileSetId });
      });
    });
    registerReceiveHook(ReceiveCmdS.FLASH_FILE_UPLOAD_STATUS, (payload) => {
      this.ctx.parallel("nt/flash-file-upload-status", payload);
    });
    registerReceiveHook(ReceiveCmdS.FLASH_FILE_DOWNLOADING, (payload) => {
      const [fileSetId, info] = payload;
      this.ctx.parallel("nt/flash-file-downloading", [fileSetId, info]);
    });
    registerReceiveHook(ReceiveCmdS.FLASH_FILE_UPLOADING, (payload) => {
      this.ctx.parallel("nt/flash-file-uploading", payload);
    });
  }
}
var OB11UserSex = /* @__PURE__ */ ((OB11UserSex2) => {
  OB11UserSex2["Male"] = "male";
  OB11UserSex2["Female"] = "female";
  OB11UserSex2["Unknown"] = "unknown";
  return OB11UserSex2;
})(OB11UserSex || {});
var OB11GroupMemberRole = /* @__PURE__ */ ((OB11GroupMemberRole2) => {
  OB11GroupMemberRole2["Owner"] = "owner";
  OB11GroupMemberRole2["Admin"] = "admin";
  OB11GroupMemberRole2["Member"] = "member";
  return OB11GroupMemberRole2;
})(OB11GroupMemberRole || {});
var OB11MessageDataType = /* @__PURE__ */ ((OB11MessageDataType2) => {
  OB11MessageDataType2["Text"] = "text";
  OB11MessageDataType2["Image"] = "image";
  OB11MessageDataType2["Music"] = "music";
  OB11MessageDataType2["Video"] = "video";
  OB11MessageDataType2["Record"] = "record";
  OB11MessageDataType2["File"] = "file";
  OB11MessageDataType2["FlashFile"] = "flash_file";
  OB11MessageDataType2["At"] = "at";
  OB11MessageDataType2["Reply"] = "reply";
  OB11MessageDataType2["Json"] = "json";
  OB11MessageDataType2["Face"] = "face";
  OB11MessageDataType2["Mface"] = "mface";
  OB11MessageDataType2["Markdown"] = "markdown";
  OB11MessageDataType2["Node"] = "node";
  OB11MessageDataType2["Forward"] = "forward";
  OB11MessageDataType2["Xml"] = "xml";
  OB11MessageDataType2["Poke"] = "poke";
  OB11MessageDataType2["Dice"] = "dice";
  OB11MessageDataType2["Rps"] = "rps";
  OB11MessageDataType2["Contact"] = "contact";
  OB11MessageDataType2["Shake"] = "shake";
  OB11MessageDataType2["Keyboard"] = "keyboard";
  return OB11MessageDataType2;
})(OB11MessageDataType || {});
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2["META"] = "meta_event";
  EventType2["REQUEST"] = "request";
  EventType2["NOTICE"] = "notice";
  EventType2["MESSAGE"] = "message";
  EventType2["MESSAGE_SENT"] = "message_sent";
  return EventType2;
})(EventType || {});
class OB11BaseEvent {
  time = Math.floor(Date.now() / 1e3);
  self_id = parseInt(selfInfo.uin);
}
const pattern = /\[CQ:(\w+)((,\w+=[^,\]]*)*)\]/;
function unescape$1(source2) {
  return String(source2).replace(/&#91;/g, "[").replace(/&#93;/g, "]").replace(/&#44;/g, ",").replace(/&amp;/g, "&");
}
function from(source2) {
  const capture = pattern.exec(source2);
  if (!capture) return null;
  const [, type2, attrs] = capture;
  const data = {};
  if (attrs) {
    attrs.slice(1).split(",").forEach((str) => {
      const index = str.indexOf("=");
      data[str.slice(0, index)] = unescape$1(str.slice(index + 1));
    });
  }
  return { type: type2, data, capture };
}
function h$1(type2, data) {
  return {
    type: type2,
    data
  };
}
function decodeCQCode(source2) {
  const elements = [];
  let result;
  while (result = from(source2)) {
    const { type: type2, data, capture } = result;
    if (capture.index) {
      elements.push(h$1("text", { text: unescape$1(source2.slice(0, capture.index)) }));
    }
    elements.push(h$1(type2, data));
    source2 = source2.slice(capture.index + capture[0].length);
  }
  if (source2) elements.push(h$1("text", { text: unescape$1(source2) }));
  return elements;
}
function encodeCQCode(input) {
  const CQCodeEscapeText = (text) => {
    return text.replace(/\&/g, "&amp;").replace(/\[/g, "&#91;").replace(/\]/g, "&#93;");
  };
  const CQCodeEscape = (text) => {
    return text.replace(/\&/g, "&amp;").replace(/\[/g, "&#91;").replace(/\]/g, "&#93;").replace(/,/g, "&#44;");
  };
  if (input.type === "text") {
    return CQCodeEscapeText(input.data.text);
  }
  let result = "[CQ:" + input.type;
  for (const [key2, value] of Object.entries(input.data)) {
    if (value === void 0) {
      continue;
    }
    try {
      const text = value.toString();
      result += `,${key2}=${CQCodeEscape(text)}`;
    } catch (error) {
    }
  }
  result += "]";
  return result;
}
class OB11BaseNoticeEvent extends OB11BaseEvent {
  post_type = EventType.NOTICE;
}
class OB11GroupNoticeEvent extends OB11BaseNoticeEvent {
}
class OB11GroupIncreaseEvent extends OB11GroupNoticeEvent {
  notice_type = "group_increase";
  operator_id;
  sub_type;
  group_id;
  user_id;
  constructor(groupId, userId, operatorId, subType = "approve") {
    super();
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.sub_type = subType;
  }
}
class OB11GroupUploadNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_upload";
  file;
  group_id;
  user_id;
  constructor(groupId, userId, file) {
    super();
    this.group_id = groupId;
    this.user_id = userId;
    this.file = file;
  }
}
function isNumeric(str) {
  return /^\d+$/.test(str);
}
function calcQQLevel(level) {
  const { crownNum, sunNum, moonNum, starNum } = level;
  return crownNum * 64 + sunNum * 16 + moonNum * 4 + starNum;
}
function mergeNewProperties(newObj, oldObj) {
  Object.keys(newObj).forEach((key2) => {
    if (!oldObj.hasOwnProperty(key2)) {
      oldObj[key2] = newObj[key2];
    } else {
      if (typeof oldObj[key2] === "object" && typeof newObj[key2] === "object") {
        mergeNewProperties(newObj[key2], oldObj[key2]);
      } else if (typeof oldObj[key2] === "object" || typeof newObj[key2] === "object") {
        oldObj[key2] = newObj[key2];
      }
    }
  });
}
function filterNullable(array) {
  return array.filter((e) => !isNullable(e));
}
function parseBool(value) {
  if (["", "true", "1"].includes(value)) {
    return true;
  }
  return false;
}
class DetailedError extends Error {
  data;
  constructor(message, data) {
    super(message);
    defineProperty(this, "data", data);
  }
}
class OB11GroupTitleEvent extends OB11GroupNoticeEvent {
  notice_type = "notify";
  sub_type = "title";
  title;
  group_id;
  user_id;
  constructor(groupId, userId, title) {
    super();
    this.group_id = groupId;
    this.user_id = userId;
    this.title = title;
  }
}
class OB11GroupDecreaseEvent extends OB11GroupNoticeEvent {
  notice_type = "group_decrease";
  sub_type = "leave";
  operator_id;
  group_id;
  user_id;
  constructor(groupId, userId, operatorId, subType = "leave") {
    super();
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.sub_type = subType;
  }
}
class OB11FriendAddNoticeEvent extends OB11BaseNoticeEvent {
  notice_type = "friend_add";
  user_id;
  constructor(userId) {
    super();
    this.user_id = userId;
  }
}
class OB11FriendRecallNoticeEvent extends OB11BaseNoticeEvent {
  notice_type = "friend_recall";
  user_id;
  message_id;
  constructor(userId, messageId) {
    super();
    this.user_id = userId;
    this.message_id = messageId;
  }
}
class OB11GroupRecallNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_recall";
  operator_id;
  message_id;
  group_id;
  user_id;
  constructor(groupId, userId, operatorId, messageId) {
    super();
    this.group_id = groupId;
    this.user_id = userId;
    this.operator_id = operatorId;
    this.message_id = messageId;
  }
}
class OB11PokeEvent extends OB11BaseNoticeEvent {
  notice_type = "notify";
  sub_type = "poke";
  target_id = 0;
}
class OB11FriendPokeEvent extends OB11PokeEvent {
  user_id;
  raw_info;
  constructor(user_id, target_id, raw_message) {
    super();
    this.target_id = target_id;
    this.user_id = user_id;
    this.raw_info = raw_message;
  }
}
class OB11GroupPokeEvent extends OB11PokeEvent {
  user_id;
  group_id;
  raw_info;
  constructor(group_id, user_id, target_id, raw_message) {
    super();
    this.group_id = group_id;
    this.target_id = target_id;
    this.user_id = user_id;
    this.raw_info = raw_message;
  }
}
class OB11GroupRequestEvent extends OB11BaseNoticeEvent {
  post_type = EventType.REQUEST;
  request_type = "group";
  sub_type;
  // invite  bot 
  comment;
  flag;
  group_id;
  user_id;
  //  sub_type  invite  user_id  QQ 
  invitor_id;
  // https://github.com/Mrs4s/go-cqhttp/blob/master/coolq/event.go#L566
  constructor(groupId, userId, flag, comment, subType, invitorId = 0) {
    super();
    this.group_id = groupId;
    this.user_id = userId;
    this.comment = comment;
    this.flag = flag;
    this.sub_type = subType;
    this.invitor_id = invitorId;
  }
}
class GroupBanEvent extends OB11GroupNoticeEvent {
  notice_type = "group_ban";
  operator_id;
  duration;
  sub_type;
  group_id;
  user_id;
  constructor(groupId, userId, operatorId, duration, sub_type) {
    super();
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.duration = duration;
    this.sub_type = sub_type;
  }
  static async parse(ctx, groupElement, groupCode) {
    const memberUid = groupElement.shutUp?.member.uid;
    const adminUid = groupElement.shutUp?.admin.uid;
    let memberUin = "";
    let duration = Number(groupElement.shutUp?.duration);
    if (memberUid) {
      memberUin = await ctx.ntUserApi.getUinByUid(memberUid);
    } else {
      memberUin = "0";
      if (duration > 0) {
        duration = -1;
      }
    }
    const adminUin = await ctx.ntUserApi.getUinByUid(adminUid);
    const subType = duration > 0 ? "ban" : "lift_ban";
    return new GroupBanEvent(+groupCode, +memberUin, +adminUin, duration, subType);
  }
}
class GroupMsgEmojiLikeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_msg_emoji_like";
  message_id;
  likes;
  group_id;
  user_id;
  constructor(groupId, userId, messageId, likes) {
    super();
    this.group_id = groupId;
    this.user_id = userId;
    this.message_id = messageId;
    this.likes = likes;
  }
  static async parse(ctx, xmlElement, groupCode) {
    const senderUin = xmlElement.templParam.get("jp_uin");
    const msgSeq = xmlElement.templParam.get("msg_seq");
    const emojiId = xmlElement.templParam.get("face_id");
    const peer = {
      chatType: ChatType.Group,
      guildId: "",
      peerUid: groupCode
    };
    const replyMsgList = (await ctx.ntMsgApi.queryFirstMsgBySeq(peer, msgSeq)).msgList;
    if (!replyMsgList?.length) {
      return;
    }
    const shortId = ctx.store.createMsgShortId(peer, replyMsgList[0].msgId);
    return new GroupMsgEmojiLikeEvent(
      parseInt(groupCode),
      parseInt(senderUin),
      shortId,
      [{
        emoji_id: emojiId,
        count: 1
      }]
    );
  }
}
class GroupEssenceEvent extends OB11GroupNoticeEvent {
  notice_type = "essence";
  message_id;
  sender_id;
  sub_type = "add";
  group_id;
  user_id;
  operator_id;
  constructor(groupId, messageId, senderId, operatorId) {
    super();
    this.group_id = groupId;
    this.user_id = senderId;
    this.message_id = messageId;
    this.sender_id = senderId;
    this.operator_id = operatorId;
  }
  static async parse(ctx, url) {
    const searchParams = url.searchParams;
    const msgSeq = searchParams.get("seq");
    const groupCode = searchParams.get("gc");
    const msgRandom = searchParams.get("random");
    if (!groupCode || !msgSeq || !msgRandom) return;
    const peer = {
      guildId: "",
      chatType: ChatType.Group,
      peerUid: groupCode
    };
    const essence = await ctx.ntGroupApi.queryCachedEssenceMsg(groupCode, msgSeq, msgRandom);
    const { msgList } = await ctx.ntMsgApi.queryMsgsWithFilterExBySeq(peer, msgSeq, "0");
    const sourceMsg = msgList.find((e) => e.msgRandom === msgRandom);
    if (!sourceMsg) return;
    return new GroupEssenceEvent(
      parseInt(groupCode),
      ctx.store.getShortIdByMsgInfo(peer, sourceMsg.msgId),
      parseInt(essence.items[0]?.msgSenderUin ?? sourceMsg.senderUin),
      parseInt(essence.items[0]?.opUin ?? "0")
    );
  }
}
var OB11Entities;
((OB11Entities2) => {
  async function message(ctx, msg, rootMsgID, peer) {
    if (!msg.senderUin || msg.senderUin === "0" || msg.msgType === 1) return;
    const {
      debug,
      messagePostFormat
    } = ctx.config;
    const selfUin = selfInfo.uin;
    const msgShortId = ctx.store.createMsgShortId({ chatType: msg.chatType, peerUid: msg.peerUid }, msg.msgId);
    const resMsg = {
      self_id: Number(selfUin),
      user_id: Number(msg.senderUin),
      time: Number(msg.msgTime),
      message_id: msgShortId,
      message_seq: Number(msg.msgSeq),
      message_type: msg.chatType === ChatType.Group ? "group" : "private",
      sender: {
        user_id: Number(msg.senderUin),
        nickname: msg.sendNickName,
        card: msg.sendMemberName ?? ""
      },
      raw_message: "",
      font: 14,
      sub_type: "friend",
      message: messagePostFormat === "string" ? "" : [],
      message_format: messagePostFormat === "string" ? "string" : "array",
      post_type: selfUin === msg.senderUin ? EventType.MESSAGE_SENT : EventType.MESSAGE
    };
    if (debug) {
      resMsg.raw = msg;
    }
    if (msg.chatType === ChatType.Group) {
      resMsg.sub_type = "normal";
      resMsg.group_id = parseInt(msg.peerUin);
      if (msg.peerUin !== "284840486") {
        try {
          const member = await ctx.ntGroupApi.getGroupMember(msg.peerUin, msg.senderUid);
          resMsg.sender.role = groupMemberRole(member.role);
          resMsg.sender.nickname = member.nick;
          resMsg.sender.title = member.memberSpecialTitle ?? "";
        } catch {
          resMsg.sender.role = OB11GroupMemberRole.Member;
          resMsg.sender.title = "";
        }
      }
    } else if (msg.chatType === ChatType.C2C) {
      resMsg.sub_type = "friend";
      resMsg.sender.nickname = (await ctx.ntUserApi.getUserSimpleInfo(msg.senderUid)).coreInfo.nick;
    } else if (msg.chatType === ChatType.TempC2CFromGroup) {
      resMsg.sub_type = "group";
      resMsg.temp_source = 0;
      resMsg.sender.nickname = (await ctx.ntUserApi.getUserSimpleInfo(msg.senderUid)).coreInfo.nick;
      const ret = await ctx.ntMsgApi.getTempChatInfo(ChatType.TempC2CFromGroup, msg.senderUid);
      if (ret?.result === 0) {
        resMsg.sender.group_id = Number(ret.tmpChatInfo?.groupCode);
      } else {
        resMsg.sender.group_id = 284840486;
      }
    }
    for (const element of msg.elements) {
      let messageSegment;
      if (element.textElement && element.textElement?.atType !== AtType.Unknown) {
        let qq;
        let name;
        if (element.textElement.atType === AtType.All) {
          qq = "all";
        } else {
          const { atNtUid, atUid, content } = element.textElement;
          if (atUid && atUid !== "0") {
            qq = atUid;
          } else {
            qq = await ctx.ntUserApi.getUinByUid(atNtUid, peer?.peerUid);
          }
          name = content.replace("@", "");
        }
        messageSegment = {
          type: OB11MessageDataType.At,
          data: {
            qq,
            name
          }
        };
      } else if (element.textElement) {
        const text = element.textElement.content;
        if (!text) {
          continue;
        }
        messageSegment = {
          type: OB11MessageDataType.Text,
          data: {
            text
          }
        };
      } else if (element.replyElement) {
        const { replyElement } = element;
        const peer2 = {
          chatType: msg.chatType,
          peerUid: msg.peerUid,
          guildId: ""
        };
        try {
          const { replayMsgSeq, replyMsgTime } = replyElement;
          const record = msg.records.find((msgRecord) => msgRecord.msgId === replyElement.sourceMsgIdInRecords);
          const senderUid = replyElement.senderUidStr || record?.senderUid;
          if (!record || !replyMsgTime || !senderUid) {
            ctx.logger.error("");
            continue;
          }
          const { msgList } = await ctx.ntMsgApi.getMsgsBySeqAndCount(peer2, replayMsgSeq, 1, true, true);
          let replyMsg;
          if (record.msgRandom !== "0") {
            replyMsg = msgList.find((msg2) => msg2.msgRandom === record.msgRandom);
          } else {
            ctx.logger.info("msgRandom is missing", replyElement, record);
            replyMsg = msgList[0];
          }
          if (!replyMsg) {
            ctx.logger.error("", replyElement);
            continue;
          }
          if (!replyMsg && msg.peerUin !== "284840486") {
            ctx.logger.error("", replyElement);
            ctx.logger.warn("queryMsgs", msgList.map((e) => pick(e, ["msgSeq", "msgRandom"])), record.msgRandom);
            continue;
          }
          messageSegment = {
            type: OB11MessageDataType.Reply,
            data: {
              id: ctx.store.createMsgShortId(peer2, replyMsg ? replyMsg.msgId : record.msgId).toString()
            }
          };
        } catch (e) {
          ctx.logger.error("", e, replyElement, e.stack);
          continue;
        }
      } else if (element.picElement) {
        const { picElement } = element;
        const fileSize = picElement.fileSize ?? "0";
        messageSegment = {
          type: OB11MessageDataType.Image,
          data: {
            file: picElement.fileName,
            subType: picElement.picSubType,
            url: await ctx.ntFileApi.getImageUrl(picElement),
            file_size: fileSize
          }
        };
        ctx.store.addFileCache({
          peerUid: msg.peerUid,
          msgId: msg.msgId,
          msgTime: +msg.msgTime,
          chatType: msg.chatType,
          elementId: element.elementId,
          elementType: element.elementType,
          fileName: picElement.fileName,
          fileUuid: picElement.fileUuid,
          fileSize
        }).then();
      } else if (element.videoElement) {
        const { videoElement } = element;
        const videoUrl = await ctx.ntFileApi.getVideoUrl(
          {
            chatType: msg.chatType,
            peerUid: peer?.peerUid ?? msg.peerUid
          },
          rootMsgID ?? msg.msgId,
          element.elementId
        );
        const fileSize = videoElement.fileSize ?? "0";
        messageSegment = {
          type: OB11MessageDataType.Video,
          data: {
            file: videoElement.fileName,
            url: videoUrl || pathToFileURL(videoElement.filePath).href,
            path: videoElement.filePath,
            file_size: fileSize
          }
        };
        ctx.store.addFileCache({
          peerUid: msg.peerUid,
          msgId: msg.msgId,
          msgTime: +msg.msgTime,
          chatType: msg.chatType,
          elementId: element.elementId,
          elementType: element.elementType,
          fileName: videoElement.fileName,
          fileUuid: videoElement.fileUuid,
          fileSize
        }).then();
      } else if (element.fileElement) {
        const { fileElement } = element;
        const fileSize = fileElement.fileSize ?? "0";
        messageSegment = {
          type: OB11MessageDataType.File,
          data: {
            file: fileElement.fileName,
            url: pathToFileURL(fileElement.filePath).href,
            file_id: fileElement.fileUuid,
            path: fileElement.filePath,
            file_size: fileSize
          }
        };
        ctx.store.addFileCache({
          peerUid: msg.peerUid,
          msgId: msg.msgId,
          msgTime: +msg.msgTime,
          chatType: msg.chatType,
          elementId: element.elementId,
          elementType: element.elementType,
          fileName: fileElement.fileName,
          fileUuid: fileElement.fileUuid,
          fileSize
        }).then();
      } else if (element.pttElement) {
        const { pttElement } = element;
        const fileSize = pttElement.fileSize ?? "0";
        messageSegment = {
          type: OB11MessageDataType.Record,
          data: {
            file: pttElement.fileName,
            url: pathToFileURL(pttElement.filePath).href,
            path: pttElement.filePath,
            file_size: fileSize
          }
        };
        ctx.store.addFileCache({
          peerUid: msg.peerUid,
          msgId: msg.msgId,
          msgTime: +msg.msgTime,
          chatType: msg.chatType,
          elementId: element.elementId,
          elementType: element.elementType,
          fileName: pttElement.fileName,
          fileUuid: pttElement.fileUuid,
          fileSize
        }).then();
      } else if (element.arkElement) {
        const { arkElement } = element;
        messageSegment = {
          type: OB11MessageDataType.Json,
          data: {
            data: arkElement.bytesData
          }
        };
      } else if (element.faceElement) {
        const { faceElement } = element;
        const { faceIndex, pokeType } = faceElement;
        if (faceIndex === FaceIndex.Dice) {
          messageSegment = {
            type: OB11MessageDataType.Dice,
            data: {
              result: faceElement.resultId
            }
          };
        } else if (faceIndex === FaceIndex.RPS) {
          messageSegment = {
            type: OB11MessageDataType.Rps,
            data: {
              result: faceElement.resultId
            }
          };
        } else {
          messageSegment = {
            type: OB11MessageDataType.Face,
            data: {
              id: faceIndex.toString()
            }
          };
        }
      } else if (element.marketFaceElement) {
        const { marketFaceElement } = element;
        const { emojiId } = marketFaceElement;
        const dir = emojiId.substring(0, 2);
        const url = `https://gxh.vip.qq.com/club/item/parcel/item/${dir}/${emojiId}/raw300.gif`;
        messageSegment = {
          type: OB11MessageDataType.Mface,
          data: {
            summary: marketFaceElement.faceName,
            url,
            emoji_id: emojiId,
            emoji_package_id: marketFaceElement.emojiPackageId,
            key: marketFaceElement.key
          }
        };
      } else if (element.markdownElement) {
        const { markdownElement } = element;
        if (markdownElement?.content.startsWith("[](")) {
          const mqqapiUrl = markdownElement?.content.substring(5, markdownElement?.content.length - 1);
          const urlJson = new URL(mqqapiUrl).searchParams.get("json");
          if (urlJson) {
            const jsonData = JSON.parse(urlJson);
            const busId = jsonData?.busId;
            if (busId === "FlashTransfer") {
              const attributes = jsonData?.attributes?.attributes || [];
              const fileAttribute = attributes.find((a) => a.viewId === "file");
              if (fileAttribute) {
                const urlParams = new URL(fileAttribute.schema).searchParams;
                const fileSetId = urlParams.get("fileset_id") || "";
                const sceneType = urlParams.get("scene_type") || "";
                const fileSubAttributes = fileAttribute?.attributes || [];
                const titleAttribute = fileSubAttributes.find((a) => a.viewId === "title");
                const title = titleAttribute?.text;
                messageSegment = {
                  type: OB11MessageDataType.FlashFile,
                  data: {
                    title,
                    file_set_id: fileSetId,
                    scene_type: parseInt(sceneType)
                  }
                };
              }
            }
          }
        } else {
          messageSegment = {
            type: OB11MessageDataType.Markdown,
            data: {
              content: markdownElement.content
            }
          };
        }
      } else if (element.multiForwardMsgElement) {
        messageSegment = {
          type: OB11MessageDataType.Forward,
          data: {
            id: msg.msgId
          }
        };
      } else if (element.inlineKeyboardElement) {
        messageSegment = {
          type: OB11MessageDataType.Keyboard,
          data: {
            rows: element.inlineKeyboardElement.rows.map((row) => ({
              buttons: row.buttons.map((button) => ({
                id: button.id,
                render_data: {
                  label: button.label,
                  visited_label: button.visitedLabel,
                  style: button.style
                },
                action: {
                  type: button.type,
                  permission: {
                    type: button.permissionType,
                    specify_role_ids: button.specifyRoleIds,
                    specify_user_ids: button.specifyTinyids
                  },
                  unsupport_tips: button.unsupportTips,
                  data: button.data,
                  reply: button.isReply,
                  enter: button.enter
                }
              }))
            }))
          }
        };
      }
      if (messageSegment) {
        const cqCode = encodeCQCode(messageSegment);
        if (messagePostFormat === "array") {
          resMsg.message.push(messageSegment);
        }
        resMsg.raw_message += cqCode;
      }
    }
    if (messagePostFormat === "string") {
      resMsg.message = resMsg.raw_message;
    }
    return resMsg;
  }
  OB11Entities2.message = message;
  async function privateEvent(ctx, msg) {
    if (msg.chatType !== ChatType.C2C) {
      return;
    }
    if (msg.msgType !== 5 && msg.msgType !== 11) {
      return;
    }
    for (const element of msg.elements) {
      if (element.grayTipElement) {
        const { grayTipElement } = element;
        if (grayTipElement.jsonGrayTipElement?.busiId === "1061") {
          const json = JSON.parse(grayTipElement.jsonGrayTipElement.jsonStr);
          const param = grayTipElement.jsonGrayTipElement.xmlToJsonParam;
          if (param) {
            return new OB11FriendPokeEvent(
              Number(param.templParam.get("uin_str1")),
              Number(param.templParam.get("uin_str2")),
              json.items
            );
          }
          const pokedetail = json.items;
          const poke_uid = pokedetail.filter((item) => item.uid);
          if (poke_uid.length === 2) {
            return new OB11FriendPokeEvent(
              Number(await ctx.ntUserApi.getUinByUid(poke_uid[0].uid)),
              Number(await ctx.ntUserApi.getUinByUid(poke_uid[1].uid)),
              pokedetail
            );
          }
        }
        if (grayTipElement.xmlElement?.templId === "10229" || grayTipElement.jsonGrayTipElement?.busiId === "19324") {
          ctx.logger.info("", msg.peerUid);
          const uin = +msg.peerUin || +await ctx.ntUserApi.getUinByUid(msg.peerUid);
          return new OB11FriendAddNoticeEvent(uin);
        }
      } else if (element.arkElement) {
        const data = JSON.parse(element.arkElement.bytesData);
        if (data.app === "com.tencent.qun.invite") {
          const params = new URLSearchParams(data.meta.news.jumpUrl);
          const receiverUin = params.get("receiveruin");
          const senderUin = params.get("senderuin");
          if (receiverUin !== selfInfo.uin || senderUin !== msg.senderUin) {
            return;
          }
          ctx.logger.info("");
          const groupCode = params.get("groupcode");
          const seq = params.get("msgseq");
          const flag = `${groupCode}|${seq}|1|0`;
          return new OB11GroupRequestEvent(
            Number(groupCode),
            Number(senderUin),
            flag,
            data.meta.news.desc,
            "invite"
          );
        }
      }
    }
  }
  OB11Entities2.privateEvent = privateEvent;
  async function groupEvent(ctx, msg) {
    if (msg.chatType !== ChatType.Group) {
      return;
    }
    if (msg.msgType !== 5 && msg.msgType !== 3) {
      return;
    }
    for (const element of msg.elements) {
      if (element.fileElement) {
        return new OB11GroupUploadNoticeEvent(+msg.peerUid, +msg.senderUin, {
          id: element.fileElement.fileUuid,
          name: element.fileElement.fileName,
          size: parseInt(element.fileElement.fileSize),
          busid: element.fileElement.fileBizId || 0
        });
      } else if (element.grayTipElement) {
        const grayTipElement = element.grayTipElement;
        if (grayTipElement.subElementType === GrayTipElementSubType.JSON) {
          const json = JSON.parse(grayTipElement.jsonGrayTipElement.jsonStr);
          if (grayTipElement.jsonGrayTipElement?.busiId === "1061") {
            const param = grayTipElement.jsonGrayTipElement.xmlToJsonParam;
            return new OB11GroupPokeEvent(
              Number(msg.peerUid),
              Number(param.templParam.get("uin_str1")),
              Number(param.templParam.get("uin_str2")),
              json.items
            );
          } else if (grayTipElement.jsonGrayTipElement?.busiId === "2401" && json.items[2]) {
            ctx.logger.info("", json);
            return await GroupEssenceEvent.parse(ctx, new URL(json.items[2].jp));
          } else if (grayTipElement.jsonGrayTipElement?.busiId === "2407") {
            ctx.logger.info("", json);
            const memberUin = json.items[1].param[0];
            const title = json.items[3].txt;
            return new OB11GroupTitleEvent(parseInt(msg.peerUid), parseInt(memberUin), title);
          } else if (grayTipElement.jsonGrayTipElement?.busiId === "19217") {
            ctx.logger.info("", grayTipElement);
            const userId = new URL(json.items[2].jp).searchParams.get("robot_uin");
            const operatorId = new URL(json.items[0].jp).searchParams.get("uin");
            return new OB11GroupIncreaseEvent(Number(msg.peerUid), Number(userId), Number(operatorId), "invite");
          }
        } else if (grayTipElement.subElementType === GrayTipElementSubType.Group) {
          const groupElement = grayTipElement.groupElement;
          if (groupElement.type === TipGroupElementType.Ban) {
            ctx.logger.info("", groupElement);
            return await GroupBanEvent.parse(ctx, groupElement, msg.peerUid);
          } else if (groupElement.type === TipGroupElementType.Kicked) {
            ctx.logger.info(`, ${msg.peerUid}`, groupElement);
            const { adminUid } = groupElement;
            return new OB11GroupDecreaseEvent(
              Number(msg.peerUid),
              Number(selfInfo.uin),
              adminUid ? Number(await ctx.ntUserApi.getUinByUid(adminUid)) : 0,
              adminUid ? "kick_me" : "leave"
            );
          } else if (groupElement.type === TipGroupElementType.MemberIncrease) {
            const { memberUid, adminUid } = groupElement;
            if (memberUid !== selfInfo.uid) return;
            ctx.logger.info("", groupElement);
            const adminUin = adminUid ? await ctx.ntUserApi.getUinByUid(adminUid) : selfInfo.uin;
            return new OB11GroupIncreaseEvent(+msg.peerUid, +selfInfo.uin, +adminUin);
          }
        } else if (grayTipElement.subElementType === GrayTipElementSubType.XmlMsg) {
          const xmlElement = grayTipElement.xmlElement;
          if (xmlElement.templId === "10382") {
            ctx.logger.info("", xmlElement.templParam);
            return await GroupMsgEmojiLikeEvent.parse(ctx, xmlElement, msg.peerUid);
          } else if (xmlElement.templId == "10179") {
            ctx.logger.info(" templId: 10179", xmlElement);
            const invitor = xmlElement.templParam.get("invitor");
            const invitee = xmlElement.templParam.get("invitee");
            if (invitor && invitee) {
              return new OB11GroupIncreaseEvent(+msg.peerUid, +invitee, +invitor, "invite");
            }
          }
        }
      }
    }
  }
  OB11Entities2.groupEvent = groupEvent;
  async function recallEvent(ctx, msg, shortId) {
    const revokeElement = msg.elements[0].grayTipElement?.revokeElement;
    if (msg.chatType === ChatType.Group) {
      const operator = await ctx.ntGroupApi.getGroupMember(msg.peerUid, revokeElement.operatorUid);
      return new OB11GroupRecallNoticeEvent(
        parseInt(msg.peerUid),
        parseInt(msg.senderUin),
        parseInt(operator?.uin || msg.senderUin),
        shortId
      );
    } else {
      return new OB11FriendRecallNoticeEvent(parseInt(msg.senderUin), shortId);
    }
  }
  OB11Entities2.recallEvent = recallEvent;
  function friend(friend2) {
    return {
      user_id: parseInt(friend2.uin),
      nickname: friend2.nick,
      remark: friend2.remark,
      sex: sex(friend2.sex),
      level: friend2.qqLevel && calcQQLevel(friend2.qqLevel) || 0
    };
  }
  OB11Entities2.friend = friend;
  function friends(friends2) {
    return friends2.map(friend);
  }
  OB11Entities2.friends = friends;
  function friendV2(raw) {
    return {
      ...omit(raw.baseInfo, ["richBuffer", "phoneNum"]),
      ...omit(raw.coreInfo, ["nick"]),
      user_id: parseInt(raw.coreInfo.uin),
      nickname: raw.coreInfo.nick,
      remark: raw.coreInfo.remark || raw.coreInfo.nick,
      sex: sex(raw.baseInfo.sex),
      level: 0
    };
  }
  OB11Entities2.friendV2 = friendV2;
  function friendsV2(raw) {
    return raw.map(friendV2);
  }
  OB11Entities2.friendsV2 = friendsV2;
  function groupMemberRole(role) {
    return {
      4: OB11GroupMemberRole.Owner,
      3: OB11GroupMemberRole.Admin,
      2: OB11GroupMemberRole.Member
    }[role] ?? OB11GroupMemberRole.Member;
  }
  OB11Entities2.groupMemberRole = groupMemberRole;
  function sex(sex2) {
    const sexMap = {
      [Sex.Unknown]: OB11UserSex.Unknown,
      [Sex.Male]: OB11UserSex.Male,
      [Sex.Female]: OB11UserSex.Female,
      [Sex.Hidden]: OB11UserSex.Unknown
    };
    return sexMap[sex2] ?? OB11UserSex.Unknown;
  }
  OB11Entities2.sex = sex;
  function groupMember(groupId, member) {
    return {
      group_id: groupId,
      user_id: parseInt(member.uin),
      nickname: member.nick,
      card: member.cardName || member.nick,
      sex: OB11UserSex.Unknown,
      age: 0,
      area: "",
      level: String(member.memberRealLevel ?? 0),
      qq_level: 0,
      join_time: member.joinTime,
      last_sent_time: member.lastSpeakTime,
      title_expire_time: 0,
      unfriendly: false,
      card_changeable: true,
      is_robot: member.isRobot,
      shut_up_timestamp: member.shutUpTime,
      role: groupMemberRole(member.role),
      title: member.memberSpecialTitle
    };
  }
  OB11Entities2.groupMember = groupMember;
  function group(group2) {
    return {
      group_id: parseInt(group2.groupCode),
      group_name: group2.groupName,
      group_memo: "",
      group_create_time: +group2.createTime,
      member_count: group2.memberCount,
      max_member_count: group2.maxMember,
      remark_name: group2.remarkName
    };
  }
  OB11Entities2.group = group;
  function groups(groups2) {
    return groups2.map(group);
  }
  OB11Entities2.groups = groups;
})(OB11Entities || (OB11Entities = {}));
class OB11FriendRequestEvent extends OB11BaseNoticeEvent {
  post_type = EventType.REQUEST;
  user_id;
  request_type;
  comment;
  flag;
  constructor(userId, comment, flag, requestType = "friend") {
    super();
    this.user_id = userId;
    this.comment = comment;
    this.flag = flag;
    this.request_type = requestType;
  }
}
class OB11Response {
  static res(data, status, retcode, message = "") {
    return {
      status,
      retcode,
      data,
      message,
      wording: message,
      echo: void 0
    };
  }
  static ok(data, echo) {
    const res = OB11Response.res(data, "ok", 0);
    if (!isNullable(echo)) {
      res.echo = echo;
    }
    return res;
  }
  static error(err, retcode, echo) {
    const res = OB11Response.res(null, "failed", retcode, err);
    if (!isNullable(echo)) {
      res.echo = echo;
    }
    return res;
  }
}
class OB11BaseMetaEvent extends OB11BaseEvent {
  post_type = EventType.META;
}
var LifeCycleSubType = /* @__PURE__ */ ((LifeCycleSubType2) => {
  LifeCycleSubType2["ENABLE"] = "enable";
  LifeCycleSubType2["DISABLE"] = "disable";
  LifeCycleSubType2["CONNECT"] = "connect";
  return LifeCycleSubType2;
})(LifeCycleSubType || {});
class OB11LifeCycleEvent extends OB11BaseMetaEvent {
  meta_event_type = "lifecycle";
  sub_type;
  constructor(subType) {
    super();
    this.sub_type = subType;
  }
}
class OB11HeartbeatEvent extends OB11BaseMetaEvent {
  meta_event_type = "heartbeat";
  status;
  interval;
  constructor(isOnline, isGood, interval) {
    super();
    this.interval = interval;
    this.status = {
      online: isOnline,
      good: isGood
    };
  }
}
class OB11WebSocket {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
  }
  wsServer;
  wsClients = [];
  start() {
    if (this.wsServer) return;
    const host = this.config.listenLocalhost ? "127.0.0.1" : "";
    this.ctx.logger.info(`OneBot V11 WebSocket server started ${host}:${this.config.port}`);
    this.wsServer = new WebSocketServer({
      host,
      port: this.config.port,
      maxPayload: 1024 * 1024 * 1024
    });
    llonebotError.wsServerError = "";
    this.wsServer.on("error", (err) => {
      this.ctx.logger.error("OneBot V11  WS ", err);
    });
    this.wsServer?.on("connection", (socket, req) => {
      this.authorize(socket, req);
      this.connect(socket, req);
    });
  }
  stop() {
    return new Promise((resolve2) => {
      llonebotError.wsServerError = "";
      this.ctx.logger.info("OneBot V11 WebSocket Server closing...");
      this.wsClients.forEach(({ socket }) => {
        try {
          socket.close();
        } catch (e) {
          this.ctx.logger.error(" OneBot V11 WebSocket ", e);
        }
      });
      this.wsClients = [];
      if (this.wsServer) {
        this.wsServer.close((err) => {
          if (err) {
            this.ctx.logger.error(`OneBot V11 WebSocket Server closing ${err}`);
            return resolve2(false);
          }
          this.ctx.logger.info("OneBot V11 WebSocket Server closed");
          resolve2(true);
        });
        this.wsServer = void 0;
      } else {
        resolve2(true);
      }
    });
  }
  async emitEvent(event) {
    this.wsClients.forEach(({ socket, emitEvent }) => {
      if (emitEvent && socket.readyState === WebSocket$1.OPEN) {
        socket.send(JSON.stringify(event));
        const eventName = event.post_type + "." + event[event.post_type + "_type"];
        this.ctx.logger.info("WebSocket ", socket.url ?? "", eventName);
      }
    });
  }
  updateConfig(config) {
    Object.assign(this.config, config);
  }
  reply(socket, data) {
    if (socket.readyState !== WebSocket$1.OPEN) {
      return;
    }
    socket.send(JSON.stringify(data));
    if ("post_type" in data) {
      this.ctx.logger.info("WebSocket ", socket.url ?? "", data.post_type);
    }
  }
  authorize(socket, req) {
    const url = req.url?.split("?").shift();
    this.ctx.logger.info("ws connect", url);
    let clientToken = "";
    const authHeader = req.headers["authorization"];
    if (authHeader) {
      clientToken = authHeader.split("Bearer ").pop();
      this.ctx.logger.info("receive ws header token", clientToken);
    } else {
      const { searchParams } = new URL(`http://localhost${req.url}`);
      const urlToken = searchParams.get("access_token");
      if (urlToken) {
        if (Array.isArray(urlToken)) {
          clientToken = urlToken[0];
        } else {
          clientToken = urlToken;
        }
        this.ctx.logger.info("receive ws url token", clientToken);
      }
    }
    if (this.config.token && clientToken !== this.config.token) {
      this.reply(socket, OB11Response.res(null, "failed", 1403, "token"));
      return socket.close();
    }
  }
  async handleAction(socket, msg) {
    let receive = { action: null, params: {} };
    try {
      receive = JSON.parse(msg.toString());
      this.ctx.logger.info(" Websocket ", receive);
    } catch (e) {
      return this.reply(socket, OB11Response.error("json", 1400));
    }
    const action = this.config.actionMap.get(receive.action);
    if (!action) {
      return this.reply(socket, OB11Response.error("api " + receive.action, 1404, receive.echo));
    }
    const handleResult = await action.websocketHandle(receive.params, receive.echo);
    this.reply(socket, handleResult);
  }
  connect(socket, req) {
    const url = req.url?.split("?").shift();
    if (["/api", "/api/", "/", void 0].includes(url)) {
      socket.on("message", (msg) => {
        this.handleAction(socket, msg.toString());
      });
    }
    if (["/event", "/event/", "/", void 0].includes(url)) {
      try {
        this.reply(socket, new OB11LifeCycleEvent(LifeCycleSubType.CONNECT));
      } catch (e) {
        this.ctx.logger.error("", e);
      }
      const disposeHeartBeat = this.ctx.setInterval(() => {
        this.reply(socket, new OB11HeartbeatEvent(selfInfo.online, true, this.config.heartInterval));
      }, this.config.heartInterval);
      socket.on("close", () => {
        disposeHeartBeat();
        this.ctx.logger.info(" Websocket ");
      });
    }
    socket.on("error", (err) => this.ctx.logger.error(err.message));
    socket.on("ping", () => {
      socket.pong();
    });
    this.wsClients.push({
      socket,
      emitEvent: ["/event", "/event/", "/", void 0].includes(url)
    });
  }
}
class OB11WebSocketReverse {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
  }
  running = false;
  wsClient;
  start() {
    if (!this.running) {
      this.running = true;
      this.tryConnect();
    }
  }
  stop() {
    this.running = false;
    this.wsClient?.close();
  }
  emitEvent(event) {
    if (this.wsClient && this.wsClient.readyState === WebSocket$1.OPEN) {
      this.wsClient.send(JSON.stringify(event));
      const eventName = event.post_type + "." + event[event.post_type + "_type"];
      this.ctx.logger.info("WebSocket ", this.wsClient.url ?? "", eventName);
    }
  }
  reply(socket, data) {
    if (socket.readyState !== WebSocket$1.OPEN) {
      return;
    }
    socket.send(JSON.stringify(data));
    if ("post_type" in data) {
      this.ctx.logger.info("WebSocket ", socket.url ?? "", data.post_type);
    }
  }
  async handleAction(msg) {
    let receive = { action: null, params: {} };
    try {
      receive = JSON.parse(msg.toString());
      this.ctx.logger.info(" Websocket ", receive);
    } catch (e) {
      return this.reply(this.wsClient, OB11Response.error("json", 1400, receive.echo));
    }
    const action = this.config.actionMap.get(receive.action);
    if (!action) {
      return this.reply(this.wsClient, OB11Response.error("api " + receive.action, 1404, receive.echo));
    }
    const handleResult = await action.websocketHandle(receive.params, receive.echo);
    this.reply(this.wsClient, handleResult);
  }
  tryConnect() {
    if (this.wsClient && !this.running) {
      return;
    }
    this.wsClient = new WebSocket$1(this.config.url, {
      maxPayload: 1024 * 1024 * 1024,
      handshakeTimeout: 2e3,
      perMessageDeflate: false,
      headers: {
        "X-Self-ID": selfInfo.uin,
        "Authorization": `Bearer ${this.config.token}`,
        "x-client-role": "Universal",
        // koishi-adapter-onebot 
        "User-Agent": `LLOneBot/${version}`
      }
    });
    this.ctx.logger.info("Trying to connect to the websocket server: " + this.config.url);
    this.wsClient.on("open", () => {
      this.ctx.logger.info("Connected to the websocket server: " + this.config.url);
      try {
        this.reply(this.wsClient, new OB11LifeCycleEvent(LifeCycleSubType.CONNECT));
      } catch (e) {
        this.ctx.logger.error("", e);
      }
    });
    this.wsClient.on("error", (err) => this.ctx.logger.error(err));
    this.wsClient.on("message", (data) => {
      this.handleAction(data.toString());
    });
    this.wsClient.on("ping", () => {
      this.wsClient?.pong();
    });
    const disposeHeartBeat = this.ctx.setInterval(() => {
      if (this.wsClient) {
        this.reply(this.wsClient, new OB11HeartbeatEvent(selfInfo.online, true, this.config.heartInterval));
      }
    }, this.config.heartInterval);
    this.wsClient.on("close", () => {
      disposeHeartBeat();
      this.ctx.logger.info(`The websocket connection: ${this.config.url} closed${this.running ? ", trying reconnecting..." : ""}`);
      if (this.running) {
        this.ctx.setTimeout(() => this.tryConnect(), 3e3);
      }
    });
  }
}
class OB11WebSocketReverseManager {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
  }
  list = [];
  async start() {
    if (this.list.length > 0) {
      return;
    }
    for (const url of this.config.hosts) {
      const ws = new OB11WebSocketReverse(this.ctx, { ...this.config, url });
      ws.start();
      this.list.push(ws);
    }
  }
  stop() {
    for (const ws of this.list) {
      try {
        ws.stop();
      } catch (e) {
        this.ctx.logger.error(" WebSocket :", e.stack);
      }
    }
    this.list.length = 0;
  }
  async emitEvent(event) {
    for (const ws of this.list) {
      ws.emitEvent(event);
    }
  }
  updateConfig(config) {
    Object.assign(this.config, config);
  }
}
var lib$3 = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign) return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target, source2) {
    var from2;
    var to = toObject(target);
    var symbols2;
    for (var s = 1; s < arguments.length; s++) {
      from2 = Object(arguments[s]);
      for (var key2 in from2) {
        if (hasOwnProperty.call(from2, key2)) {
          to[key2] = from2[key2];
        }
      }
      if (getOwnPropertySymbols) {
        symbols2 = getOwnPropertySymbols(from2);
        for (var i = 0; i < symbols2.length; i++) {
          if (propIsEnumerable.call(from2, symbols2[i])) {
            to[symbols2[i]] = from2[symbols2[i]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
var vary = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredVary;
function requireVary() {
  if (hasRequiredVary) return vary.exports;
  hasRequiredVary = 1;
  vary.exports = vary$1;
  vary.exports.append = append;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  function append(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse3(String(field)) : field;
    for (var j = 0; j < fields.length; j++) {
      if (!FIELD_NAME_REGEXP.test(fields[j])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val = header;
    var vals = parse3(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i = 0; i < fields.length; i++) {
      var fld = fields[i].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ", " + fields[i] : fields[i];
      }
    }
    return val;
  }
  function parse3(header) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = header.length; i < len; i++) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(header.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(header.substring(start, end));
    return list;
  }
  function vary$1(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val = res.getHeader("Vary") || "";
    var header = Array.isArray(val) ? val.join(", ") : String(val);
    if (val = append(header, field)) {
      res.setHeader("Vary", val);
    }
  }
  return vary.exports;
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$3.exports;
  hasRequiredLib$2 = 1;
  (function() {
    var assign = requireObjectAssign();
    var vary2 = requireVary();
    var defaults = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: false,
      optionsSuccessStatus: 204
    };
    function isString(s) {
      return typeof s === "string" || s instanceof String;
    }
    function isOriginAllowed(origin, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (var i = 0; i < allowedOrigin.length; ++i) {
          if (isOriginAllowed(origin, allowedOrigin[i])) {
            return true;
          }
        }
        return false;
      } else if (isString(allowedOrigin)) {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      } else {
        return !!allowedOrigin;
      }
    }
    function configureOrigin(options, req) {
      var requestOrigin = req.headers.origin, headers = [], isAllowed;
      if (!options.origin || options.origin === "*") {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: "*"
        }]);
      } else if (isString(options.origin)) {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: options.origin
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      } else {
        isAllowed = isOriginAllowed(requestOrigin, options.origin);
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: isAllowed ? requestOrigin : false
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      }
      return headers;
    }
    function configureMethods(options) {
      var methods2 = options.methods;
      if (methods2.join) {
        methods2 = options.methods.join(",");
      }
      return {
        key: "Access-Control-Allow-Methods",
        value: methods2
      };
    }
    function configureCredentials(options) {
      if (options.credentials === true) {
        return {
          key: "Access-Control-Allow-Credentials",
          value: "true"
        };
      }
      return null;
    }
    function configureAllowedHeaders(options, req) {
      var allowedHeaders = options.allowedHeaders || options.headers;
      var headers = [];
      if (!allowedHeaders) {
        allowedHeaders = req.headers["access-control-request-headers"];
        headers.push([{
          key: "Vary",
          value: "Access-Control-Request-Headers"
        }]);
      } else if (allowedHeaders.join) {
        allowedHeaders = allowedHeaders.join(",");
      }
      if (allowedHeaders && allowedHeaders.length) {
        headers.push([{
          key: "Access-Control-Allow-Headers",
          value: allowedHeaders
        }]);
      }
      return headers;
    }
    function configureExposedHeaders(options) {
      var headers = options.exposedHeaders;
      if (!headers) {
        return null;
      } else if (headers.join) {
        headers = headers.join(",");
      }
      if (headers && headers.length) {
        return {
          key: "Access-Control-Expose-Headers",
          value: headers
        };
      }
      return null;
    }
    function configureMaxAge(options) {
      var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
      if (maxAge && maxAge.length) {
        return {
          key: "Access-Control-Max-Age",
          value: maxAge
        };
      }
      return null;
    }
    function applyHeaders(headers, res) {
      for (var i = 0, n = headers.length; i < n; i++) {
        var header = headers[i];
        if (header) {
          if (Array.isArray(header)) {
            applyHeaders(header, res);
          } else if (header.key === "Vary" && header.value) {
            vary2(res, header.value);
          } else if (header.value) {
            res.setHeader(header.key, header.value);
          }
        }
      }
    }
    function cors2(options, req, res, next) {
      var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
      if (method === "OPTIONS") {
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options));
        headers.push(configureMethods(options));
        headers.push(configureAllowedHeaders(options, req));
        headers.push(configureMaxAge(options));
        headers.push(configureExposedHeaders(options));
        applyHeaders(headers, res);
        if (options.preflightContinue) {
          next();
        } else {
          res.statusCode = options.optionsSuccessStatus;
          res.setHeader("Content-Length", "0");
          res.end();
        }
      } else {
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options));
        headers.push(configureExposedHeaders(options));
        applyHeaders(headers, res);
        next();
      }
    }
    function middlewareWrapper(o) {
      var optionsCallback = null;
      if (typeof o === "function") {
        optionsCallback = o;
      } else {
        optionsCallback = function(req, cb) {
          cb(null, o);
        };
      }
      return function corsMiddleware(req, res, next) {
        optionsCallback(req, function(err, options) {
          if (err) {
            next(err);
          } else {
            var corsOptions = assign({}, defaults, options);
            var originCallback = null;
            if (corsOptions.origin && typeof corsOptions.origin === "function") {
              originCallback = corsOptions.origin;
            } else if (corsOptions.origin) {
              originCallback = function(origin, cb) {
                cb(null, corsOptions.origin);
              };
            }
            if (originCallback) {
              originCallback(req.headers.origin, function(err2, origin) {
                if (err2 || !origin) {
                  next(err2);
                } else {
                  corsOptions.origin = origin;
                  cors2(corsOptions, req, res, next);
                }
              });
            } else {
              next();
            }
          }
        });
      };
    }
    lib$3.exports = middlewareWrapper;
  })();
  return lib$3.exports;
}
var libExports = requireLib$2();
const cors = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
var express$2 = { exports: {} };
var bodyParser = { exports: {} };
var httpErrors = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = depd;
  function depd(namespace) {
    if (!namespace) {
      throw new TypeError("argument namespace is required");
    }
    function deprecate(message) {
    }
    deprecate._file = void 0;
    deprecate._ignored = true;
    deprecate._namespace = namespace;
    deprecate._traced = false;
    deprecate._warned = /* @__PURE__ */ Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
  }
  function wrapfunction(fn, message) {
    if (typeof fn !== "function") {
      throw new TypeError("argument fn must be a function");
    }
    return fn;
  }
  function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("argument obj must be object");
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
      throw new TypeError("must call property on owner object");
    }
    if (!descriptor.configurable) {
      throw new TypeError("property must be configurable");
    }
  }
  return browser;
}
var setprototypeof;
var hasRequiredSetprototypeof;
function requireSetprototypeof() {
  if (hasRequiredSetprototypeof) return setprototypeof;
  hasRequiredSetprototypeof = 1;
  setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }
  return setprototypeof;
}
const require$$0$3 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var statuses$1;
var hasRequiredStatuses$1;
function requireStatuses$1() {
  if (hasRequiredStatuses$1) return statuses$1;
  hasRequiredStatuses$1 = 1;
  var codes = require$$0$3;
  statuses$1 = status;
  status.message = codes;
  status.code = createMessageToStatusCodeMap(codes);
  status.codes = createStatusCodeList(codes);
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };
  status.empty = {
    204: true,
    205: true,
    304: true
  };
  status.retry = {
    502: true,
    503: true,
    504: true
  };
  function createMessageToStatusCodeMap(codes2) {
    var map = {};
    Object.keys(codes2).forEach(function forEachCode(code) {
      var message = codes2[code];
      var status2 = Number(code);
      map[message.toLowerCase()] = status2;
    });
    return map;
  }
  function createStatusCodeList(codes2) {
    return Object.keys(codes2).map(function mapCode(code) {
      return Number(code);
    });
  }
  function getStatusCode(message) {
    var msg = message.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
      throw new Error('invalid status message: "' + message + '"');
    }
    return status.code[msg];
  }
  function getStatusMessage(code) {
    if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
      throw new Error("invalid status code: " + code);
    }
    return status.message[code];
  }
  function status(code) {
    if (typeof code === "number") {
      return getStatusMessage(code);
    }
    if (typeof code !== "string") {
      throw new TypeError("code must be a number or string");
    }
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      return getStatusMessage(n);
    }
    return getStatusCode(code);
  }
  return statuses$1;
}
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier;
var hasRequiredToidentifier;
function requireToidentifier() {
  if (hasRequiredToidentifier) return toidentifier;
  hasRequiredToidentifier = 1;
  toidentifier = toIdentifier;
  function toIdentifier(str) {
    return str.split(" ").map(function(token2) {
      return token2.slice(0, 1).toUpperCase() + token2.slice(1);
    }).join("").replace(/[^ _0-9a-z]/gi, "");
  }
  return toidentifier;
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredHttpErrors;
function requireHttpErrors() {
  if (hasRequiredHttpErrors) return httpErrors.exports;
  hasRequiredHttpErrors = 1;
  (function(module) {
    var deprecate = requireBrowser()("http-errors");
    var setPrototypeOf = requireSetprototypeof();
    var statuses2 = requireStatuses$1();
    var inherits = requireInherits_browser();
    var toIdentifier = requireToidentifier();
    module.exports = createError;
    module.exports.HttpError = createHttpErrorConstructor();
    module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
    populateConstructorExports(module.exports, statuses2.codes, module.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        var type2 = typeof arg;
        if (type2 === "object" && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type2 === "number" && i === 0) {
          status = arg;
        } else if (type2 === "string") {
          msg = arg;
        } else if (type2 === "object") {
          props = arg;
        } else {
          throw new TypeError("argument #" + (i + 1) + " unsupported type " + type2);
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses2.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses2.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key2 in props) {
        if (key2 !== "status" && key2 !== "statusCode") {
          err[key2] = props[key2];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ClientError(message) {
        var msg = message != null ? message : statuses2.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== "object") {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
      };
    }
    function createServerErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ServerError(message) {
        var msg = message != null ? message : statuses2.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses2.message[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          exports[code] = CodeError;
          exports[name] = CodeError;
        }
      });
    }
    function toClassName(name) {
      return name.substr(-5) !== "Error" ? name + "Error" : name;
    }
  })(httpErrors);
  return httpErrors.exports;
}
var onFinished = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var eeFirst;
var hasRequiredEeFirst;
function requireEeFirst() {
  if (hasRequiredEeFirst) return eeFirst;
  hasRequiredEeFirst = 1;
  eeFirst = first;
  function first(stuff, done) {
    if (!Array.isArray(stuff))
      throw new TypeError("arg must be an array of [ee, events...] arrays");
    var cleanups = [];
    for (var i = 0; i < stuff.length; i++) {
      var arr = stuff[i];
      if (!Array.isArray(arr) || arr.length < 2)
        throw new TypeError("each array member must be [ee, events...]");
      var ee = arr[0];
      for (var j = 1; j < arr.length; j++) {
        var event = arr[j];
        var fn = listener(event, callback);
        ee.on(event, fn);
        cleanups.push({
          ee,
          event,
          fn
        });
      }
    }
    function callback() {
      cleanup();
      done.apply(null, arguments);
    }
    function cleanup() {
      var x;
      for (var i2 = 0; i2 < cleanups.length; i2++) {
        x = cleanups[i2];
        x.ee.removeListener(x.event, x.fn);
      }
    }
    function thunk(fn2) {
      done = fn2;
    }
    thunk.cancel = cleanup;
    return thunk;
  }
  function listener(event, done) {
    return function onevent(arg1) {
      var args = new Array(arguments.length);
      var ee = this;
      var err = event === "error" ? arg1 : null;
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      done(err, ee, event, args);
    };
  }
  return eeFirst;
}
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredOnFinished;
function requireOnFinished() {
  if (hasRequiredOnFinished) return onFinished.exports;
  hasRequiredOnFinished = 1;
  onFinished.exports = onFinished$1;
  onFinished.exports.isFinished = isFinished;
  var asyncHooks = tryRequireAsyncHooks();
  var first = requireEeFirst();
  var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };
  function onFinished$1(msg, listener) {
    if (isFinished(msg) !== false) {
      defer(listener, null, msg);
      return msg;
    }
    attachListener(msg, wrap(listener));
    return msg;
  }
  function isFinished(msg) {
    var socket = msg.socket;
    if (typeof msg.finished === "boolean") {
      return Boolean(msg.finished || socket && !socket.writable);
    }
    if (typeof msg.complete === "boolean") {
      return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
    }
    return void 0;
  }
  function attachFinishedListener(msg, callback) {
    var eeMsg;
    var eeSocket;
    var finished = false;
    function onFinish(error) {
      eeMsg.cancel();
      eeSocket.cancel();
      finished = true;
      callback(error);
    }
    eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
    function onSocket(socket) {
      msg.removeListener("socket", onSocket);
      if (finished) return;
      if (eeMsg !== eeSocket) return;
      eeSocket = first([[socket, "error", "close"]], onFinish);
    }
    if (msg.socket) {
      onSocket(msg.socket);
      return;
    }
    msg.on("socket", onSocket);
    if (msg.socket === void 0) {
      patchAssignSocket(msg, onSocket);
    }
  }
  function attachListener(msg, listener) {
    var attached = msg.__onFinished;
    if (!attached || !attached.queue) {
      attached = msg.__onFinished = createListener(msg);
      attachFinishedListener(msg, attached);
    }
    attached.queue.push(listener);
  }
  function createListener(msg) {
    function listener(err) {
      if (msg.__onFinished === listener) msg.__onFinished = null;
      if (!listener.queue) return;
      var queue2 = listener.queue;
      listener.queue = null;
      for (var i = 0; i < queue2.length; i++) {
        queue2[i](err, msg);
      }
    }
    listener.queue = [];
    return listener;
  }
  function patchAssignSocket(res, callback) {
    var assignSocket = res.assignSocket;
    if (typeof assignSocket !== "function") return;
    res.assignSocket = function _assignSocket(socket) {
      assignSocket.call(this, socket);
      callback(socket);
    };
  }
  function tryRequireAsyncHooks() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return onFinished.exports;
}
var bytes = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes) return bytes.exports;
  hasRequiredBytes = 1;
  bytes.exports = bytes$1;
  bytes.exports.format = format;
  bytes.exports.parse = parse3;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes$1(value, options) {
    if (typeof value === "string") {
      return parse3(value);
    }
    if (typeof value === "number") {
      return format(value, options);
    }
    return null;
  }
  function format(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map[unit.toLowerCase()]) {
      if (mag >= map.pb) {
        unit = "PB";
      } else if (mag >= map.tb) {
        unit = "TB";
      } else if (mag >= map.gb) {
        unit = "GB";
      } else if (mag >= map.mb) {
        unit = "MB";
      } else if (mag >= map.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.split(".").map(function(s, i) {
        return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
      }).join(".");
    }
    return str + unitSeparator + unit;
  }
  function parse3(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map[unit] * floatValue);
  }
  return bytes.exports;
}
var lib$2 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer2 = require$$0$7;
  var Buffer2 = buffer2.Buffer;
  var safer = {};
  var key2;
  for (key2 in buffer2) {
    if (!buffer2.hasOwnProperty(key2)) continue;
    if (key2 === "SlowBuffer" || key2 === "Buffer") continue;
    safer[key2] = buffer2[key2];
  }
  var Safer = safer.Buffer = {};
  for (key2 in Buffer2) {
    if (!Buffer2.hasOwnProperty(key2)) continue;
    if (key2 === "allocUnsafe" || key2 === "allocUnsafeSlow") continue;
    Safer[key2] = Buffer2[key2];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding2 === "string") {
        buf.fill(fill, encoding2);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder2, options) {
    this.decoder = decoder2;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling;
}
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$4.StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
  return internal;
}
var utf32 = {};
var hasRequiredUtf32;
function requireUtf32() {
  if (hasRequiredUtf32) return utf32;
  hasRequiredUtf32 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf32._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32.utf32le = { type: "_utf32", isLE: true };
  utf32.utf32be = { type: "_utf32", isLE: false };
  utf32.ucs4le = "utf32le";
  utf32.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str) {
    var src = Buffer2.from(str, "ucs2");
    var dst = Buffer2.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src.length; i += 2) {
      var code = src.readUInt16LE(i);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0)
      return "";
    var i = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i < src.length && overflow.length < 4; i++)
        overflow.push(src[i]);
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (; i < src.length - 3; i += 4) {
      if (isLE) {
        codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
      } else {
        codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (; i < src.length; i++) {
      overflow.push(src[i]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  utf32.utf32 = Utf32AutoCodec;
  utf32.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        return "";
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;
    var bmpCharsLE = 0, bmpCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 4) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                return "utf-32le";
              }
              if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                return "utf-32be";
              }
            }
            if (b[0] !== 0 || b[1] > 16) invalidBE++;
            if (b[3] !== 0 || b[2] > 16) invalidLE++;
            if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
            if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
  return utf32;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        return "";
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 2) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254) return "utf-16le";
              if (b[0] === 254 && b[1] === 255) return "utf-16be";
            }
            if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
            if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE) return "utf-16be";
    if (asciiCharsBE < asciiCharsLE) return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0; i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp720": {
      "type": "_sbcs",
      "chars": ""
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j = 48; j <= 57; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 129; k <= 254; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 48; l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED)
                fourthByteNode[l] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes2 = [];
    for (; addr > 0; addr >>>= 8)
      bytes2.push(addr & 255);
    if (bytes2.length == 0)
      bytes2.push(0);
    var node = this.decodeTables[0];
    for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
      var val = node[bytes2[i2]];
      if (val == UNASSIGNED) {
        node[bytes2[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0; m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== void 0)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
            hasValues = true;
          else
            subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length) break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 255;
        newBuf[j++] = dbcsCode >>> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0)
        ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0$2 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
];
const require$$1 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]');
const require$$2 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]');
const require$$3 = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ],
  [
    "8135f437",
    ""
  ]
];
const uChars = [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536];
const gbChars = [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]');
const require$$6 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]');
const require$$7 = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0$2;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [
        // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
        // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
        // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports) {
    var modules = [
      requireInternal(),
      requireUtf32(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = requireSafer().Buffer;
  streams = function(stream_module) {
    var Transform = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding2, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding2, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
  return streams;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$2.exports;
  hasRequiredLib$1 = 1;
  (function(module) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling(), iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode2(str, encoding2, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding2, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode2(buf, encoding2, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder2 = iconv.getDecoder(encoding2, options);
      var res = decoder2.write(buf);
      var trail = decoder2.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding2) {
      if (!iconv.encodings)
        iconv.encodings = requireEncodings();
      var enc = iconv._canonicalizeEncoding(encoding2);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key2 in codecDef)
              codecOptions[key2] = codecDef[key2];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding2 + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding2) {
      return ("" + encoding2).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding2, options) {
      var codec = iconv.getCodec(encoding2), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling2.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding2, options) {
      var codec = iconv.getCodec(encoding2), decoder2 = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder2 = new bomHandling2.StripBOM(decoder2, options);
      return decoder2;
    };
    iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
      if (iconv.supportsStreams)
        return;
      var streams2 = requireStreams()(stream_module2);
      iconv.IconvLiteEncoderStream = streams2.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams2.IconvLiteDecoderStream;
      iconv.encodeStream = function encodeStream(encoding2, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding2, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding2, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding2, options), options);
      };
      iconv.supportsStreams = true;
    };
    var stream_module;
    try {
      stream_module = require("stream");
    } catch (e) {
    }
    if (stream_module && stream_module.Transform) {
      iconv.enableStreamingAPI(stream_module);
    } else {
      iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
  })(lib$2);
  return lib$2.exports;
}
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var unpipe_1;
var hasRequiredUnpipe;
function requireUnpipe() {
  if (hasRequiredUnpipe) return unpipe_1;
  hasRequiredUnpipe = 1;
  unpipe_1 = unpipe;
  function hasPipeDataListeners(stream) {
    var listeners = stream.listeners("data");
    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i].name === "ondata") {
        return true;
      }
    }
    return false;
  }
  function unpipe(stream) {
    if (!stream) {
      throw new TypeError("argument stream is required");
    }
    if (typeof stream.unpipe === "function") {
      stream.unpipe();
      return;
    }
    if (!hasPipeDataListeners(stream)) {
      return;
    }
    var listener;
    var listeners = stream.listeners("close");
    for (var i = 0; i < listeners.length; i++) {
      listener = listeners[i];
      if (listener.name !== "cleanup" && listener.name !== "onclose") {
        continue;
      }
      listener.call(stream);
    }
  }
  return unpipe_1;
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var rawBody;
var hasRequiredRawBody;
function requireRawBody() {
  if (hasRequiredRawBody) return rawBody;
  hasRequiredRawBody = 1;
  var asyncHooks = tryRequireAsyncHooks();
  var bytes2 = requireBytes();
  var createError = requireHttpErrors();
  var iconv = requireLib$1();
  var unpipe = requireUnpipe();
  rawBody = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder(encoding2) {
    if (!encoding2) return null;
    try {
      return iconv.getDecoder(encoding2);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
      throw createError(415, "specified encoding unsupported", {
        encoding: encoding2,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream, options, callback) {
    var done = callback;
    var opts = options || {};
    if (stream === void 0) {
      throw new TypeError("argument stream is required");
    } else if (typeof stream !== "object" || stream === null || typeof stream.on !== "function") {
      throw new TypeError("argument stream must be a stream");
    }
    if (options === true || typeof options === "string") {
      opts = {
        encoding: options
      };
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (done !== void 0 && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !commonjsGlobal.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding2 = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit = bytes2.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream(stream, encoding2, length, limit, wrap(done));
    }
    return new Promise(function executor(resolve2, reject) {
      readStream(stream, encoding2, length, limit, function onRead(err, buf) {
        if (err) return reject(err);
        resolve2(buf);
      });
    });
  }
  function halt(stream) {
    unpipe(stream);
    if (typeof stream.pause === "function") {
      stream.pause();
    }
  }
  function readStream(stream, encoding2, length, limit, callback) {
    var complete = false;
    var sync = true;
    if (limit !== null && length !== null && length > limit) {
      return done(createError(413, "request entity too large", {
        expected: length,
        length,
        limit,
        type: "entity.too.large"
      }));
    }
    var state = stream._readableState;
    if (stream._decoder || state && (state.encoding || state.decoder)) {
      return done(createError(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    if (typeof stream.readable !== "undefined" && !stream.readable) {
      return done(createError(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    }
    var received = 0;
    var decoder2;
    try {
      decoder2 = getDecoder(encoding2);
    } catch (err) {
      return done(err);
    }
    var buffer2 = decoder2 ? "" : [];
    stream.on("aborted", onAborted);
    stream.on("close", cleanup);
    stream.on("data", onData);
    stream.on("end", onEnd);
    stream.on("error", onEnd);
    sync = false;
    function done() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args[0]) {
          halt(stream);
        }
        callback.apply(null, args);
      }
    }
    function onAborted() {
      if (complete) return;
      done(createError(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete) return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done(createError(413, "request entity too large", {
          limit,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder2) {
        buffer2 += decoder2.write(chunk);
      } else {
        buffer2.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete) return;
      if (err) return done(err);
      if (length !== null && received !== length) {
        done(createError(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string = decoder2 ? buffer2 + (decoder2.end() || "") : Buffer.concat(buffer2);
        done(null, string);
      }
    }
    function cleanup() {
      buffer2 = null;
      stream.removeListener("aborted", onAborted);
      stream.removeListener("data", onData);
      stream.removeListener("end", onEnd);
      stream.removeListener("error", onEnd);
      stream.removeListener("close", cleanup);
    }
  }
  function tryRequireAsyncHooks() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return rawBody;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var read_1;
var hasRequiredRead;
function requireRead() {
  if (hasRequiredRead) return read_1;
  hasRequiredRead = 1;
  var createError = requireHttpErrors();
  var getBody = requireRawBody();
  var iconv = requireLib$1();
  var onFinished2 = requireOnFinished();
  var zlib = require$$4$1;
  read_1 = read2;
  function read2(req, res, next, parse3, debug, options) {
    var length;
    var opts = options;
    var stream;
    var encoding2 = opts.encoding !== null ? opts.encoding : null;
    var verify = opts.verify;
    try {
      stream = contentstream(req, debug, opts.inflate);
      length = stream.length;
      stream.length = void 0;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding2;
    if (opts.encoding === null && encoding2 !== null && !iconv.encodingExists(encoding2)) {
      return next(createError(415, 'unsupported charset "' + encoding2.toUpperCase() + '"', {
        charset: encoding2.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug("read body");
    getBody(stream, opts, function(error, body) {
      if (error) {
        var _error;
        if (error.type === "encoding.unsupported") {
          _error = createError(415, 'unsupported charset "' + encoding2.toUpperCase() + '"', {
            charset: encoding2.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError(400, error);
        }
        if (stream !== req) {
          req.unpipe();
          stream.destroy();
        }
        dump(req, function onfinished() {
          next(createError(400, _error));
        });
        return;
      }
      if (verify) {
        try {
          debug("verify body");
          verify(req, res, body, encoding2);
        } catch (err) {
          next(createError(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str = body;
      try {
        debug("parse body");
        str = typeof body !== "string" && encoding2 !== null ? iconv.decode(body, encoding2) : body;
        req.body = parse3(str, encoding2);
      } catch (err) {
        next(createError(400, err, {
          body: str,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req, debug, inflate) {
    var encoding2 = (req.headers["content-encoding"] || "identity").toLowerCase();
    var length = req.headers["content-length"];
    debug('content-encoding "%s"', encoding2);
    if (inflate === false && encoding2 !== "identity") {
      throw createError(415, "content encoding unsupported", {
        encoding: encoding2,
        type: "encoding.unsupported"
      });
    }
    if (encoding2 === "identity") {
      req.length = length;
      return req;
    }
    var stream = createDecompressionStream(encoding2, debug);
    req.pipe(stream);
    return stream;
  }
  function createDecompressionStream(encoding2, debug) {
    switch (encoding2) {
      case "deflate":
        debug("inflate body");
        return zlib.createInflate();
      case "gzip":
        debug("gunzip body");
        return zlib.createGunzip();
      case "br":
        debug("brotli decompress body");
        return zlib.createBrotliDecompress();
      default:
        throw createError(415, 'unsupported content encoding "' + encoding2 + '"', {
          encoding: encoding2,
          type: "encoding.unsupported"
        });
    }
  }
  function dump(req, callback) {
    if (onFinished2.isFinished(req)) {
      callback(null);
    } else {
      onFinished2(req, callback);
      req.resume();
    }
  }
  return read_1;
}
var typeIs = { exports: {} };
var contentType = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredContentType;
function requireContentType() {
  if (hasRequiredContentType) return contentType;
  hasRequiredContentType = 1;
  var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
  var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  contentType.format = format;
  contentType.parse = parse3;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var type2 = obj.type;
    if (!type2 || !TYPE_REGEXP.test(type2)) {
      throw new TypeError("invalid type");
    }
    var string = type2;
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        if (!TOKEN_REGEXP.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string;
  }
  function parse3(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    var header = typeof string === "object" ? getcontenttype(string) : string;
    if (typeof header !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index = header.indexOf(";");
    var type2 = index !== -1 ? header.slice(0, index).trim() : header.trim();
    if (!TYPE_REGEXP.test(type2)) {
      throw new TypeError("invalid media type");
    }
    var obj = new ContentType(type2.toLowerCase());
    if (index !== -1) {
      var key2;
      var match;
      var value;
      PARAM_REGEXP.lastIndex = index;
      while (match = PARAM_REGEXP.exec(header)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key2 = match[1].toLowerCase();
        value = match[2];
        if (value.charCodeAt(0) === 34) {
          value = value.slice(1, -1);
          if (value.indexOf("\\") !== -1) {
            value = value.replace(QESC_REGEXP, "$1");
          }
        }
        obj.parameters[key2] = value;
      }
      if (index !== header.length) {
        throw new TypeError("invalid parameter format");
      }
    }
    return obj;
  }
  function getcontenttype(obj) {
    var header;
    if (typeof obj.getHeader === "function") {
      header = obj.getHeader("content-type");
    } else if (typeof obj.headers === "object") {
      header = obj.headers && obj.headers["content-type"];
    }
    if (typeof header !== "string") {
      throw new TypeError("content-type header is missing from object");
    }
    return header;
  }
  function qstring(val) {
    var str = String(val);
    if (TOKEN_REGEXP.test(str)) {
      return str;
    }
    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ContentType(type2) {
    this.parameters = /* @__PURE__ */ Object.create(null);
    this.type = type2;
  }
  return contentType;
}
var mimeTypes = {};
const require$$0$1 = {
  "application/1d-interleaved-parityfec": { "source": "iana" },
  "application/3gpdash-qoe-report+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/3gpp-ims+xml": { "source": "iana", "compressible": true },
  "application/3gpphal+json": { "source": "iana", "compressible": true },
  "application/3gpphalforms+json": { "source": "iana", "compressible": true },
  "application/a2l": { "source": "iana" },
  "application/ace+cbor": { "source": "iana" },
  "application/ace+json": { "source": "iana", "compressible": true },
  "application/ace-groupcomm+cbor": { "source": "iana" },
  "application/ace-trl+cbor": { "source": "iana" },
  "application/activemessage": { "source": "iana" },
  "application/activity+json": { "source": "iana", "compressible": true },
  "application/aif+cbor": { "source": "iana" },
  "application/aif+json": { "source": "iana", "compressible": true },
  "application/alto-cdni+json": { "source": "iana", "compressible": true },
  "application/alto-cdnifilter+json": { "source": "iana", "compressible": true },
  "application/alto-costmap+json": { "source": "iana", "compressible": true },
  "application/alto-costmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-directory+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcost+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true },
  "application/alto-endpointprop+json": { "source": "iana", "compressible": true },
  "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true },
  "application/alto-error+json": { "source": "iana", "compressible": true },
  "application/alto-networkmap+json": { "source": "iana", "compressible": true },
  "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-propmap+json": { "source": "iana", "compressible": true },
  "application/alto-propmapparams+json": { "source": "iana", "compressible": true },
  "application/alto-tips+json": { "source": "iana", "compressible": true },
  "application/alto-tipsparams+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamcontrol+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamparams+json": { "source": "iana", "compressible": true },
  "application/aml": { "source": "iana" },
  "application/andrew-inset": { "source": "iana", "extensions": ["ez"] },
  "application/appinstaller": { "compressible": false, "extensions": ["appinstaller"] },
  "application/applefile": { "source": "iana" },
  "application/applixware": { "source": "apache", "extensions": ["aw"] },
  "application/appx": { "compressible": false, "extensions": ["appx"] },
  "application/appxbundle": { "compressible": false, "extensions": ["appxbundle"] },
  "application/at+jwt": { "source": "iana" },
  "application/atf": { "source": "iana" },
  "application/atfx": { "source": "iana" },
  "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] },
  "application/atomcat+xml": { "source": "iana", "compressible": true, "extensions": ["atomcat"] },
  "application/atomdeleted+xml": { "source": "iana", "compressible": true, "extensions": ["atomdeleted"] },
  "application/atomicmail": { "source": "iana" },
  "application/atomsvc+xml": { "source": "iana", "compressible": true, "extensions": ["atomsvc"] },
  "application/atsc-dwd+xml": { "source": "iana", "compressible": true, "extensions": ["dwd"] },
  "application/atsc-dynamic-event-message": { "source": "iana" },
  "application/atsc-held+xml": { "source": "iana", "compressible": true, "extensions": ["held"] },
  "application/atsc-rdt+json": { "source": "iana", "compressible": true },
  "application/atsc-rsat+xml": { "source": "iana", "compressible": true, "extensions": ["rsat"] },
  "application/atxml": { "source": "iana" },
  "application/auth-policy+xml": { "source": "iana", "compressible": true },
  "application/automationml-aml+xml": { "source": "iana", "compressible": true, "extensions": ["aml"] },
  "application/automationml-amlx+zip": { "source": "iana", "compressible": false, "extensions": ["amlx"] },
  "application/bacnet-xdd+zip": { "source": "iana", "compressible": false },
  "application/batch-smtp": { "source": "iana" },
  "application/bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/beep+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/bufr": { "source": "iana" },
  "application/c2pa": { "source": "iana" },
  "application/calendar+json": { "source": "iana", "compressible": true },
  "application/calendar+xml": { "source": "iana", "compressible": true, "extensions": ["xcs"] },
  "application/call-completion": { "source": "iana" },
  "application/cals-1840": { "source": "iana" },
  "application/captive+json": { "source": "iana", "compressible": true },
  "application/cbor": { "source": "iana" },
  "application/cbor-seq": { "source": "iana" },
  "application/cccex": { "source": "iana" },
  "application/ccmp+xml": { "source": "iana", "compressible": true },
  "application/ccxml+xml": { "source": "iana", "compressible": true, "extensions": ["ccxml"] },
  "application/cda+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/cdfx+xml": { "source": "iana", "compressible": true, "extensions": ["cdfx"] },
  "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] },
  "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] },
  "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] },
  "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] },
  "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] },
  "application/cdni": { "source": "iana" },
  "application/ce+cbor": { "source": "iana" },
  "application/cea": { "source": "iana" },
  "application/cea-2018+xml": { "source": "iana", "compressible": true },
  "application/cellml+xml": { "source": "iana", "compressible": true },
  "application/cfw": { "source": "iana" },
  "application/cid-edhoc+cbor-seq": { "source": "iana" },
  "application/city+json": { "source": "iana", "compressible": true },
  "application/city+json-seq": { "source": "iana" },
  "application/clr": { "source": "iana" },
  "application/clue+xml": { "source": "iana", "compressible": true },
  "application/clue_info+xml": { "source": "iana", "compressible": true },
  "application/cms": { "source": "iana" },
  "application/cnrp+xml": { "source": "iana", "compressible": true },
  "application/coap-eap": { "source": "iana" },
  "application/coap-group+json": { "source": "iana", "compressible": true },
  "application/coap-payload": { "source": "iana" },
  "application/commonground": { "source": "iana" },
  "application/concise-problem-details+cbor": { "source": "iana" },
  "application/conference-info+xml": { "source": "iana", "compressible": true },
  "application/cose": { "source": "iana" },
  "application/cose-key": { "source": "iana" },
  "application/cose-key-set": { "source": "iana" },
  "application/cose-x509": { "source": "iana" },
  "application/cpl+xml": { "source": "iana", "compressible": true, "extensions": ["cpl"] },
  "application/csrattrs": { "source": "iana" },
  "application/csta+xml": { "source": "iana", "compressible": true },
  "application/cstadata+xml": { "source": "iana", "compressible": true },
  "application/csvm+json": { "source": "iana", "compressible": true },
  "application/cu-seeme": { "source": "apache", "extensions": ["cu"] },
  "application/cwl": { "source": "iana", "extensions": ["cwl"] },
  "application/cwl+json": { "source": "iana", "compressible": true },
  "application/cwl+yaml": { "source": "iana" },
  "application/cwt": { "source": "iana" },
  "application/cybercash": { "source": "iana" },
  "application/dart": { "compressible": true },
  "application/dash+xml": { "source": "iana", "compressible": true, "extensions": ["mpd"] },
  "application/dash-patch+xml": { "source": "iana", "compressible": true, "extensions": ["mpp"] },
  "application/dashdelta": { "source": "iana" },
  "application/davmount+xml": { "source": "iana", "compressible": true, "extensions": ["davmount"] },
  "application/dca-rft": { "source": "iana" },
  "application/dcd": { "source": "iana" },
  "application/dec-dx": { "source": "iana" },
  "application/dialog-info+xml": { "source": "iana", "compressible": true },
  "application/dicom": { "source": "iana", "extensions": ["dcm"] },
  "application/dicom+json": { "source": "iana", "compressible": true },
  "application/dicom+xml": { "source": "iana", "compressible": true },
  "application/dii": { "source": "iana" },
  "application/dit": { "source": "iana" },
  "application/dns": { "source": "iana" },
  "application/dns+json": { "source": "iana", "compressible": true },
  "application/dns-message": { "source": "iana" },
  "application/docbook+xml": { "source": "apache", "compressible": true, "extensions": ["dbk"] },
  "application/dots+cbor": { "source": "iana" },
  "application/dpop+jwt": { "source": "iana" },
  "application/dskpp+xml": { "source": "iana", "compressible": true },
  "application/dssc+der": { "source": "iana", "extensions": ["dssc"] },
  "application/dssc+xml": { "source": "iana", "compressible": true, "extensions": ["xdssc"] },
  "application/dvcs": { "source": "iana" },
  "application/eat+cwt": { "source": "iana" },
  "application/eat+jwt": { "source": "iana" },
  "application/eat-bun+cbor": { "source": "iana" },
  "application/eat-bun+json": { "source": "iana", "compressible": true },
  "application/eat-ucs+cbor": { "source": "iana" },
  "application/eat-ucs+json": { "source": "iana", "compressible": true },
  "application/ecmascript": { "source": "apache", "compressible": true, "extensions": ["ecma"] },
  "application/edhoc+cbor-seq": { "source": "iana" },
  "application/edi-consent": { "source": "iana" },
  "application/edi-x12": { "source": "iana", "compressible": false },
  "application/edifact": { "source": "iana", "compressible": false },
  "application/efi": { "source": "iana" },
  "application/elm+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/elm+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.cap+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/emergencycalldata.comment+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.control+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.deviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.ecall.msd": { "source": "iana" },
  "application/emergencycalldata.legacyesn+json": { "source": "iana", "compressible": true },
  "application/emergencycalldata.providerinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.serviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.subscriberinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.veds+xml": { "source": "iana", "compressible": true },
  "application/emma+xml": { "source": "iana", "compressible": true, "extensions": ["emma"] },
  "application/emotionml+xml": { "source": "iana", "compressible": true, "extensions": ["emotionml"] },
  "application/encaprtp": { "source": "iana" },
  "application/entity-statement+jwt": { "source": "iana" },
  "application/epp+xml": { "source": "iana", "compressible": true },
  "application/epub+zip": { "source": "iana", "compressible": false, "extensions": ["epub"] },
  "application/eshop": { "source": "iana" },
  "application/exi": { "source": "iana", "extensions": ["exi"] },
  "application/expect-ct-report+json": { "source": "iana", "compressible": true },
  "application/express": { "source": "iana", "extensions": ["exp"] },
  "application/fastinfoset": { "source": "iana" },
  "application/fastsoap": { "source": "iana" },
  "application/fdf": { "source": "iana", "extensions": ["fdf"] },
  "application/fdt+xml": { "source": "iana", "compressible": true, "extensions": ["fdt"] },
  "application/fhir+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fhir+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fido.trusted-apps+json": { "compressible": true },
  "application/fits": { "source": "iana" },
  "application/flexfec": { "source": "iana" },
  "application/font-sfnt": { "source": "iana" },
  "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] },
  "application/font-woff": { "source": "iana", "compressible": false },
  "application/framework-attributes+xml": { "source": "iana", "compressible": true },
  "application/geo+json": { "source": "iana", "compressible": true, "extensions": ["geojson"] },
  "application/geo+json-seq": { "source": "iana" },
  "application/geopackage+sqlite3": { "source": "iana" },
  "application/geopose+json": { "source": "iana", "compressible": true },
  "application/geoxacml+json": { "source": "iana", "compressible": true },
  "application/geoxacml+xml": { "source": "iana", "compressible": true },
  "application/gltf-buffer": { "source": "iana" },
  "application/gml+xml": { "source": "iana", "compressible": true, "extensions": ["gml"] },
  "application/gnap-binding-jws": { "source": "iana" },
  "application/gnap-binding-jwsd": { "source": "iana" },
  "application/gnap-binding-rotation-jws": { "source": "iana" },
  "application/gnap-binding-rotation-jwsd": { "source": "iana" },
  "application/gpx+xml": { "source": "apache", "compressible": true, "extensions": ["gpx"] },
  "application/grib": { "source": "iana" },
  "application/gxf": { "source": "apache", "extensions": ["gxf"] },
  "application/gzip": { "source": "iana", "compressible": false, "extensions": ["gz"] },
  "application/h224": { "source": "iana" },
  "application/held+xml": { "source": "iana", "compressible": true },
  "application/hjson": { "extensions": ["hjson"] },
  "application/hl7v2+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/http": { "source": "iana" },
  "application/hyperstudio": { "source": "iana", "extensions": ["stk"] },
  "application/ibe-key-request+xml": { "source": "iana", "compressible": true },
  "application/ibe-pkg-reply+xml": { "source": "iana", "compressible": true },
  "application/ibe-pp-data": { "source": "iana" },
  "application/iges": { "source": "iana" },
  "application/im-iscomposing+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/index": { "source": "iana" },
  "application/index.cmd": { "source": "iana" },
  "application/index.obj": { "source": "iana" },
  "application/index.response": { "source": "iana" },
  "application/index.vnd": { "source": "iana" },
  "application/inkml+xml": { "source": "iana", "compressible": true, "extensions": ["ink", "inkml"] },
  "application/iotp": { "source": "iana" },
  "application/ipfix": { "source": "iana", "extensions": ["ipfix"] },
  "application/ipp": { "source": "iana" },
  "application/isup": { "source": "iana" },
  "application/its+xml": { "source": "iana", "compressible": true, "extensions": ["its"] },
  "application/java-archive": { "source": "iana", "compressible": false, "extensions": ["jar", "war", "ear"] },
  "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] },
  "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] },
  "application/javascript": { "source": "apache", "charset": "UTF-8", "compressible": true, "extensions": ["js"] },
  "application/jf2feed+json": { "source": "iana", "compressible": true },
  "application/jose": { "source": "iana" },
  "application/jose+json": { "source": "iana", "compressible": true },
  "application/jrd+json": { "source": "iana", "compressible": true },
  "application/jscalendar+json": { "source": "iana", "compressible": true },
  "application/jscontact+json": { "source": "iana", "compressible": true },
  "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] },
  "application/json-patch+json": { "source": "iana", "compressible": true },
  "application/json-seq": { "source": "iana" },
  "application/json5": { "extensions": ["json5"] },
  "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] },
  "application/jsonpath": { "source": "iana" },
  "application/jwk+json": { "source": "iana", "compressible": true },
  "application/jwk-set+json": { "source": "iana", "compressible": true },
  "application/jwk-set+jwt": { "source": "iana" },
  "application/jwt": { "source": "iana" },
  "application/kpml-request+xml": { "source": "iana", "compressible": true },
  "application/kpml-response+xml": { "source": "iana", "compressible": true },
  "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] },
  "application/lgr+xml": { "source": "iana", "compressible": true, "extensions": ["lgr"] },
  "application/link-format": { "source": "iana" },
  "application/linkset": { "source": "iana" },
  "application/linkset+json": { "source": "iana", "compressible": true },
  "application/load-control+xml": { "source": "iana", "compressible": true },
  "application/logout+jwt": { "source": "iana" },
  "application/lost+xml": { "source": "iana", "compressible": true, "extensions": ["lostxml"] },
  "application/lostsync+xml": { "source": "iana", "compressible": true },
  "application/lpf+zip": { "source": "iana", "compressible": false },
  "application/lxf": { "source": "iana" },
  "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] },
  "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] },
  "application/macwriteii": { "source": "iana" },
  "application/mads+xml": { "source": "iana", "compressible": true, "extensions": ["mads"] },
  "application/manifest+json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] },
  "application/marc": { "source": "iana", "extensions": ["mrc"] },
  "application/marcxml+xml": { "source": "iana", "compressible": true, "extensions": ["mrcx"] },
  "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] },
  "application/mathml+xml": { "source": "iana", "compressible": true, "extensions": ["mathml"] },
  "application/mathml-content+xml": { "source": "iana", "compressible": true },
  "application/mathml-presentation+xml": { "source": "iana", "compressible": true },
  "application/mbms-associated-procedure-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-deregister+xml": { "source": "iana", "compressible": true },
  "application/mbms-envelope+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-protection-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-reception-report+xml": { "source": "iana", "compressible": true },
  "application/mbms-register+xml": { "source": "iana", "compressible": true },
  "application/mbms-register-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-schedule+xml": { "source": "iana", "compressible": true },
  "application/mbms-user-service-description+xml": { "source": "iana", "compressible": true },
  "application/mbox": { "source": "iana", "extensions": ["mbox"] },
  "application/media-policy-dataset+xml": { "source": "iana", "compressible": true, "extensions": ["mpf"] },
  "application/media_control+xml": { "source": "iana", "compressible": true },
  "application/mediaservercontrol+xml": { "source": "iana", "compressible": true, "extensions": ["mscml"] },
  "application/merge-patch+json": { "source": "iana", "compressible": true },
  "application/metalink+xml": { "source": "apache", "compressible": true, "extensions": ["metalink"] },
  "application/metalink4+xml": { "source": "iana", "compressible": true, "extensions": ["meta4"] },
  "application/mets+xml": { "source": "iana", "compressible": true, "extensions": ["mets"] },
  "application/mf4": { "source": "iana" },
  "application/mikey": { "source": "iana" },
  "application/mipc": { "source": "iana" },
  "application/missing-blocks+cbor-seq": { "source": "iana" },
  "application/mmt-aei+xml": { "source": "iana", "compressible": true, "extensions": ["maei"] },
  "application/mmt-usd+xml": { "source": "iana", "compressible": true, "extensions": ["musd"] },
  "application/mods+xml": { "source": "iana", "compressible": true, "extensions": ["mods"] },
  "application/moss-keys": { "source": "iana" },
  "application/moss-signature": { "source": "iana" },
  "application/mosskey-data": { "source": "iana" },
  "application/mosskey-request": { "source": "iana" },
  "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] },
  "application/mp4": { "source": "iana", "extensions": ["mp4", "mpg4", "mp4s", "m4p"] },
  "application/mpeg4-generic": { "source": "iana" },
  "application/mpeg4-iod": { "source": "iana" },
  "application/mpeg4-iod-xmt": { "source": "iana" },
  "application/mrb-consumer+xml": { "source": "iana", "compressible": true },
  "application/mrb-publish+xml": { "source": "iana", "compressible": true },
  "application/msc-ivr+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msc-mixer+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msix": { "compressible": false, "extensions": ["msix"] },
  "application/msixbundle": { "compressible": false, "extensions": ["msixbundle"] },
  "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] },
  "application/mud+json": { "source": "iana", "compressible": true },
  "application/multipart-core": { "source": "iana" },
  "application/mxf": { "source": "iana", "extensions": ["mxf"] },
  "application/n-quads": { "source": "iana", "extensions": ["nq"] },
  "application/n-triples": { "source": "iana", "extensions": ["nt"] },
  "application/nasdata": { "source": "iana" },
  "application/news-checkgroups": { "source": "iana", "charset": "US-ASCII" },
  "application/news-groupinfo": { "source": "iana", "charset": "US-ASCII" },
  "application/news-transmission": { "source": "iana" },
  "application/nlsml+xml": { "source": "iana", "compressible": true },
  "application/node": { "source": "iana", "extensions": ["cjs"] },
  "application/nss": { "source": "iana" },
  "application/oauth-authz-req+jwt": { "source": "iana" },
  "application/oblivious-dns-message": { "source": "iana" },
  "application/ocsp-request": { "source": "iana" },
  "application/ocsp-response": { "source": "iana" },
  "application/octet-stream": { "source": "iana", "compressible": true, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { "source": "iana", "extensions": ["oda"] },
  "application/odm+xml": { "source": "iana", "compressible": true },
  "application/odx": { "source": "iana" },
  "application/oebps-package+xml": { "source": "iana", "compressible": true, "extensions": ["opf"] },
  "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] },
  "application/ohttp-keys": { "source": "iana" },
  "application/omdoc+xml": { "source": "apache", "compressible": true, "extensions": ["omdoc"] },
  "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg", "one", "onea"] },
  "application/opc-nodeset+xml": { "source": "iana", "compressible": true },
  "application/oscore": { "source": "iana" },
  "application/oxps": { "source": "iana", "extensions": ["oxps"] },
  "application/p21": { "source": "iana" },
  "application/p21+zip": { "source": "iana", "compressible": false },
  "application/p2p-overlay+xml": { "source": "iana", "compressible": true, "extensions": ["relo"] },
  "application/parityfec": { "source": "iana" },
  "application/passport": { "source": "iana" },
  "application/patch-ops-error+xml": { "source": "iana", "compressible": true, "extensions": ["xer"] },
  "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] },
  "application/pdx": { "source": "iana" },
  "application/pem-certificate-chain": { "source": "iana" },
  "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] },
  "application/pgp-keys": { "source": "iana", "extensions": ["asc"] },
  "application/pgp-signature": { "source": "iana", "extensions": ["sig", "asc"] },
  "application/pics-rules": { "source": "apache", "extensions": ["prf"] },
  "application/pidf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pidf-diff+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pkcs10": { "source": "iana", "extensions": ["p10"] },
  "application/pkcs12": { "source": "iana" },
  "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] },
  "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] },
  "application/pkcs8": { "source": "iana", "extensions": ["p8"] },
  "application/pkcs8-encrypted": { "source": "iana" },
  "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] },
  "application/pkix-cert": { "source": "iana", "extensions": ["cer"] },
  "application/pkix-crl": { "source": "iana", "extensions": ["crl"] },
  "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] },
  "application/pkixcmp": { "source": "iana", "extensions": ["pki"] },
  "application/pls+xml": { "source": "iana", "compressible": true, "extensions": ["pls"] },
  "application/poc-settings+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { "source": "iana", "compressible": true },
  "application/private-token-issuer-directory": { "source": "iana" },
  "application/private-token-request": { "source": "iana" },
  "application/private-token-response": { "source": "iana" },
  "application/problem+json": { "source": "iana", "compressible": true },
  "application/problem+xml": { "source": "iana", "compressible": true },
  "application/provenance+xml": { "source": "iana", "compressible": true, "extensions": ["provx"] },
  "application/provided-claims+jwt": { "source": "iana" },
  "application/prs.alvestrand.titrax-sheet": { "source": "iana" },
  "application/prs.cww": { "source": "iana", "extensions": ["cww"] },
  "application/prs.cyn": { "source": "iana", "charset": "7-BIT" },
  "application/prs.hpub+zip": { "source": "iana", "compressible": false },
  "application/prs.implied-document+xml": { "source": "iana", "compressible": true },
  "application/prs.implied-executable": { "source": "iana" },
  "application/prs.implied-object+json": { "source": "iana", "compressible": true },
  "application/prs.implied-object+json-seq": { "source": "iana" },
  "application/prs.implied-object+yaml": { "source": "iana" },
  "application/prs.implied-structure": { "source": "iana" },
  "application/prs.mayfile": { "source": "iana" },
  "application/prs.nprend": { "source": "iana" },
  "application/prs.plucker": { "source": "iana" },
  "application/prs.rdf-xml-crypt": { "source": "iana" },
  "application/prs.vcfbzip2": { "source": "iana" },
  "application/prs.xsf+xml": { "source": "iana", "compressible": true, "extensions": ["xsf"] },
  "application/pskc+xml": { "source": "iana", "compressible": true, "extensions": ["pskcxml"] },
  "application/pvd+json": { "source": "iana", "compressible": true },
  "application/qsig": { "source": "iana" },
  "application/raml+yaml": { "compressible": true, "extensions": ["raml"] },
  "application/raptorfec": { "source": "iana" },
  "application/rdap+json": { "source": "iana", "compressible": true },
  "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf", "owl"] },
  "application/reginfo+xml": { "source": "iana", "compressible": true, "extensions": ["rif"] },
  "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] },
  "application/remote-printing": { "source": "apache" },
  "application/reputon+json": { "source": "iana", "compressible": true },
  "application/resolve-response+jwt": { "source": "iana" },
  "application/resource-lists+xml": { "source": "iana", "compressible": true, "extensions": ["rl"] },
  "application/resource-lists-diff+xml": { "source": "iana", "compressible": true, "extensions": ["rld"] },
  "application/rfc+xml": { "source": "iana", "compressible": true },
  "application/riscos": { "source": "iana" },
  "application/rlmi+xml": { "source": "iana", "compressible": true },
  "application/rls-services+xml": { "source": "iana", "compressible": true, "extensions": ["rs"] },
  "application/route-apd+xml": { "source": "iana", "compressible": true, "extensions": ["rapd"] },
  "application/route-s-tsid+xml": { "source": "iana", "compressible": true, "extensions": ["sls"] },
  "application/route-usd+xml": { "source": "iana", "compressible": true, "extensions": ["rusd"] },
  "application/rpki-checklist": { "source": "iana" },
  "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] },
  "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] },
  "application/rpki-publication": { "source": "iana" },
  "application/rpki-roa": { "source": "iana", "extensions": ["roa"] },
  "application/rpki-signed-tal": { "source": "iana" },
  "application/rpki-updown": { "source": "iana" },
  "application/rsd+xml": { "source": "apache", "compressible": true, "extensions": ["rsd"] },
  "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] },
  "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "application/rtploopback": { "source": "iana" },
  "application/rtx": { "source": "iana" },
  "application/samlassertion+xml": { "source": "iana", "compressible": true },
  "application/samlmetadata+xml": { "source": "iana", "compressible": true },
  "application/sarif+json": { "source": "iana", "compressible": true },
  "application/sarif-external-properties+json": { "source": "iana", "compressible": true },
  "application/sbe": { "source": "iana" },
  "application/sbml+xml": { "source": "iana", "compressible": true, "extensions": ["sbml"] },
  "application/scaip+xml": { "source": "iana", "compressible": true },
  "application/scim+json": { "source": "iana", "compressible": true },
  "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] },
  "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] },
  "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] },
  "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] },
  "application/sdp": { "source": "iana", "extensions": ["sdp"] },
  "application/secevent+jwt": { "source": "iana" },
  "application/senml+cbor": { "source": "iana" },
  "application/senml+json": { "source": "iana", "compressible": true },
  "application/senml+xml": { "source": "iana", "compressible": true, "extensions": ["senmlx"] },
  "application/senml-etch+cbor": { "source": "iana" },
  "application/senml-etch+json": { "source": "iana", "compressible": true },
  "application/senml-exi": { "source": "iana" },
  "application/sensml+cbor": { "source": "iana" },
  "application/sensml+json": { "source": "iana", "compressible": true },
  "application/sensml+xml": { "source": "iana", "compressible": true, "extensions": ["sensmlx"] },
  "application/sensml-exi": { "source": "iana" },
  "application/sep+xml": { "source": "iana", "compressible": true },
  "application/sep-exi": { "source": "iana" },
  "application/session-info": { "source": "iana" },
  "application/set-payment": { "source": "iana" },
  "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] },
  "application/set-registration": { "source": "iana" },
  "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] },
  "application/sgml": { "source": "iana" },
  "application/sgml-open-catalog": { "source": "iana" },
  "application/shf+xml": { "source": "iana", "compressible": true, "extensions": ["shf"] },
  "application/sieve": { "source": "iana", "extensions": ["siv", "sieve"] },
  "application/simple-filter+xml": { "source": "iana", "compressible": true },
  "application/simple-message-summary": { "source": "iana" },
  "application/simplesymbolcontainer": { "source": "iana" },
  "application/sipc": { "source": "iana" },
  "application/slate": { "source": "iana" },
  "application/smil": { "source": "apache" },
  "application/smil+xml": { "source": "iana", "compressible": true, "extensions": ["smi", "smil"] },
  "application/smpte336m": { "source": "iana" },
  "application/soap+fastinfoset": { "source": "iana" },
  "application/soap+xml": { "source": "iana", "compressible": true },
  "application/sparql-query": { "source": "iana", "extensions": ["rq"] },
  "application/sparql-results+xml": { "source": "iana", "compressible": true, "extensions": ["srx"] },
  "application/spdx+json": { "source": "iana", "compressible": true },
  "application/spirits-event+xml": { "source": "iana", "compressible": true },
  "application/sql": { "source": "iana", "extensions": ["sql"] },
  "application/srgs": { "source": "iana", "extensions": ["gram"] },
  "application/srgs+xml": { "source": "iana", "compressible": true, "extensions": ["grxml"] },
  "application/sru+xml": { "source": "iana", "compressible": true, "extensions": ["sru"] },
  "application/ssdl+xml": { "source": "apache", "compressible": true, "extensions": ["ssdl"] },
  "application/sslkeylogfile": { "source": "iana" },
  "application/ssml+xml": { "source": "iana", "compressible": true, "extensions": ["ssml"] },
  "application/st2110-41": { "source": "iana" },
  "application/stix+json": { "source": "iana", "compressible": true },
  "application/stratum": { "source": "iana" },
  "application/swid+cbor": { "source": "iana" },
  "application/swid+xml": { "source": "iana", "compressible": true, "extensions": ["swidtag"] },
  "application/tamp-apex-update": { "source": "iana" },
  "application/tamp-apex-update-confirm": { "source": "iana" },
  "application/tamp-community-update": { "source": "iana" },
  "application/tamp-community-update-confirm": { "source": "iana" },
  "application/tamp-error": { "source": "iana" },
  "application/tamp-sequence-adjust": { "source": "iana" },
  "application/tamp-sequence-adjust-confirm": { "source": "iana" },
  "application/tamp-status-query": { "source": "iana" },
  "application/tamp-status-response": { "source": "iana" },
  "application/tamp-update": { "source": "iana" },
  "application/tamp-update-confirm": { "source": "iana" },
  "application/tar": { "compressible": true },
  "application/taxii+json": { "source": "iana", "compressible": true },
  "application/td+json": { "source": "iana", "compressible": true },
  "application/tei+xml": { "source": "iana", "compressible": true, "extensions": ["tei", "teicorpus"] },
  "application/tetra_isi": { "source": "iana" },
  "application/thraud+xml": { "source": "iana", "compressible": true, "extensions": ["tfi"] },
  "application/timestamp-query": { "source": "iana" },
  "application/timestamp-reply": { "source": "iana" },
  "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] },
  "application/tlsrpt+gzip": { "source": "iana" },
  "application/tlsrpt+json": { "source": "iana", "compressible": true },
  "application/tm+json": { "source": "iana", "compressible": true },
  "application/tnauthlist": { "source": "iana" },
  "application/toc+cbor": { "source": "iana" },
  "application/token-introspection+jwt": { "source": "iana" },
  "application/toml": { "source": "iana", "compressible": true, "extensions": ["toml"] },
  "application/trickle-ice-sdpfrag": { "source": "iana" },
  "application/trig": { "source": "iana", "extensions": ["trig"] },
  "application/trust-chain+json": { "source": "iana", "compressible": true },
  "application/trust-mark+jwt": { "source": "iana" },
  "application/trust-mark-delegation+jwt": { "source": "iana" },
  "application/ttml+xml": { "source": "iana", "compressible": true, "extensions": ["ttml"] },
  "application/tve-trigger": { "source": "iana" },
  "application/tzif": { "source": "iana" },
  "application/tzif-leap": { "source": "iana" },
  "application/ubjson": { "compressible": false, "extensions": ["ubj"] },
  "application/uccs+cbor": { "source": "iana" },
  "application/ujcs+json": { "source": "iana", "compressible": true },
  "application/ulpfec": { "source": "iana" },
  "application/urc-grpsheet+xml": { "source": "iana", "compressible": true },
  "application/urc-ressheet+xml": { "source": "iana", "compressible": true, "extensions": ["rsheet"] },
  "application/urc-targetdesc+xml": { "source": "iana", "compressible": true, "extensions": ["td"] },
  "application/urc-uisocketdesc+xml": { "source": "iana", "compressible": true },
  "application/vc": { "source": "iana" },
  "application/vc+cose": { "source": "iana" },
  "application/vc+jwt": { "source": "iana" },
  "application/vcard+json": { "source": "iana", "compressible": true },
  "application/vcard+xml": { "source": "iana", "compressible": true },
  "application/vemmi": { "source": "iana" },
  "application/vividence.scriptfile": { "source": "apache" },
  "application/vnd.1000minds.decision-model+xml": { "source": "iana", "compressible": true, "extensions": ["1km"] },
  "application/vnd.1ob": { "source": "iana" },
  "application/vnd.3gpp-prose+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3a+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ach+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc8+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gnas": { "source": "iana" },
  "application/vnd.3gpp.5gsa2x": { "source": "iana" },
  "application/vnd.3gpp.5gsa2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gsv2x": { "source": "iana" },
  "application/vnd.3gpp.5gsv2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.bsf+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.crs+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.current-location-discovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gmop+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gtpc": { "source": "iana" },
  "application/vnd.3gpp.interworking-data": { "source": "iana" },
  "application/vnd.3gpp.lpp": { "source": "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-payload": { "source": "iana" },
  "application/vnd.3gpp.mcdata-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-floor-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-signed+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mid-call+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ngap": { "source": "iana" },
  "application/vnd.3gpp.pfcp": { "source": "iana" },
  "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] },
  "application/vnd.3gpp.pinapp-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.s1ap": { "source": "iana" },
  "application/vnd.3gpp.seal-group-doc+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-network-qos-management-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-ue-config-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-unicast-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-user-profile-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.sms": { "source": "iana" },
  "application/vnd.3gpp.sms+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ussd+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.v2x": { "source": "iana" },
  "application/vnd.3gpp.vae-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.sms": { "source": "iana" },
  "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { "source": "iana" },
  "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] },
  "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] },
  "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] },
  "application/vnd.acm.addressxfer+json": { "source": "iana", "compressible": true },
  "application/vnd.acm.chatbot+json": { "source": "iana", "compressible": true },
  "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] },
  "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "compressible": false, "extensions": ["air"] },
  "application/vnd.adobe.flash.movie": { "source": "iana" },
  "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] },
  "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { "source": "iana" },
  "application/vnd.adobe.xdp+xml": { "source": "iana", "compressible": true, "extensions": ["xdp"] },
  "application/vnd.adobe.xfdf": { "source": "apache", "extensions": ["xfdf"] },
  "application/vnd.aether.imp": { "source": "iana" },
  "application/vnd.afpc.afplinedata": { "source": "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
  "application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
  "application/vnd.afpc.foca-charset": { "source": "iana" },
  "application/vnd.afpc.foca-codedfont": { "source": "iana" },
  "application/vnd.afpc.foca-codepage": { "source": "iana" },
  "application/vnd.afpc.modca": { "source": "iana" },
  "application/vnd.afpc.modca-cmtable": { "source": "iana" },
  "application/vnd.afpc.modca-formdef": { "source": "iana" },
  "application/vnd.afpc.modca-mediummap": { "source": "iana" },
  "application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
  "application/vnd.afpc.modca-overlay": { "source": "iana" },
  "application/vnd.afpc.modca-pagesegment": { "source": "iana" },
  "application/vnd.age": { "source": "iana", "extensions": ["age"] },
  "application/vnd.ah-barcode": { "source": "apache" },
  "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] },
  "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] },
  "application/vnd.amadeus+json": { "source": "iana", "compressible": true },
  "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { "source": "iana" },
  "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] },
  "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] },
  "application/vnd.amundsen.maze+xml": { "source": "iana", "compressible": true },
  "application/vnd.android.ota": { "source": "iana" },
  "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] },
  "application/vnd.anki": { "source": "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] },
  "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] },
  "application/vnd.apache.arrow.file": { "source": "iana" },
  "application/vnd.apache.arrow.stream": { "source": "iana" },
  "application/vnd.apache.parquet": { "source": "iana" },
  "application/vnd.apache.thrift.binary": { "source": "iana" },
  "application/vnd.apache.thrift.compact": { "source": "iana" },
  "application/vnd.apache.thrift.json": { "source": "iana" },
  "application/vnd.apexlang": { "source": "iana" },
  "application/vnd.api+json": { "source": "iana", "compressible": true },
  "application/vnd.aplextor.warrp+json": { "source": "iana", "compressible": true },
  "application/vnd.apothekende.reservation+json": { "source": "iana", "compressible": true },
  "application/vnd.apple.installer+xml": { "source": "iana", "compressible": true, "extensions": ["mpkg"] },
  "application/vnd.apple.keynote": { "source": "iana", "extensions": ["key"] },
  "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] },
  "application/vnd.apple.numbers": { "source": "iana", "extensions": ["numbers"] },
  "application/vnd.apple.pages": { "source": "iana", "extensions": ["pages"] },
  "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] },
  "application/vnd.arastra.swi": { "source": "apache" },
  "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] },
  "application/vnd.artisan+json": { "source": "iana", "compressible": true },
  "application/vnd.artsquare": { "source": "iana" },
  "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] },
  "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] },
  "application/vnd.autodesk.fbx": { "extensions": ["fbx"] },
  "application/vnd.autopackage": { "source": "iana" },
  "application/vnd.avalon+json": { "source": "iana", "compressible": true },
  "application/vnd.avistar+xml": { "source": "iana", "compressible": true },
  "application/vnd.balsamiq.bmml+xml": { "source": "iana", "compressible": true, "extensions": ["bmml"] },
  "application/vnd.balsamiq.bmpr": { "source": "iana" },
  "application/vnd.banana-accounting": { "source": "iana" },
  "application/vnd.bbf.usp.error": { "source": "iana" },
  "application/vnd.bbf.usp.msg": { "source": "iana" },
  "application/vnd.bbf.usp.msg+json": { "source": "iana", "compressible": true },
  "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true },
  "application/vnd.belightsoft.lhzd+zip": { "source": "iana", "compressible": false },
  "application/vnd.belightsoft.lhzl+zip": { "source": "iana", "compressible": false },
  "application/vnd.bint.med-content": { "source": "iana" },
  "application/vnd.biopax.rdf+xml": { "source": "iana", "compressible": true },
  "application/vnd.blink-idb-value-wrapper": { "source": "iana" },
  "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { "source": "iana" },
  "application/vnd.bluetooth.le.oob": { "source": "iana" },
  "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] },
  "application/vnd.bpf": { "source": "iana" },
  "application/vnd.bpf3": { "source": "iana" },
  "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] },
  "application/vnd.byu.uapi+json": { "source": "iana", "compressible": true },
  "application/vnd.bzip3": { "source": "iana" },
  "application/vnd.c3voc.schedule+xml": { "source": "iana", "compressible": true },
  "application/vnd.cab-jscript": { "source": "iana" },
  "application/vnd.canon-cpdl": { "source": "iana" },
  "application/vnd.canon-lips": { "source": "iana" },
  "application/vnd.capasystems-pg+json": { "source": "iana", "compressible": true },
  "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
  "application/vnd.century-systems.tcp_stream": { "source": "iana" },
  "application/vnd.chemdraw+xml": { "source": "iana", "compressible": true, "extensions": ["cdxml"] },
  "application/vnd.chess-pgn": { "source": "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] },
  "application/vnd.ciedi": { "source": "iana" },
  "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { "source": "iana" },
  "application/vnd.citationstyles.style+xml": { "source": "iana", "compressible": true, "extensions": ["csl"] },
  "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] },
  "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] },
  "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] },
  "application/vnd.cncf.helm.chart.content.v1.tar+gzip": { "source": "iana" },
  "application/vnd.cncf.helm.chart.provenance.v1.prov": { "source": "iana" },
  "application/vnd.cncf.helm.config.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.coffeescript": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
  "application/vnd.collection+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.doc+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.next+json": { "source": "iana", "compressible": true },
  "application/vnd.comicbook+zip": { "source": "iana", "compressible": false },
  "application/vnd.comicbook-rar": { "source": "iana" },
  "application/vnd.commerce-battelle": { "source": "iana" },
  "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] },
  "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true },
  "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] },
  "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] },
  "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] },
  "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { "source": "iana", "compressible": true, "extensions": ["wbs"] },
  "application/vnd.cryptii.pipe+json": { "source": "iana", "compressible": true },
  "application/vnd.crypto-shade-file": { "source": "iana" },
  "application/vnd.cryptomator.encrypted": { "source": "iana" },
  "application/vnd.cryptomator.vault": { "source": "iana" },
  "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] },
  "application/vnd.ctct.ws+xml": { "source": "iana", "compressible": true },
  "application/vnd.cups-pdf": { "source": "iana" },
  "application/vnd.cups-postscript": { "source": "iana" },
  "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] },
  "application/vnd.cups-raster": { "source": "iana" },
  "application/vnd.cups-raw": { "source": "iana" },
  "application/vnd.curl": { "source": "iana" },
  "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] },
  "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { "source": "iana", "compressible": true },
  "application/vnd.cybank": { "source": "iana" },
  "application/vnd.cyclonedx+json": { "source": "iana", "compressible": true },
  "application/vnd.cyclonedx+xml": { "source": "iana", "compressible": true },
  "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana", "compressible": false },
  "application/vnd.d3m-dataset": { "source": "iana" },
  "application/vnd.d3m-problem": { "source": "iana" },
  "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] },
  "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] },
  "application/vnd.datalog": { "source": "iana" },
  "application/vnd.datapackage+json": { "source": "iana", "compressible": true },
  "application/vnd.dataresource+json": { "source": "iana", "compressible": true },
  "application/vnd.dbf": { "source": "iana", "extensions": ["dbf"] },
  "application/vnd.dcmp+xml": { "source": "iana", "compressible": true, "extensions": ["dcmp"] },
  "application/vnd.debian.binary-package": { "source": "iana" },
  "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { "source": "iana", "compressible": true, "extensions": ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] },
  "application/vnd.desmume.movie": { "source": "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
  "application/vnd.dm.delegation+xml": { "source": "iana", "compressible": true },
  "application/vnd.dna": { "source": "iana", "extensions": ["dna"] },
  "application/vnd.document+json": { "source": "iana", "compressible": true },
  "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] },
  "application/vnd.dolby.mobile.1": { "source": "iana" },
  "application/vnd.dolby.mobile.2": { "source": "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
  "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] },
  "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] },
  "application/vnd.drive+json": { "source": "iana", "compressible": true },
  "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] },
  "application/vnd.dtg.local": { "source": "iana" },
  "application/vnd.dtg.local.flash": { "source": "iana" },
  "application/vnd.dtg.local.html": { "source": "iana" },
  "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.dvbj": { "source": "iana" },
  "application/vnd.dvb.esgcontainer": { "source": "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
  "application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
  "application/vnd.dvb.ipdcroaming": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-container+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-generic+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-init+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.pfr": { "source": "iana" },
  "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] },
  "application/vnd.dxr": { "source": "iana" },
  "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] },
  "application/vnd.dzr": { "source": "iana" },
  "application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
  "application/vnd.ecdis-update": { "source": "iana" },
  "application/vnd.ecip.rlp": { "source": "iana" },
  "application/vnd.eclipse.ditto+json": { "source": "iana", "compressible": true },
  "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] },
  "application/vnd.ecowin.filerequest": { "source": "iana" },
  "application/vnd.ecowin.fileupdate": { "source": "iana" },
  "application/vnd.ecowin.series": { "source": "iana" },
  "application/vnd.ecowin.seriesrequest": { "source": "iana" },
  "application/vnd.ecowin.seriesupdate": { "source": "iana" },
  "application/vnd.efi.img": { "source": "iana" },
  "application/vnd.efi.iso": { "source": "iana" },
  "application/vnd.eln+zip": { "source": "iana", "compressible": false },
  "application/vnd.emclient.accessrequest+xml": { "source": "iana", "compressible": true },
  "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] },
  "application/vnd.enphase.envoy": { "source": "iana" },
  "application/vnd.eprints.data+xml": { "source": "iana", "compressible": true },
  "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] },
  "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] },
  "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] },
  "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] },
  "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] },
  "application/vnd.ericsson.quickcall": { "source": "iana" },
  "application/vnd.erofs": { "source": "iana" },
  "application/vnd.espass-espass+zip": { "source": "iana", "compressible": false },
  "application/vnd.eszigno3+xml": { "source": "iana", "compressible": true, "extensions": ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.asic-e+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.asic-s+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.cug+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvcommand+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvservice+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsync+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mcid+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mheg5": { "source": "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.pstn+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.sci+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.simservs+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.timestamp-token": { "source": "iana" },
  "application/vnd.etsi.tsl+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.tsl.der": { "source": "iana" },
  "application/vnd.eu.kasparian.car+json": { "source": "iana", "compressible": true },
  "application/vnd.eudora.data": { "source": "iana" },
  "application/vnd.evolv.ecig.profile": { "source": "iana" },
  "application/vnd.evolv.ecig.settings": { "source": "iana" },
  "application/vnd.evolv.ecig.theme": { "source": "iana" },
  "application/vnd.exstream-empower+zip": { "source": "iana", "compressible": false },
  "application/vnd.exstream-package": { "source": "iana" },
  "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] },
  "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] },
  "application/vnd.f-secure.mobile": { "source": "iana" },
  "application/vnd.familysearch.gedcom+zip": { "source": "iana", "compressible": false },
  "application/vnd.fastcopy-disk-image": { "source": "iana" },
  "application/vnd.fdf": { "source": "apache", "extensions": ["fdf"] },
  "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] },
  "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] },
  "application/vnd.fdsn.stationxml+xml": { "source": "iana", "charset": "XML-BASED", "compressible": true },
  "application/vnd.ffsns": { "source": "iana" },
  "application/vnd.ficlab.flb+zip": { "source": "iana", "compressible": false },
  "application/vnd.filmit.zfc": { "source": "iana" },
  "application/vnd.fints": { "source": "iana" },
  "application/vnd.firemonkeys.cloudcell": { "source": "iana" },
  "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] },
  "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] },
  "application/vnd.font-fontforge-sfd": { "source": "iana" },
  "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] },
  "application/vnd.freelog.comic": { "source": "iana" },
  "application/vnd.frogans.fnc": { "source": "apache", "extensions": ["fnc"] },
  "application/vnd.frogans.ltf": { "source": "apache", "extensions": ["ltf"] },
  "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { "source": "iana", "compressible": true },
  "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] },
  "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] },
  "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] },
  "application/vnd.fujixerox.art-ex": { "source": "iana" },
  "application/vnd.fujixerox.art4": { "source": "iana" },
  "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] },
  "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { "source": "iana" },
  "application/vnd.fujixerox.hbpl": { "source": "iana" },
  "application/vnd.fut-misnet": { "source": "iana" },
  "application/vnd.futoin+cbor": { "source": "iana" },
  "application/vnd.futoin+json": { "source": "iana", "compressible": true },
  "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] },
  "application/vnd.ga4gh.passport+jwt": { "source": "iana" },
  "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] },
  "application/vnd.genozip": { "source": "iana" },
  "application/vnd.gentics.grd+json": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.catmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.ebuild": { "source": "iana" },
  "application/vnd.gentoo.eclass": { "source": "iana" },
  "application/vnd.gentoo.gpkg": { "source": "iana" },
  "application/vnd.gentoo.manifest": { "source": "iana" },
  "application/vnd.gentoo.pkgmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.xpak": { "source": "iana" },
  "application/vnd.geo+json": { "source": "apache", "compressible": true },
  "application/vnd.geocube+xml": { "source": "apache", "compressible": true },
  "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] },
  "application/vnd.geogebra.pinboard": { "source": "iana" },
  "application/vnd.geogebra.slides": { "source": "iana", "extensions": ["ggs"] },
  "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] },
  "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] },
  "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] },
  "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] },
  "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] },
  "application/vnd.gerber": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
  "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] },
  "application/vnd.gnu.taler.exchange+json": { "source": "iana", "compressible": true },
  "application/vnd.gnu.taler.merchant+json": { "source": "iana", "compressible": true },
  "application/vnd.google-apps.audio": {},
  "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] },
  "application/vnd.google-apps.drawing": { "compressible": false, "extensions": ["gdraw"] },
  "application/vnd.google-apps.drive-sdk": { "compressible": false },
  "application/vnd.google-apps.file": {},
  "application/vnd.google-apps.folder": { "compressible": false },
  "application/vnd.google-apps.form": { "compressible": false, "extensions": ["gform"] },
  "application/vnd.google-apps.fusiontable": {},
  "application/vnd.google-apps.jam": { "compressible": false, "extensions": ["gjam"] },
  "application/vnd.google-apps.mail-layout": {},
  "application/vnd.google-apps.map": { "compressible": false, "extensions": ["gmap"] },
  "application/vnd.google-apps.photo": {},
  "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] },
  "application/vnd.google-apps.script": { "compressible": false, "extensions": ["gscript"] },
  "application/vnd.google-apps.shortcut": {},
  "application/vnd.google-apps.site": { "compressible": false, "extensions": ["gsite"] },
  "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] },
  "application/vnd.google-apps.unknown": {},
  "application/vnd.google-apps.video": {},
  "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] },
  "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { "source": "apache", "compressible": true },
  "application/vnd.gov.sk.e-form+zip": { "source": "iana", "compressible": false },
  "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana", "compressible": true, "extensions": ["xdcf"] },
  "application/vnd.gpxsee.map+xml": { "source": "iana", "compressible": true },
  "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] },
  "application/vnd.gridmp": { "source": "iana" },
  "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] },
  "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] },
  "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] },
  "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] },
  "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] },
  "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] },
  "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] },
  "application/vnd.hal+json": { "source": "iana", "compressible": true },
  "application/vnd.hal+xml": { "source": "iana", "compressible": true, "extensions": ["hal"] },
  "application/vnd.handheld-entertainment+xml": { "source": "iana", "compressible": true, "extensions": ["zmm"] },
  "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] },
  "application/vnd.hc+json": { "source": "iana", "compressible": true },
  "application/vnd.hcl-bireports": { "source": "iana" },
  "application/vnd.hdt": { "source": "iana" },
  "application/vnd.heroku+json": { "source": "iana", "compressible": true },
  "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] },
  "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] },
  "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] },
  "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] },
  "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] },
  "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] },
  "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] },
  "application/vnd.hsl": { "source": "iana" },
  "application/vnd.httphone": { "source": "iana" },
  "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] },
  "application/vnd.hyper+json": { "source": "iana", "compressible": true },
  "application/vnd.hyper-item+json": { "source": "iana", "compressible": true },
  "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true },
  "application/vnd.hzn-3d-crossword": { "source": "iana" },
  "application/vnd.ibm.afplinedata": { "source": "apache" },
  "application/vnd.ibm.electronic-media": { "source": "iana" },
  "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] },
  "application/vnd.ibm.modcap": { "source": "apache", "extensions": ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] },
  "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] },
  "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] },
  "application/vnd.ieee.1905": { "source": "iana" },
  "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] },
  "application/vnd.imagemeter.folder+zip": { "source": "iana", "compressible": false },
  "application/vnd.imagemeter.image+zip": { "source": "iana", "compressible": false },
  "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] },
  "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] },
  "application/vnd.ims.imsccv1p1": { "source": "iana" },
  "application/vnd.ims.imsccv1p2": { "source": "iana" },
  "application/vnd.ims.imsccv1p3": { "source": "iana" },
  "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true },
  "application/vnd.informedcontrol.rms+xml": { "source": "iana", "compressible": true },
  "application/vnd.informix-visionary": { "source": "apache" },
  "application/vnd.infotech.project": { "source": "iana" },
  "application/vnd.infotech.project+xml": { "source": "iana", "compressible": true },
  "application/vnd.innopath.wamp.notification": { "source": "iana" },
  "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] },
  "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] },
  "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] },
  "application/vnd.intertrust.digibox": { "source": "iana" },
  "application/vnd.intertrust.nncp": { "source": "iana" },
  "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] },
  "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] },
  "application/vnd.ipfs.ipns-record": { "source": "iana" },
  "application/vnd.ipld.car": { "source": "iana" },
  "application/vnd.ipld.dag-cbor": { "source": "iana" },
  "application/vnd.ipld.dag-json": { "source": "iana" },
  "application/vnd.ipld.raw": { "source": "iana" },
  "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.packageitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.planningitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] },
  "application/vnd.irepository.package+xml": { "source": "iana", "compressible": true, "extensions": ["irp"] },
  "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] },
  "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] },
  "application/vnd.iso11783-10+zip": { "source": "iana", "compressible": false },
  "application/vnd.jam": { "source": "iana", "extensions": ["jam"] },
  "application/vnd.japannet-directory-service": { "source": "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-payment-wakeup": { "source": "iana" },
  "application/vnd.japannet-registration": { "source": "iana" },
  "application/vnd.japannet-registration-wakeup": { "source": "iana" },
  "application/vnd.japannet-setstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-verification": { "source": "iana" },
  "application/vnd.japannet-verification-wakeup": { "source": "iana" },
  "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] },
  "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] },
  "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] },
  "application/vnd.jsk.isdn-ngn": { "source": "iana" },
  "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] },
  "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] },
  "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] },
  "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] },
  "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] },
  "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] },
  "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] },
  "application/vnd.kdl": { "source": "iana" },
  "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] },
  "application/vnd.keyman.kmp+zip": { "source": "iana", "compressible": false },
  "application/vnd.keyman.kmx": { "source": "iana" },
  "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] },
  "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] },
  "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] },
  "application/vnd.las": { "source": "iana" },
  "application/vnd.las.las+json": { "source": "iana", "compressible": true },
  "application/vnd.las.las+xml": { "source": "iana", "compressible": true, "extensions": ["lasxml"] },
  "application/vnd.laszip": { "source": "iana" },
  "application/vnd.ldev.productlicensing": { "source": "iana" },
  "application/vnd.leap+json": { "source": "iana", "compressible": true },
  "application/vnd.liberty-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "compressible": true, "extensions": ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { "source": "iana", "compressible": false },
  "application/vnd.loom": { "source": "iana" },
  "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] },
  "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] },
  "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] },
  "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] },
  "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] },
  "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] },
  "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] },
  "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { "source": "iana", "extensions": ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.conftoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.license+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.mdcf": { "source": "iana" },
  "application/vnd.mason+json": { "source": "iana", "compressible": true },
  "application/vnd.maxar.archive.3tz+zip": { "source": "iana", "compressible": false },
  "application/vnd.maxmind.maxmind-db": { "source": "iana" },
  "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] },
  "application/vnd.mdl": { "source": "iana" },
  "application/vnd.mdl-mbsdf": { "source": "iana" },
  "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] },
  "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] },
  "application/vnd.medicalholodeck.recordxr": { "source": "iana" },
  "application/vnd.meridian-slingshot": { "source": "iana" },
  "application/vnd.mermaid": { "source": "iana" },
  "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] },
  "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] },
  "application/vnd.micro+json": { "source": "iana", "compressible": true },
  "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] },
  "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] },
  "application/vnd.microsoft.portable-executable": { "source": "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
  "application/vnd.miele+json": { "source": "iana", "compressible": true },
  "application/vnd.mif": { "source": "iana", "extensions": ["mif"] },
  "application/vnd.minisoft-hp3000-save": { "source": "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
  "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] },
  "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] },
  "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] },
  "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] },
  "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] },
  "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] },
  "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] },
  "application/vnd.modl": { "source": "iana" },
  "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] },
  "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] },
  "application/vnd.motorola.flexsuite": { "source": "iana" },
  "application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
  "application/vnd.motorola.flexsuite.fis": { "source": "iana" },
  "application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
  "application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
  "application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
  "application/vnd.motorola.flexsuite.wem": { "source": "iana" },
  "application/vnd.motorola.iprm": { "source": "iana" },
  "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] },
  "application/vnd.ms-3mfdocument": { "source": "iana" },
  "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] },
  "application/vnd.ms-asf": { "source": "iana" },
  "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] },
  "application/vnd.ms-color.iccprofile": { "source": "apache" },
  "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] },
  "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] },
  "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] },
  "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] },
  "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] },
  "application/vnd.ms-office.activex+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] },
  "application/vnd.ms-opentype": { "source": "apache", "compressible": true },
  "application/vnd.ms-outlook": { "compressible": false, "extensions": ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
  "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] },
  "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-printing.printticket+xml": { "source": "apache", "compressible": true },
  "application/vnd.ms-printschematicket+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { "source": "iana" },
  "application/vnd.ms-visio.viewer": { "extensions": ["vdx"] },
  "application/vnd.ms-windows.devicepairing": { "source": "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
  "application/vnd.ms-windows.printerpairing": { "source": "iana" },
  "application/vnd.ms-windows.wsd.oob": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] },
  "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] },
  "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] },
  "application/vnd.msa-disk-image": { "source": "iana" },
  "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] },
  "application/vnd.msgpack": { "source": "iana" },
  "application/vnd.msign": { "source": "iana" },
  "application/vnd.multiad.creator": { "source": "iana" },
  "application/vnd.multiad.creator.cif": { "source": "iana" },
  "application/vnd.music-niff": { "source": "iana" },
  "application/vnd.musician": { "source": "iana", "extensions": ["mus"] },
  "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] },
  "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { "source": "iana", "compressible": true },
  "application/vnd.nato.bindingdataobject+cbor": { "source": "iana" },
  "application/vnd.nato.bindingdataobject+json": { "source": "iana", "compressible": true },
  "application/vnd.nato.bindingdataobject+xml": { "source": "iana", "compressible": true, "extensions": ["bdo"] },
  "application/vnd.nato.openxmlformats-package.iepd+zip": { "source": "iana", "compressible": false },
  "application/vnd.ncd.control": { "source": "iana" },
  "application/vnd.ncd.reference": { "source": "iana" },
  "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true },
  "application/vnd.nebumind.line": { "source": "iana" },
  "application/vnd.nervana": { "source": "iana" },
  "application/vnd.netfpx": { "source": "iana" },
  "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] },
  "application/vnd.nimn": { "source": "iana" },
  "application/vnd.nintendo.nitro.rom": { "source": "iana" },
  "application/vnd.nintendo.snes.rom": { "source": "iana" },
  "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] },
  "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] },
  "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] },
  "application/vnd.nokia.catalogs": { "source": "iana" },
  "application/vnd.nokia.conml+wbxml": { "source": "iana" },
  "application/vnd.nokia.conml+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.iptv.config+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.isds-radio-presets": { "source": "iana" },
  "application/vnd.nokia.landmark+wbxml": { "source": "iana" },
  "application/vnd.nokia.landmark+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.landmarkcollection+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.n-gage.ac+xml": { "source": "iana", "compressible": true, "extensions": ["ac"] },
  "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { "source": "apache", "extensions": ["n-gage"] },
  "application/vnd.nokia.ncd": { "source": "iana" },
  "application/vnd.nokia.pcd+wbxml": { "source": "iana" },
  "application/vnd.nokia.pcd+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] },
  "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] },
  "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] },
  "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] },
  "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] },
  "application/vnd.ntt-local.content-share": { "source": "iana" },
  "application/vnd.ntt-local.file-transfer": { "source": "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
  "application/vnd.oai.workflows": { "source": "iana" },
  "application/vnd.oai.workflows+json": { "source": "iana", "compressible": true },
  "application/vnd.oai.workflows+yaml": { "source": "iana" },
  "application/vnd.oasis.opendocument.base": { "source": "iana" },
  "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] },
  "application/vnd.oasis.opendocument.database": { "source": "apache", "extensions": ["odb"] },
  "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] },
  "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] },
  "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] },
  "application/vnd.oasis.opendocument.text-master-template": { "source": "iana" },
  "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] },
  "application/vnd.obn": { "source": "iana" },
  "application/vnd.ocf+cbor": { "source": "iana" },
  "application/vnd.oci.image.manifest.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
  "application/vnd.oipf.dae.svg+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.dae.xhtml+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.pae.gem": { "source": "iana" },
  "application/vnd.oipf.spdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.spdlist+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.ueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.userprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] },
  "application/vnd.oma-scws-config": { "source": "iana" },
  "application/vnd.oma-scws-http-request": { "source": "iana" },
  "application/vnd.oma-scws-http-response": { "source": "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.drm-trigger+xml": { "source": "apache", "compressible": true },
  "application/vnd.oma.bcast.imd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.ltkm": { "source": "iana" },
  "application/vnd.oma.bcast.notification+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
  "application/vnd.oma.bcast.sgboot": { "source": "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sgdu": { "source": "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "apache", "compressible": true },
  "application/vnd.oma.bcast.sprov+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.stkm": { "source": "iana" },
  "application/vnd.oma.cab-address-book+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-feature-handler+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-pcc+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-subs-invite+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-user-prefs+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.dcd": { "source": "iana" },
  "application/vnd.oma.dcdc": { "source": "iana" },
  "application/vnd.oma.dd2+xml": { "source": "iana", "compressible": true, "extensions": ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.group-usage-list+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+cbor": { "source": "iana" },
  "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+tlv": { "source": "iana" },
  "application/vnd.oma.pal+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.final-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.groups+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.push": { "source": "iana" },
  "application/vnd.oma.scidm.messages+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.xcap-directory+xml": { "source": "iana", "compressible": true },
  "application/vnd.omads-email+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-file+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-folder+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omaloc-supl-init": { "source": "iana" },
  "application/vnd.onepager": { "source": "iana" },
  "application/vnd.onepagertamp": { "source": "iana" },
  "application/vnd.onepagertamx": { "source": "iana" },
  "application/vnd.onepagertat": { "source": "iana" },
  "application/vnd.onepagertatp": { "source": "iana" },
  "application/vnd.onepagertatx": { "source": "iana" },
  "application/vnd.onvif.metadata": { "source": "iana" },
  "application/vnd.openblox.game+xml": { "source": "iana", "compressible": true, "extensions": ["obgx"] },
  "application/vnd.openblox.game-binary": { "source": "iana" },
  "application/vnd.openeye.oeb": { "source": "iana" },
  "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { "source": "iana", "compressible": true, "extensions": ["osm"] },
  "application/vnd.opentimestamps.ots": { "source": "iana" },
  "application/vnd.openvpi.dspx+json": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "iana", "extensions": ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "iana", "extensions": ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "iana", "extensions": ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana", "compressible": true },
  "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true },
  "application/vnd.orange.indata": { "source": "iana" },
  "application/vnd.osa.netdeploy": { "source": "iana" },
  "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] },
  "application/vnd.osgi.bundle": { "source": "iana" },
  "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] },
  "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] },
  "application/vnd.otps.ct-kip+xml": { "source": "iana", "compressible": true },
  "application/vnd.oxli.countgraph": { "source": "iana" },
  "application/vnd.pagerduty+json": { "source": "iana", "compressible": true },
  "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { "source": "iana" },
  "application/vnd.paos.xml": { "source": "iana" },
  "application/vnd.patentdive": { "source": "iana" },
  "application/vnd.patientecommsdoc": { "source": "iana" },
  "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] },
  "application/vnd.pcos": { "source": "iana" },
  "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] },
  "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] },
  "application/vnd.piaccess.application-licence": { "source": "iana" },
  "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] },
  "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { "source": "iana", "compressible": true },
  "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] },
  "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] },
  "application/vnd.powerbuilder6-s": { "source": "iana" },
  "application/vnd.powerbuilder7": { "source": "iana" },
  "application/vnd.powerbuilder7-s": { "source": "iana" },
  "application/vnd.powerbuilder75": { "source": "iana" },
  "application/vnd.powerbuilder75-s": { "source": "iana" },
  "application/vnd.preminet": { "source": "iana" },
  "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] },
  "application/vnd.procrate.brushset": { "extensions": ["brushset"] },
  "application/vnd.procreate.brush": { "extensions": ["brush"] },
  "application/vnd.procreate.dream": { "extensions": ["drm"] },
  "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] },
  "application/vnd.psfs": { "source": "iana" },
  "application/vnd.pt.mundusmundi": { "source": "iana" },
  "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] },
  "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] },
  "application/vnd.pwg-multiplexed": { "source": "iana" },
  "application/vnd.pwg-xhtml-print+xml": { "source": "iana", "compressible": true, "extensions": ["xhtm"] },
  "application/vnd.qualcomm.brew-app-res": { "source": "iana" },
  "application/vnd.quarantainenet": { "source": "iana" },
  "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { "source": "iana" },
  "application/vnd.radisys.moml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana", "compressible": true },
  "application/vnd.rainstor.data": { "source": "iana" },
  "application/vnd.rapid": { "source": "iana" },
  "application/vnd.rar": { "source": "iana", "extensions": ["rar"] },
  "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] },
  "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { "source": "iana", "compressible": true, "extensions": ["musicxml"] },
  "application/vnd.relpipe": { "source": "iana" },
  "application/vnd.renlearn.rlprint": { "source": "iana" },
  "application/vnd.resilient.logic": { "source": "iana" },
  "application/vnd.restful+json": { "source": "iana", "compressible": true },
  "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] },
  "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] },
  "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] },
  "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] },
  "application/vnd.route66.link66+xml": { "source": "iana", "compressible": true, "extensions": ["link66"] },
  "application/vnd.rs-274x": { "source": "iana" },
  "application/vnd.ruckus.download": { "source": "iana" },
  "application/vnd.s3sms": { "source": "iana" },
  "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] },
  "application/vnd.sar": { "source": "iana" },
  "application/vnd.sbm.cid": { "source": "iana" },
  "application/vnd.sbm.mid2": { "source": "iana" },
  "application/vnd.scribus": { "source": "iana" },
  "application/vnd.sealed.3df": { "source": "iana" },
  "application/vnd.sealed.csf": { "source": "iana" },
  "application/vnd.sealed.doc": { "source": "iana" },
  "application/vnd.sealed.eml": { "source": "iana" },
  "application/vnd.sealed.mht": { "source": "iana" },
  "application/vnd.sealed.net": { "source": "iana" },
  "application/vnd.sealed.ppt": { "source": "iana" },
  "application/vnd.sealed.tiff": { "source": "iana" },
  "application/vnd.sealed.xls": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.html": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
  "application/vnd.seemail": { "source": "iana", "extensions": ["see"] },
  "application/vnd.seis+json": { "source": "iana", "compressible": true },
  "application/vnd.sema": { "source": "iana", "extensions": ["sema"] },
  "application/vnd.semd": { "source": "iana", "extensions": ["semd"] },
  "application/vnd.semf": { "source": "iana", "extensions": ["semf"] },
  "application/vnd.shade-save-file": { "source": "iana" },
  "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] },
  "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] },
  "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] },
  "application/vnd.shootproof+json": { "source": "iana", "compressible": true },
  "application/vnd.shopkick+json": { "source": "iana", "compressible": true },
  "application/vnd.shp": { "source": "iana" },
  "application/vnd.shx": { "source": "iana" },
  "application/vnd.sigrok.session": { "source": "iana" },
  "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] },
  "application/vnd.siren+json": { "source": "iana", "compressible": true },
  "application/vnd.sketchometry": { "source": "iana" },
  "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] },
  "application/vnd.smart.notebook": { "source": "iana" },
  "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] },
  "application/vnd.smintio.portals.archive": { "source": "iana" },
  "application/vnd.snesdev-page-table": { "source": "iana" },
  "application/vnd.software602.filler.form+xml": { "source": "iana", "compressible": true, "extensions": ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
  "application/vnd.solent.sdkm+xml": { "source": "iana", "compressible": true, "extensions": ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] },
  "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] },
  "application/vnd.sqlite3": { "source": "iana" },
  "application/vnd.sss-cod": { "source": "iana" },
  "application/vnd.sss-dtf": { "source": "iana" },
  "application/vnd.sss-ntf": { "source": "iana" },
  "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] },
  "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] },
  "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] },
  "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] },
  "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] },
  "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] },
  "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] },
  "application/vnd.street-stream": { "source": "iana" },
  "application/vnd.sun.wadl+xml": { "source": "iana", "compressible": true, "extensions": ["wadl"] },
  "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] },
  "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] },
  "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] },
  "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] },
  "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] },
  "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] },
  "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] },
  "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] },
  "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] },
  "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] },
  "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] },
  "application/vnd.svd": { "source": "iana", "extensions": ["svd"] },
  "application/vnd.swiftview-ics": { "source": "iana" },
  "application/vnd.sybyl.mol2": { "source": "iana" },
  "application/vnd.sycle+xml": { "source": "iana", "compressible": true },
  "application/vnd.syft+json": { "source": "iana", "compressible": true },
  "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] },
  "application/vnd.syncml+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["bdm"] },
  "application/vnd.syncml.dm+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xdm"] },
  "application/vnd.syncml.dm.notification": { "source": "iana" },
  "application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmddf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmtnds+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.syncml.ds.notification": { "source": "iana" },
  "application/vnd.tableschema+json": { "source": "iana", "compressible": true },
  "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] },
  "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { "source": "iana", "compressible": true },
  "application/vnd.tmd.mediaflex.api+xml": { "source": "iana", "compressible": true },
  "application/vnd.tml": { "source": "iana" },
  "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] },
  "application/vnd.tri.onesource": { "source": "iana" },
  "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] },
  "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] },
  "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] },
  "application/vnd.truedoc": { "source": "iana" },
  "application/vnd.ubisoft.webplayer": { "source": "iana" },
  "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] },
  "application/vnd.uic.osdm+json": { "source": "iana", "compressible": true },
  "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] },
  "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] },
  "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] },
  "application/vnd.uoml+xml": { "source": "iana", "compressible": true, "extensions": ["uoml", "uo"] },
  "application/vnd.uplanet.alert": { "source": "iana" },
  "application/vnd.uplanet.alert-wbxml": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
  "application/vnd.uplanet.cacheop": { "source": "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
  "application/vnd.uplanet.channel": { "source": "iana" },
  "application/vnd.uplanet.channel-wbxml": { "source": "iana" },
  "application/vnd.uplanet.list": { "source": "iana" },
  "application/vnd.uplanet.list-wbxml": { "source": "iana" },
  "application/vnd.uplanet.listcmd": { "source": "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
  "application/vnd.uplanet.signal": { "source": "iana" },
  "application/vnd.uri-map": { "source": "iana" },
  "application/vnd.valve.source.material": { "source": "iana" },
  "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] },
  "application/vnd.vd-study": { "source": "iana" },
  "application/vnd.vectorworks": { "source": "iana" },
  "application/vnd.vel+json": { "source": "iana", "compressible": true },
  "application/vnd.veraison.tsm-report+cbor": { "source": "iana" },
  "application/vnd.veraison.tsm-report+json": { "source": "iana", "compressible": true },
  "application/vnd.verimatrix.vcas": { "source": "iana" },
  "application/vnd.veritone.aion+json": { "source": "iana", "compressible": true },
  "application/vnd.veryant.thin": { "source": "iana" },
  "application/vnd.ves.encrypted": { "source": "iana" },
  "application/vnd.vidsoft.vidconference": { "source": "iana" },
  "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw", "vsdx", "vtx"] },
  "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] },
  "application/vnd.vividence.scriptfile": { "source": "iana" },
  "application/vnd.vocalshaper.vsp4": { "source": "iana" },
  "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] },
  "application/vnd.wap.sic": { "source": "iana" },
  "application/vnd.wap.slc": { "source": "iana" },
  "application/vnd.wap.wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["wbxml"] },
  "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] },
  "application/vnd.wasmflow.wafl": { "source": "iana" },
  "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] },
  "application/vnd.wfa.dpp": { "source": "iana" },
  "application/vnd.wfa.p2p": { "source": "iana" },
  "application/vnd.wfa.wsc": { "source": "iana" },
  "application/vnd.windows.devicepairing": { "source": "iana" },
  "application/vnd.wmc": { "source": "iana" },
  "application/vnd.wmf.bootstrap": { "source": "iana" },
  "application/vnd.wolfram.mathematica": { "source": "iana" },
  "application/vnd.wolfram.mathematica.package": { "source": "iana" },
  "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] },
  "application/vnd.wordlift": { "source": "iana" },
  "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] },
  "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { "source": "iana" },
  "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] },
  "application/vnd.wv.csp+wbxml": { "source": "iana" },
  "application/vnd.wv.csp+xml": { "source": "iana", "compressible": true },
  "application/vnd.wv.ssp+xml": { "source": "iana", "compressible": true },
  "application/vnd.xacml+json": { "source": "iana", "compressible": true },
  "application/vnd.xara": { "source": "iana", "extensions": ["xar"] },
  "application/vnd.xarin.cpj": { "source": "iana" },
  "application/vnd.xecrets-encrypted": { "source": "iana" },
  "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] },
  "application/vnd.xfdl.webform": { "source": "iana" },
  "application/vnd.xmi+xml": { "source": "iana", "compressible": true },
  "application/vnd.xmpie.cpkg": { "source": "iana" },
  "application/vnd.xmpie.dpkg": { "source": "iana" },
  "application/vnd.xmpie.plan": { "source": "iana" },
  "application/vnd.xmpie.ppkg": { "source": "iana" },
  "application/vnd.xmpie.xlim": { "source": "iana" },
  "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] },
  "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] },
  "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "compressible": true, "extensions": ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { "source": "iana" },
  "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] },
  "application/vnd.yamaha.through-ngn": { "source": "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
  "application/vnd.yaoweme": { "source": "iana" },
  "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] },
  "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { "source": "iana", "compressible": true, "extensions": ["zaz"] },
  "application/voicexml+xml": { "source": "iana", "compressible": true, "extensions": ["vxml"] },
  "application/voucher-cms+json": { "source": "iana", "compressible": true },
  "application/voucher-jws+json": { "source": "iana", "compressible": true },
  "application/vp": { "source": "iana" },
  "application/vp+cose": { "source": "iana" },
  "application/vp+jwt": { "source": "iana" },
  "application/vq-rtcpxr": { "source": "iana" },
  "application/wasm": { "source": "iana", "compressible": true, "extensions": ["wasm"] },
  "application/watcherinfo+xml": { "source": "iana", "compressible": true, "extensions": ["wif"] },
  "application/webpush-options+json": { "source": "iana", "compressible": true },
  "application/whoispp-query": { "source": "iana" },
  "application/whoispp-response": { "source": "iana" },
  "application/widget": { "source": "iana", "extensions": ["wgt"] },
  "application/winhlp": { "source": "apache", "extensions": ["hlp"] },
  "application/wita": { "source": "iana" },
  "application/wordperfect5.1": { "source": "iana" },
  "application/wsdl+xml": { "source": "iana", "compressible": true, "extensions": ["wsdl"] },
  "application/wspolicy+xml": { "source": "iana", "compressible": true, "extensions": ["wspolicy"] },
  "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] },
  "application/x-abiword": { "source": "apache", "extensions": ["abw"] },
  "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] },
  "application/x-amf": { "source": "apache" },
  "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] },
  "application/x-arj": { "compressible": false, "extensions": ["arj"] },
  "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] },
  "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] },
  "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] },
  "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] },
  "application/x-blender": { "extensions": ["blend"] },
  "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] },
  "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] },
  "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] },
  "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] },
  "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] },
  "application/x-chat": { "source": "apache", "extensions": ["chat"] },
  "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] },
  "application/x-chrome-extension": { "extensions": ["crx"] },
  "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] },
  "application/x-compress": { "source": "apache" },
  "application/x-compressed": { "extensions": ["rar"] },
  "application/x-conference": { "source": "apache", "extensions": ["nsc"] },
  "application/x-cpio": { "source": "apache", "extensions": ["cpio"] },
  "application/x-csh": { "source": "apache", "extensions": ["csh"] },
  "application/x-deb": { "compressible": false },
  "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] },
  "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] },
  "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { "source": "apache", "extensions": ["wad"] },
  "application/x-dtbncx+xml": { "source": "apache", "compressible": true, "extensions": ["ncx"] },
  "application/x-dtbook+xml": { "source": "apache", "compressible": true, "extensions": ["dtb"] },
  "application/x-dtbresource+xml": { "source": "apache", "compressible": true, "extensions": ["res"] },
  "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] },
  "application/x-envoy": { "source": "apache", "extensions": ["evy"] },
  "application/x-eva": { "source": "apache", "extensions": ["eva"] },
  "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] },
  "application/x-font-dos": { "source": "apache" },
  "application/x-font-framemaker": { "source": "apache" },
  "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] },
  "application/x-font-libgrx": { "source": "apache" },
  "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] },
  "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] },
  "application/x-font-snf": { "source": "apache", "extensions": ["snf"] },
  "application/x-font-speedo": { "source": "apache" },
  "application/x-font-sunos-news": { "source": "apache" },
  "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { "source": "apache" },
  "application/x-freearc": { "source": "apache", "extensions": ["arc"] },
  "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] },
  "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] },
  "application/x-glulx": { "source": "apache", "extensions": ["ulx"] },
  "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] },
  "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] },
  "application/x-gtar": { "source": "apache", "extensions": ["gtar"] },
  "application/x-gzip": { "source": "apache" },
  "application/x-hdf": { "source": "apache", "extensions": ["hdf"] },
  "application/x-httpd-php": { "compressible": true, "extensions": ["php"] },
  "application/x-install-instructions": { "source": "apache", "extensions": ["install"] },
  "application/x-ipynb+json": { "compressible": true, "extensions": ["ipynb"] },
  "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] },
  "application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
  "application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
  "application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
  "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] },
  "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] },
  "application/x-javascript": { "compressible": true },
  "application/x-keepass2": { "extensions": ["kdbx"] },
  "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] },
  "application/x-lua-bytecode": { "extensions": ["luac"] },
  "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] },
  "application/x-makeself": { "source": "nginx", "extensions": ["run"] },
  "application/x-mie": { "source": "apache", "extensions": ["mie"] },
  "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] },
  "application/x-mpegurl": { "compressible": false },
  "application/x-ms-application": { "source": "apache", "extensions": ["application"] },
  "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] },
  "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] },
  "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] },
  "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] },
  "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] },
  "application/x-msbinder": { "source": "apache", "extensions": ["obd"] },
  "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] },
  "application/x-msclip": { "source": "apache", "extensions": ["clp"] },
  "application/x-msdos-program": { "extensions": ["exe"] },
  "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { "source": "apache", "extensions": ["mny"] },
  "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] },
  "application/x-msschedule": { "source": "apache", "extensions": ["scd"] },
  "application/x-msterminal": { "source": "apache", "extensions": ["trm"] },
  "application/x-mswrite": { "source": "apache", "extensions": ["wri"] },
  "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] },
  "application/x-nzb": { "source": "apache", "extensions": ["nzb"] },
  "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] },
  "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] },
  "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] },
  "application/x-pki-message": { "source": "iana" },
  "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] },
  "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] },
  "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] },
  "application/x-sea": { "source": "nginx", "extensions": ["sea"] },
  "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] },
  "application/x-shar": { "source": "apache", "extensions": ["shar"] },
  "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] },
  "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] },
  "application/x-sql": { "source": "apache", "extensions": ["sql"] },
  "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] },
  "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] },
  "application/x-subrip": { "source": "apache", "extensions": ["srt"] },
  "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] },
  "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] },
  "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] },
  "application/x-tads": { "source": "apache", "extensions": ["gam"] },
  "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] },
  "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] },
  "application/x-tex": { "source": "apache", "extensions": ["tex"] },
  "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] },
  "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] },
  "application/x-tgif": { "source": "apache", "extensions": ["obj"] },
  "application/x-ustar": { "source": "apache", "extensions": ["ustar"] },
  "application/x-virtualbox-hdd": { "compressible": true, "extensions": ["hdd"] },
  "application/x-virtualbox-ova": { "compressible": true, "extensions": ["ova"] },
  "application/x-virtualbox-ovf": { "compressible": true, "extensions": ["ovf"] },
  "application/x-virtualbox-vbox": { "compressible": true, "extensions": ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { "compressible": false, "extensions": ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { "compressible": true, "extensions": ["vdi"] },
  "application/x-virtualbox-vhd": { "compressible": true, "extensions": ["vhd"] },
  "application/x-virtualbox-vmdk": { "compressible": true, "extensions": ["vmdk"] },
  "application/x-wais-source": { "source": "apache", "extensions": ["src"] },
  "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] },
  "application/x-www-form-urlencoded": { "source": "iana", "compressible": true },
  "application/x-x509-ca-cert": { "source": "iana", "extensions": ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { "source": "iana" },
  "application/x-x509-next-ca-cert": { "source": "iana" },
  "application/x-xfig": { "source": "apache", "extensions": ["fig"] },
  "application/x-xliff+xml": { "source": "apache", "compressible": true, "extensions": ["xlf"] },
  "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] },
  "application/x-xz": { "source": "apache", "extensions": ["xz"] },
  "application/x-zip-compressed": { "extensions": ["zip"] },
  "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { "source": "iana" },
  "application/xacml+xml": { "source": "iana", "compressible": true },
  "application/xaml+xml": { "source": "apache", "compressible": true, "extensions": ["xaml"] },
  "application/xcap-att+xml": { "source": "iana", "compressible": true, "extensions": ["xav"] },
  "application/xcap-caps+xml": { "source": "iana", "compressible": true, "extensions": ["xca"] },
  "application/xcap-diff+xml": { "source": "iana", "compressible": true, "extensions": ["xdf"] },
  "application/xcap-el+xml": { "source": "iana", "compressible": true, "extensions": ["xel"] },
  "application/xcap-error+xml": { "source": "iana", "compressible": true },
  "application/xcap-ns+xml": { "source": "iana", "compressible": true, "extensions": ["xns"] },
  "application/xcon-conference-info+xml": { "source": "iana", "compressible": true },
  "application/xcon-conference-info-diff+xml": { "source": "iana", "compressible": true },
  "application/xenc+xml": { "source": "iana", "compressible": true, "extensions": ["xenc"] },
  "application/xfdf": { "source": "iana", "extensions": ["xfdf"] },
  "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { "source": "apache", "compressible": true },
  "application/xliff+xml": { "source": "iana", "compressible": true, "extensions": ["xlf"] },
  "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] },
  "application/xml-external-parsed-entity": { "source": "iana" },
  "application/xml-patch+xml": { "source": "iana", "compressible": true },
  "application/xmpp+xml": { "source": "iana", "compressible": true },
  "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] },
  "application/xproc+xml": { "source": "apache", "compressible": true, "extensions": ["xpl"] },
  "application/xslt+xml": { "source": "iana", "compressible": true, "extensions": ["xsl", "xslt"] },
  "application/xspf+xml": { "source": "apache", "compressible": true, "extensions": ["xspf"] },
  "application/xv+xml": { "source": "iana", "compressible": true, "extensions": ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yaml": { "source": "iana" },
  "application/yang": { "source": "iana", "extensions": ["yang"] },
  "application/yang-data+cbor": { "source": "iana" },
  "application/yang-data+json": { "source": "iana", "compressible": true },
  "application/yang-data+xml": { "source": "iana", "compressible": true },
  "application/yang-patch+json": { "source": "iana", "compressible": true },
  "application/yang-patch+xml": { "source": "iana", "compressible": true },
  "application/yang-sid+json": { "source": "iana", "compressible": true },
  "application/yin+xml": { "source": "iana", "compressible": true, "extensions": ["yin"] },
  "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] },
  "application/zip+dotlottie": { "extensions": ["lottie"] },
  "application/zlib": { "source": "iana" },
  "application/zstd": { "source": "iana" },
  "audio/1d-interleaved-parityfec": { "source": "iana" },
  "audio/32kadpcm": { "source": "iana" },
  "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] },
  "audio/3gpp2": { "source": "iana" },
  "audio/aac": { "source": "iana", "extensions": ["adts", "aac"] },
  "audio/ac3": { "source": "iana" },
  "audio/adpcm": { "source": "apache", "extensions": ["adp"] },
  "audio/amr": { "source": "iana", "extensions": ["amr"] },
  "audio/amr-wb": { "source": "iana" },
  "audio/amr-wb+": { "source": "iana" },
  "audio/aptx": { "source": "iana" },
  "audio/asc": { "source": "iana" },
  "audio/atrac-advanced-lossless": { "source": "iana" },
  "audio/atrac-x": { "source": "iana" },
  "audio/atrac3": { "source": "iana" },
  "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] },
  "audio/bv16": { "source": "iana" },
  "audio/bv32": { "source": "iana" },
  "audio/clearmode": { "source": "iana" },
  "audio/cn": { "source": "iana" },
  "audio/dat12": { "source": "iana" },
  "audio/dls": { "source": "iana" },
  "audio/dsr-es201108": { "source": "iana" },
  "audio/dsr-es202050": { "source": "iana" },
  "audio/dsr-es202211": { "source": "iana" },
  "audio/dsr-es202212": { "source": "iana" },
  "audio/dv": { "source": "iana" },
  "audio/dvi4": { "source": "iana" },
  "audio/eac3": { "source": "iana" },
  "audio/encaprtp": { "source": "iana" },
  "audio/evrc": { "source": "iana" },
  "audio/evrc-qcp": { "source": "iana" },
  "audio/evrc0": { "source": "iana" },
  "audio/evrc1": { "source": "iana" },
  "audio/evrcb": { "source": "iana" },
  "audio/evrcb0": { "source": "iana" },
  "audio/evrcb1": { "source": "iana" },
  "audio/evrcnw": { "source": "iana" },
  "audio/evrcnw0": { "source": "iana" },
  "audio/evrcnw1": { "source": "iana" },
  "audio/evrcwb": { "source": "iana" },
  "audio/evrcwb0": { "source": "iana" },
  "audio/evrcwb1": { "source": "iana" },
  "audio/evs": { "source": "iana" },
  "audio/flac": { "source": "iana" },
  "audio/flexfec": { "source": "iana" },
  "audio/fwdred": { "source": "iana" },
  "audio/g711-0": { "source": "iana" },
  "audio/g719": { "source": "iana" },
  "audio/g722": { "source": "iana" },
  "audio/g7221": { "source": "iana" },
  "audio/g723": { "source": "iana" },
  "audio/g726-16": { "source": "iana" },
  "audio/g726-24": { "source": "iana" },
  "audio/g726-32": { "source": "iana" },
  "audio/g726-40": { "source": "iana" },
  "audio/g728": { "source": "iana" },
  "audio/g729": { "source": "iana" },
  "audio/g7291": { "source": "iana" },
  "audio/g729d": { "source": "iana" },
  "audio/g729e": { "source": "iana" },
  "audio/gsm": { "source": "iana" },
  "audio/gsm-efr": { "source": "iana" },
  "audio/gsm-hr-08": { "source": "iana" },
  "audio/ilbc": { "source": "iana" },
  "audio/ip-mr_v2.5": { "source": "iana" },
  "audio/isac": { "source": "apache" },
  "audio/l16": { "source": "iana" },
  "audio/l20": { "source": "iana" },
  "audio/l24": { "source": "iana", "compressible": false },
  "audio/l8": { "source": "iana" },
  "audio/lpc": { "source": "iana" },
  "audio/matroska": { "source": "iana" },
  "audio/melp": { "source": "iana" },
  "audio/melp1200": { "source": "iana" },
  "audio/melp2400": { "source": "iana" },
  "audio/melp600": { "source": "iana" },
  "audio/mhas": { "source": "iana" },
  "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] },
  "audio/midi-clip": { "source": "iana" },
  "audio/mobile-xmf": { "source": "iana", "extensions": ["mxmf"] },
  "audio/mp3": { "compressible": false, "extensions": ["mp3"] },
  "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a", "m4b"] },
  "audio/mp4a-latm": { "source": "iana" },
  "audio/mpa": { "source": "iana" },
  "audio/mpa-robust": { "source": "iana" },
  "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { "source": "iana" },
  "audio/musepack": { "source": "apache" },
  "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { "source": "iana" },
  "audio/parityfec": { "source": "iana" },
  "audio/pcma": { "source": "iana" },
  "audio/pcma-wb": { "source": "iana" },
  "audio/pcmu": { "source": "iana" },
  "audio/pcmu-wb": { "source": "iana" },
  "audio/prs.sid": { "source": "iana" },
  "audio/qcelp": { "source": "iana" },
  "audio/raptorfec": { "source": "iana" },
  "audio/red": { "source": "iana" },
  "audio/rtp-enc-aescm128": { "source": "iana" },
  "audio/rtp-midi": { "source": "iana" },
  "audio/rtploopback": { "source": "iana" },
  "audio/rtx": { "source": "iana" },
  "audio/s3m": { "source": "apache", "extensions": ["s3m"] },
  "audio/scip": { "source": "iana" },
  "audio/silk": { "source": "apache", "extensions": ["sil"] },
  "audio/smv": { "source": "iana" },
  "audio/smv-qcp": { "source": "iana" },
  "audio/smv0": { "source": "iana" },
  "audio/sofa": { "source": "iana" },
  "audio/sp-midi": { "source": "iana" },
  "audio/speex": { "source": "iana" },
  "audio/t140c": { "source": "iana" },
  "audio/t38": { "source": "iana" },
  "audio/telephone-event": { "source": "iana" },
  "audio/tetra_acelp": { "source": "iana" },
  "audio/tetra_acelp_bb": { "source": "iana" },
  "audio/tone": { "source": "iana" },
  "audio/tsvcis": { "source": "iana" },
  "audio/uemclip": { "source": "iana" },
  "audio/ulpfec": { "source": "iana" },
  "audio/usac": { "source": "iana" },
  "audio/vdvi": { "source": "iana" },
  "audio/vmr-wb": { "source": "iana" },
  "audio/vnd.3gpp.iufp": { "source": "iana" },
  "audio/vnd.4sb": { "source": "iana" },
  "audio/vnd.audiokoz": { "source": "iana" },
  "audio/vnd.celp": { "source": "iana" },
  "audio/vnd.cisco.nse": { "source": "iana" },
  "audio/vnd.cmles.radio-events": { "source": "iana" },
  "audio/vnd.cns.anp1": { "source": "iana" },
  "audio/vnd.cns.inf1": { "source": "iana" },
  "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] },
  "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] },
  "audio/vnd.dlna.adts": { "source": "iana" },
  "audio/vnd.dolby.heaac.1": { "source": "iana" },
  "audio/vnd.dolby.heaac.2": { "source": "iana" },
  "audio/vnd.dolby.mlp": { "source": "iana" },
  "audio/vnd.dolby.mps": { "source": "iana" },
  "audio/vnd.dolby.pl2": { "source": "iana" },
  "audio/vnd.dolby.pl2x": { "source": "iana" },
  "audio/vnd.dolby.pl2z": { "source": "iana" },
  "audio/vnd.dolby.pulse.1": { "source": "iana" },
  "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] },
  "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] },
  "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] },
  "audio/vnd.dts.uhd": { "source": "iana" },
  "audio/vnd.dvb.file": { "source": "iana" },
  "audio/vnd.everad.plj": { "source": "iana" },
  "audio/vnd.hns.audio": { "source": "iana" },
  "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { "source": "iana" },
  "audio/vnd.nortel.vbk": { "source": "iana" },
  "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] },
  "audio/vnd.octel.sbc": { "source": "iana" },
  "audio/vnd.presonus.multitrack": { "source": "iana" },
  "audio/vnd.qcelp": { "source": "apache" },
  "audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
  "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] },
  "audio/vnd.rn-realaudio": { "compressible": false },
  "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
  "audio/vnd.vmx.cvsd": { "source": "iana" },
  "audio/vnd.wave": { "compressible": false },
  "audio/vorbis": { "source": "iana", "compressible": false },
  "audio/vorbis-config": { "source": "iana" },
  "audio/wav": { "compressible": false, "extensions": ["wav"] },
  "audio/wave": { "compressible": false, "extensions": ["wav"] },
  "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] },
  "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] },
  "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] },
  "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] },
  "audio/x-flac": { "source": "apache", "extensions": ["flac"] },
  "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] },
  "audio/x-matroska": { "source": "apache", "extensions": ["mka"] },
  "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] },
  "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] },
  "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] },
  "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] },
  "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] },
  "audio/x-tta": { "source": "apache" },
  "audio/x-wav": { "source": "apache", "extensions": ["wav"] },
  "audio/xm": { "source": "apache", "extensions": ["xm"] },
  "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] },
  "chemical/x-cif": { "source": "apache", "extensions": ["cif"] },
  "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] },
  "chemical/x-cml": { "source": "apache", "extensions": ["cml"] },
  "chemical/x-csml": { "source": "apache", "extensions": ["csml"] },
  "chemical/x-pdb": { "source": "apache" },
  "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] },
  "font/collection": { "source": "iana", "extensions": ["ttc"] },
  "font/otf": { "source": "iana", "compressible": true, "extensions": ["otf"] },
  "font/sfnt": { "source": "iana" },
  "font/ttf": { "source": "iana", "compressible": true, "extensions": ["ttf"] },
  "font/woff": { "source": "iana", "extensions": ["woff"] },
  "font/woff2": { "source": "iana", "extensions": ["woff2"] },
  "image/aces": { "source": "iana", "extensions": ["exr"] },
  "image/apng": { "source": "iana", "compressible": false, "extensions": ["apng"] },
  "image/avci": { "source": "iana", "extensions": ["avci"] },
  "image/avcs": { "source": "iana", "extensions": ["avcs"] },
  "image/avif": { "source": "iana", "compressible": false, "extensions": ["avif"] },
  "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp", "dib"] },
  "image/cgm": { "source": "iana", "extensions": ["cgm"] },
  "image/dicom-rle": { "source": "iana", "extensions": ["drle"] },
  "image/dpx": { "source": "iana", "extensions": ["dpx"] },
  "image/emf": { "source": "iana", "extensions": ["emf"] },
  "image/fits": { "source": "iana", "extensions": ["fits"] },
  "image/g3fax": { "source": "iana", "extensions": ["g3"] },
  "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] },
  "image/heic": { "source": "iana", "extensions": ["heic"] },
  "image/heic-sequence": { "source": "iana", "extensions": ["heics"] },
  "image/heif": { "source": "iana", "extensions": ["heif"] },
  "image/heif-sequence": { "source": "iana", "extensions": ["heifs"] },
  "image/hej2k": { "source": "iana", "extensions": ["hej2"] },
  "image/ief": { "source": "iana", "extensions": ["ief"] },
  "image/j2c": { "source": "iana" },
  "image/jaii": { "source": "iana", "extensions": ["jaii"] },
  "image/jais": { "source": "iana", "extensions": ["jais"] },
  "image/jls": { "source": "iana", "extensions": ["jls"] },
  "image/jp2": { "source": "iana", "compressible": false, "extensions": ["jp2", "jpg2"] },
  "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpg", "jpeg", "jpe"] },
  "image/jph": { "source": "iana", "extensions": ["jph"] },
  "image/jphc": { "source": "iana", "extensions": ["jhc"] },
  "image/jpm": { "source": "iana", "compressible": false, "extensions": ["jpm", "jpgm"] },
  "image/jpx": { "source": "iana", "compressible": false, "extensions": ["jpx", "jpf"] },
  "image/jxl": { "source": "iana", "extensions": ["jxl"] },
  "image/jxr": { "source": "iana", "extensions": ["jxr"] },
  "image/jxra": { "source": "iana", "extensions": ["jxra"] },
  "image/jxrs": { "source": "iana", "extensions": ["jxrs"] },
  "image/jxs": { "source": "iana", "extensions": ["jxs"] },
  "image/jxsc": { "source": "iana", "extensions": ["jxsc"] },
  "image/jxsi": { "source": "iana", "extensions": ["jxsi"] },
  "image/jxss": { "source": "iana", "extensions": ["jxss"] },
  "image/ktx": { "source": "iana", "extensions": ["ktx"] },
  "image/ktx2": { "source": "iana", "extensions": ["ktx2"] },
  "image/naplps": { "source": "iana" },
  "image/pjpeg": { "compressible": false, "extensions": ["jfif"] },
  "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] },
  "image/prs.btif": { "source": "iana", "extensions": ["btif", "btf"] },
  "image/prs.pti": { "source": "iana", "extensions": ["pti"] },
  "image/pwg-raster": { "source": "iana" },
  "image/sgi": { "source": "apache", "extensions": ["sgi"] },
  "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] },
  "image/t38": { "source": "iana", "extensions": ["t38"] },
  "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tif", "tiff"] },
  "image/tiff-fx": { "source": "iana", "extensions": ["tfx"] },
  "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] },
  "image/vnd.airzip.accelerator.azv": { "source": "iana", "extensions": ["azv"] },
  "image/vnd.clip": { "source": "iana" },
  "image/vnd.cns.inf2": { "source": "iana" },
  "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] },
  "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] },
  "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] },
  "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] },
  "image/vnd.fst": { "source": "iana", "extensions": ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] },
  "image/vnd.globalgraphics.pgb": { "source": "iana" },
  "image/vnd.microsoft.icon": { "source": "iana", "compressible": true, "extensions": ["ico"] },
  "image/vnd.mix": { "source": "iana" },
  "image/vnd.mozilla.apng": { "source": "iana" },
  "image/vnd.ms-dds": { "compressible": true, "extensions": ["dds"] },
  "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] },
  "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] },
  "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] },
  "image/vnd.pco.b16": { "source": "iana", "extensions": ["b16"] },
  "image/vnd.radiance": { "source": "iana" },
  "image/vnd.sealed.png": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
  "image/vnd.svf": { "source": "iana" },
  "image/vnd.tencent.tap": { "source": "iana", "extensions": ["tap"] },
  "image/vnd.valve.source.texture": { "source": "iana", "extensions": ["vtf"] },
  "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] },
  "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] },
  "image/vnd.zbrush.pcx": { "source": "iana", "extensions": ["pcx"] },
  "image/webp": { "source": "iana", "extensions": ["webp"] },
  "image/wmf": { "source": "iana", "extensions": ["wmf"] },
  "image/x-3ds": { "source": "apache", "extensions": ["3ds"] },
  "image/x-adobe-dng": { "extensions": ["dng"] },
  "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] },
  "image/x-cmx": { "source": "apache", "extensions": ["cmx"] },
  "image/x-emf": { "source": "iana" },
  "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] },
  "image/x-jng": { "source": "nginx", "extensions": ["jng"] },
  "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] },
  "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] },
  "image/x-pcx": { "source": "apache", "extensions": ["pcx"] },
  "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] },
  "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] },
  "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] },
  "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] },
  "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] },
  "image/x-rgb": { "source": "apache", "extensions": ["rgb"] },
  "image/x-tga": { "source": "apache", "extensions": ["tga"] },
  "image/x-wmf": { "source": "iana" },
  "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] },
  "image/x-xcf": { "compressible": false },
  "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] },
  "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] },
  "message/bhttp": { "source": "iana" },
  "message/cpim": { "source": "iana" },
  "message/delivery-status": { "source": "iana" },
  "message/disposition-notification": { "source": "iana", "extensions": ["disposition-notification"] },
  "message/external-body": { "source": "iana" },
  "message/feedback-report": { "source": "iana" },
  "message/global": { "source": "iana", "extensions": ["u8msg"] },
  "message/global-delivery-status": { "source": "iana", "extensions": ["u8dsn"] },
  "message/global-disposition-notification": { "source": "iana", "extensions": ["u8mdn"] },
  "message/global-headers": { "source": "iana", "extensions": ["u8hdr"] },
  "message/http": { "source": "iana", "compressible": false },
  "message/imdn+xml": { "source": "iana", "compressible": true },
  "message/mls": { "source": "iana" },
  "message/news": { "source": "apache" },
  "message/ohttp-req": { "source": "iana" },
  "message/ohttp-res": { "source": "iana" },
  "message/partial": { "source": "iana", "compressible": false },
  "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime", "mht", "mhtml"] },
  "message/s-http": { "source": "apache" },
  "message/sip": { "source": "iana" },
  "message/sipfrag": { "source": "iana" },
  "message/tracking-status": { "source": "iana" },
  "message/vnd.si.simp": { "source": "apache" },
  "message/vnd.wfa.wsc": { "source": "iana", "extensions": ["wsc"] },
  "model/3mf": { "source": "iana", "extensions": ["3mf"] },
  "model/e57": { "source": "iana" },
  "model/gltf+json": { "source": "iana", "compressible": true, "extensions": ["gltf"] },
  "model/gltf-binary": { "source": "iana", "compressible": true, "extensions": ["glb"] },
  "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] },
  "model/jt": { "source": "iana", "extensions": ["jt"] },
  "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] },
  "model/mtl": { "source": "iana", "extensions": ["mtl"] },
  "model/obj": { "source": "iana", "extensions": ["obj"] },
  "model/prc": { "source": "iana", "extensions": ["prc"] },
  "model/step": { "source": "iana", "extensions": ["step", "stp", "stpnc", "p21", "210"] },
  "model/step+xml": { "source": "iana", "compressible": true, "extensions": ["stpx"] },
  "model/step+zip": { "source": "iana", "compressible": false, "extensions": ["stpz"] },
  "model/step-xml+zip": { "source": "iana", "compressible": false, "extensions": ["stpxz"] },
  "model/stl": { "source": "iana", "extensions": ["stl"] },
  "model/u3d": { "source": "iana", "extensions": ["u3d"] },
  "model/vnd.bary": { "source": "iana", "extensions": ["bary"] },
  "model/vnd.cld": { "source": "iana", "extensions": ["cld"] },
  "model/vnd.collada+xml": { "source": "iana", "compressible": true, "extensions": ["dae"] },
  "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] },
  "model/vnd.flatland.3dml": { "source": "iana" },
  "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] },
  "model/vnd.gs-gdl": { "source": "apache" },
  "model/vnd.gs.gdl": { "source": "iana" },
  "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] },
  "model/vnd.moml+xml": { "source": "iana", "compressible": true },
  "model/vnd.mts": { "source": "iana", "extensions": ["mts"] },
  "model/vnd.opengex": { "source": "iana", "extensions": ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { "source": "iana", "extensions": ["x_b"] },
  "model/vnd.parasolid.transmit.text": { "source": "iana", "extensions": ["x_t"] },
  "model/vnd.pytha.pyox": { "source": "iana", "extensions": ["pyo", "pyox"] },
  "model/vnd.rosette.annotated-data-model": { "source": "iana" },
  "model/vnd.sap.vds": { "source": "iana", "extensions": ["vds"] },
  "model/vnd.usda": { "source": "iana", "extensions": ["usda"] },
  "model/vnd.usdz+zip": { "source": "iana", "compressible": false, "extensions": ["usdz"] },
  "model/vnd.valve.source.compiled-map": { "source": "iana", "extensions": ["bsp"] },
  "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] },
  "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] },
  "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { "source": "iana", "extensions": ["x3db"] },
  "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] },
  "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] },
  "model/x3d-vrml": { "source": "iana", "extensions": ["x3dv"] },
  "multipart/alternative": { "source": "iana", "compressible": false },
  "multipart/appledouble": { "source": "iana" },
  "multipart/byteranges": { "source": "iana" },
  "multipart/digest": { "source": "iana" },
  "multipart/encrypted": { "source": "iana", "compressible": false },
  "multipart/form-data": { "source": "iana", "compressible": false },
  "multipart/header-set": { "source": "iana" },
  "multipart/mixed": { "source": "iana" },
  "multipart/multilingual": { "source": "iana" },
  "multipart/parallel": { "source": "iana" },
  "multipart/related": { "source": "iana", "compressible": false },
  "multipart/report": { "source": "iana" },
  "multipart/signed": { "source": "iana", "compressible": false },
  "multipart/vnd.bint.med-plus": { "source": "iana" },
  "multipart/voice-message": { "source": "iana" },
  "multipart/x-mixed-replace": { "source": "iana" },
  "text/1d-interleaved-parityfec": { "source": "iana" },
  "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] },
  "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] },
  "text/calender": { "compressible": true },
  "text/cmd": { "compressible": true },
  "text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
  "text/cql": { "source": "iana" },
  "text/cql-expression": { "source": "iana" },
  "text/cql-identifier": { "source": "iana" },
  "text/css": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["css"] },
  "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] },
  "text/csv-schema": { "source": "iana" },
  "text/directory": { "source": "iana" },
  "text/dns": { "source": "iana" },
  "text/ecmascript": { "source": "apache" },
  "text/encaprtp": { "source": "iana" },
  "text/enriched": { "source": "iana" },
  "text/fhirpath": { "source": "iana" },
  "text/flexfec": { "source": "iana" },
  "text/fwdred": { "source": "iana" },
  "text/gff3": { "source": "iana" },
  "text/grammar-ref-list": { "source": "iana" },
  "text/hl7v2": { "source": "iana" },
  "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] },
  "text/jade": { "extensions": ["jade"] },
  "text/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js", "mjs"] },
  "text/jcr-cnd": { "source": "iana" },
  "text/jsx": { "compressible": true, "extensions": ["jsx"] },
  "text/less": { "compressible": true, "extensions": ["less"] },
  "text/markdown": { "source": "iana", "compressible": true, "extensions": ["md", "markdown"] },
  "text/mathml": { "source": "nginx", "extensions": ["mml"] },
  "text/mdx": { "compressible": true, "extensions": ["mdx"] },
  "text/mizar": { "source": "iana" },
  "text/n3": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["n3"] },
  "text/parameters": { "source": "iana", "charset": "UTF-8" },
  "text/parityfec": { "source": "iana" },
  "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { "source": "iana", "charset": "UTF-8" },
  "text/prs.fallenstein.rst": { "source": "iana" },
  "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] },
  "text/prs.prop.logic": { "source": "iana" },
  "text/prs.texi": { "source": "iana" },
  "text/raptorfec": { "source": "iana" },
  "text/red": { "source": "iana" },
  "text/rfc822-headers": { "source": "iana" },
  "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] },
  "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "text/rtp-enc-aescm128": { "source": "iana" },
  "text/rtploopback": { "source": "iana" },
  "text/rtx": { "source": "iana" },
  "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] },
  "text/shaclc": { "source": "iana" },
  "text/shex": { "source": "iana", "extensions": ["shex"] },
  "text/slim": { "extensions": ["slim", "slm"] },
  "text/spdx": { "source": "iana", "extensions": ["spdx"] },
  "text/strings": { "source": "iana" },
  "text/stylus": { "extensions": ["stylus", "styl"] },
  "text/t140": { "source": "iana" },
  "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] },
  "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { "source": "iana", "charset": "UTF-8", "extensions": ["ttl"] },
  "text/ulpfec": { "source": "iana" },
  "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] },
  "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] },
  "text/vnd.a": { "source": "iana" },
  "text/vnd.abc": { "source": "iana" },
  "text/vnd.ascii-art": { "source": "iana" },
  "text/vnd.curl": { "source": "iana", "extensions": ["curl"] },
  "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] },
  "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] },
  "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] },
  "text/vnd.debian.copyright": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.dmclientscript": { "source": "iana" },
  "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.exchangeable": { "source": "iana" },
  "text/vnd.familysearch.gedcom": { "source": "iana", "extensions": ["ged"] },
  "text/vnd.ficlab.flt": { "source": "iana" },
  "text/vnd.fly": { "source": "iana", "extensions": ["fly"] },
  "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] },
  "text/vnd.gml": { "source": "iana" },
  "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] },
  "text/vnd.hans": { "source": "iana" },
  "text/vnd.hgl": { "source": "iana" },
  "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] },
  "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] },
  "text/vnd.iptc.newsml": { "source": "iana" },
  "text/vnd.iptc.nitf": { "source": "iana" },
  "text/vnd.latex-z": { "source": "iana" },
  "text/vnd.motorola.reflex": { "source": "iana" },
  "text/vnd.ms-mediapackage": { "source": "iana" },
  "text/vnd.net2phone.commcenter.command": { "source": "iana" },
  "text/vnd.radisys.msml-basic-layout": { "source": "iana" },
  "text/vnd.senx.warpscript": { "source": "iana" },
  "text/vnd.si.uricatalogue": { "source": "apache" },
  "text/vnd.sosi": { "source": "iana" },
  "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "charset": "UTF-8", "extensions": ["jad"] },
  "text/vnd.trolltech.linguist": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.vcf": { "source": "iana" },
  "text/vnd.wap.si": { "source": "iana" },
  "text/vnd.wap.sl": { "source": "iana" },
  "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] },
  "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] },
  "text/vnd.zoo.kcl": { "source": "iana" },
  "text/vtt": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] },
  "text/wgsl": { "source": "iana", "extensions": ["wgsl"] },
  "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] },
  "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { "source": "nginx", "extensions": ["htc"] },
  "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { "compressible": true },
  "text/x-handlebars-template": { "extensions": ["hbs"] },
  "text/x-java-source": { "source": "apache", "extensions": ["java"] },
  "text/x-jquery-tmpl": { "compressible": true },
  "text/x-lua": { "extensions": ["lua"] },
  "text/x-markdown": { "compressible": true, "extensions": ["mkd"] },
  "text/x-nfo": { "source": "apache", "extensions": ["nfo"] },
  "text/x-opml": { "source": "apache", "extensions": ["opml"] },
  "text/x-org": { "compressible": true, "extensions": ["org"] },
  "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] },
  "text/x-processing": { "compressible": true, "extensions": ["pde"] },
  "text/x-sass": { "extensions": ["sass"] },
  "text/x-scss": { "extensions": ["scss"] },
  "text/x-setext": { "source": "apache", "extensions": ["etx"] },
  "text/x-sfv": { "source": "apache", "extensions": ["sfv"] },
  "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] },
  "text/x-uuencode": { "source": "apache", "extensions": ["uu"] },
  "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] },
  "text/x-vcard": { "source": "apache", "extensions": ["vcf"] },
  "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] },
  "text/xml-external-parsed-entity": { "source": "iana" },
  "text/yaml": { "compressible": true, "extensions": ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { "source": "iana" },
  "video/3gpp": { "source": "iana", "extensions": ["3gp", "3gpp"] },
  "video/3gpp-tt": { "source": "iana" },
  "video/3gpp2": { "source": "iana", "extensions": ["3g2"] },
  "video/av1": { "source": "iana" },
  "video/bmpeg": { "source": "iana" },
  "video/bt656": { "source": "iana" },
  "video/celb": { "source": "iana" },
  "video/dv": { "source": "iana" },
  "video/encaprtp": { "source": "iana" },
  "video/evc": { "source": "iana" },
  "video/ffv1": { "source": "iana" },
  "video/flexfec": { "source": "iana" },
  "video/h261": { "source": "iana", "extensions": ["h261"] },
  "video/h263": { "source": "iana", "extensions": ["h263"] },
  "video/h263-1998": { "source": "iana" },
  "video/h263-2000": { "source": "iana" },
  "video/h264": { "source": "iana", "extensions": ["h264"] },
  "video/h264-rcdo": { "source": "iana" },
  "video/h264-svc": { "source": "iana" },
  "video/h265": { "source": "iana" },
  "video/h266": { "source": "iana" },
  "video/iso.segment": { "source": "iana", "extensions": ["m4s"] },
  "video/jpeg": { "source": "iana", "extensions": ["jpgv"] },
  "video/jpeg2000": { "source": "iana" },
  "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] },
  "video/jxsv": { "source": "iana" },
  "video/lottie+json": { "source": "iana", "compressible": true },
  "video/matroska": { "source": "iana" },
  "video/matroska-3d": { "source": "iana" },
  "video/mj2": { "source": "iana", "extensions": ["mj2", "mjp2"] },
  "video/mp1s": { "source": "iana" },
  "video/mp2p": { "source": "iana" },
  "video/mp2t": { "source": "iana", "extensions": ["ts", "m2t", "m2ts", "mts"] },
  "video/mp4": { "source": "iana", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { "source": "iana" },
  "video/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { "source": "iana" },
  "video/mpv": { "source": "iana" },
  "video/nv": { "source": "iana" },
  "video/ogg": { "source": "iana", "compressible": false, "extensions": ["ogv"] },
  "video/parityfec": { "source": "iana" },
  "video/pointer": { "source": "iana" },
  "video/quicktime": { "source": "iana", "compressible": false, "extensions": ["qt", "mov"] },
  "video/raptorfec": { "source": "iana" },
  "video/raw": { "source": "iana" },
  "video/rtp-enc-aescm128": { "source": "iana" },
  "video/rtploopback": { "source": "iana" },
  "video/rtx": { "source": "iana" },
  "video/scip": { "source": "iana" },
  "video/smpte291": { "source": "iana" },
  "video/smpte292m": { "source": "iana" },
  "video/ulpfec": { "source": "iana" },
  "video/vc1": { "source": "iana" },
  "video/vc2": { "source": "iana" },
  "video/vnd.cctv": { "source": "iana" },
  "video/vnd.dece.hd": { "source": "iana", "extensions": ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { "source": "iana", "extensions": ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { "source": "iana" },
  "video/vnd.dece.pd": { "source": "iana", "extensions": ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { "source": "iana", "extensions": ["uvs", "uvvs"] },
  "video/vnd.dece.video": { "source": "iana", "extensions": ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { "source": "iana" },
  "video/vnd.directv.mpeg-tts": { "source": "iana" },
  "video/vnd.dlna.mpeg-tts": { "source": "iana" },
  "video/vnd.dvb.file": { "source": "iana", "extensions": ["dvb"] },
  "video/vnd.fvt": { "source": "iana", "extensions": ["fvt"] },
  "video/vnd.hns.video": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.ttsavc": { "source": "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
  "video/vnd.motorola.video": { "source": "iana" },
  "video/vnd.motorola.videop": { "source": "iana" },
  "video/vnd.mpegurl": { "source": "iana", "extensions": ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { "source": "iana", "extensions": ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
  "video/vnd.nokia.mp4vr": { "source": "iana" },
  "video/vnd.nokia.videovoip": { "source": "iana" },
  "video/vnd.objectvideo": { "source": "iana" },
  "video/vnd.planar": { "source": "iana" },
  "video/vnd.radgamettools.bink": { "source": "iana" },
  "video/vnd.radgamettools.smacker": { "source": "apache" },
  "video/vnd.sealed.mpeg1": { "source": "iana" },
  "video/vnd.sealed.mpeg4": { "source": "iana" },
  "video/vnd.sealed.swf": { "source": "iana" },
  "video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
  "video/vnd.uvvu.mp4": { "source": "iana", "extensions": ["uvu", "uvvu"] },
  "video/vnd.vivo": { "source": "iana", "extensions": ["viv"] },
  "video/vnd.youtube.yt": { "source": "iana" },
  "video/vp8": { "source": "iana" },
  "video/vp9": { "source": "iana" },
  "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] },
  "video/x-f4v": { "source": "apache", "extensions": ["f4v"] },
  "video/x-fli": { "source": "apache", "extensions": ["fli"] },
  "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] },
  "video/x-m4v": { "source": "apache", "extensions": ["m4v"] },
  "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] },
  "video/x-mng": { "source": "apache", "extensions": ["mng"] },
  "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] },
  "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] },
  "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] },
  "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] },
  "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] },
  "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] },
  "video/x-msvideo": { "source": "apache", "extensions": ["avi"] },
  "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] },
  "video/x-smv": { "source": "apache", "extensions": ["smv"] },
  "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] },
  "x-shader/x-fragment": { "compressible": true },
  "x-shader/x-vertex": { "compressible": true }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb;
var hasRequiredMimeDb;
function requireMimeDb() {
  if (hasRequiredMimeDb) return mimeDb;
  hasRequiredMimeDb = 1;
  mimeDb = require$$0$1;
  return mimeDb;
}
var mimeScore;
var hasRequiredMimeScore;
function requireMimeScore() {
  if (hasRequiredMimeScore) return mimeScore;
  hasRequiredMimeScore = 1;
  var FACET_SCORES = {
    "prs.": 100,
    "x-": 200,
    "x.": 300,
    "vnd.": 400,
    default: 900
  };
  var SOURCE_SCORES = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30
    // definitions added by `jshttp/mime-db` project?
  };
  var TYPE_SCORES = {
    // prefer application/xml over text/xml
    // prefer application/rtf over text/rtf
    application: 1,
    // prefer font/woff over application/font-woff
    font: 2,
    default: 0
  };
  mimeScore = function mimeScore2(mimeType, source2 = "default") {
    if (mimeType === "application/octet-stream") {
      return 0;
    }
    const [type2, subtype] = mimeType.split("/");
    const facet = subtype.replace(/(\.|x-).*/, "$1");
    const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
    const sourceScore = SOURCE_SCORES[source2] || SOURCE_SCORES.default;
    const typeScore = TYPE_SCORES[type2] || TYPE_SCORES.default;
    const lengthScore = 1 - mimeType.length / 100;
    return facetScore + sourceScore + typeScore + lengthScore;
  };
  return mimeScore;
}
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMimeTypes;
function requireMimeTypes() {
  if (hasRequiredMimeTypes) return mimeTypes;
  hasRequiredMimeTypes = 1;
  (function(exports) {
    var db = requireMimeDb();
    var extname = require$$1$2.extname;
    var mimeScore2 = requireMimeScore();
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset2;
    exports.charsets = { lookup: charset2 };
    exports.contentType = contentType2;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    exports._extensionConflicts = [];
    populateMaps(exports.extensions, exports.types);
    function charset2(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType2(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset3 = exports.charset(mime);
        if (charset3) mime += "; charset=" + charset3.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().slice(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          types2[extension2] = _preferredType(extension2, types2[extension2], type2);
          const legacyType = _preferredTypeLegacy(
            extension2,
            types2[extension2],
            type2
          );
          if (legacyType !== types2[extension2]) {
            exports._extensionConflicts.push([extension2, legacyType, types2[extension2]]);
          }
        }
      });
    }
    function _preferredType(ext, type0, type1) {
      var score0 = type0 ? mimeScore2(type0, db[type0].source) : 0;
      var score1 = type1 ? mimeScore2(type1, db[type1].source) : 0;
      return score0 > score1 ? type0 : type1;
    }
    function _preferredTypeLegacy(ext, type0, type1) {
      var SOURCE_RANK = ["nginx", "apache", void 0, "iana"];
      var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
      var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
      if (exports.types[extension] !== "application/octet-stream" && (score0 > score1 || score0 === score1 && exports.types[extension]?.slice(0, 12) === "application/")) {
        return type0;
      }
      return score0 > score1 ? type0 : type1;
    }
  })(mimeTypes);
  return mimeTypes;
}
var mediaTyper = {};
/*!
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMediaTyper;
function requireMediaTyper() {
  if (hasRequiredMediaTyper) return mediaTyper;
  hasRequiredMediaTyper = 1;
  var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
  mediaTyper.format = format;
  mediaTyper.parse = parse3;
  mediaTyper.test = test;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type2 = obj.type;
    if (!type2 || !TYPE_NAME_REGEXP.test(type2)) {
      throw new TypeError("invalid type");
    }
    if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
      throw new TypeError("invalid subtype");
    }
    var string = type2 + "/" + subtype;
    if (suffix) {
      if (!TYPE_NAME_REGEXP.test(suffix)) {
        throw new TypeError("invalid suffix");
      }
      string += "+" + suffix;
    }
    return string;
  }
  function test(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    if (typeof string !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    return TYPE_REGEXP.test(string.toLowerCase());
  }
  function parse3(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    if (typeof string !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var match = TYPE_REGEXP.exec(string.toLowerCase());
    if (!match) {
      throw new TypeError("invalid media type");
    }
    var type2 = match[1];
    var subtype = match[2];
    var suffix;
    var index = subtype.lastIndexOf("+");
    if (index !== -1) {
      suffix = subtype.substr(index + 1);
      subtype = subtype.substr(0, index);
    }
    return new MediaType(type2, subtype, suffix);
  }
  function MediaType(type2, subtype, suffix) {
    this.type = type2;
    this.subtype = subtype;
    this.suffix = suffix;
  }
  return mediaTyper;
}
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredTypeIs;
function requireTypeIs() {
  if (hasRequiredTypeIs) return typeIs.exports;
  hasRequiredTypeIs = 1;
  var contentType2 = requireContentType();
  var mime = requireMimeTypes();
  var typer = requireMediaTyper();
  typeIs.exports = typeofrequest;
  typeIs.exports.is = typeis;
  typeIs.exports.hasBody = hasbody;
  typeIs.exports.normalize = normalize;
  typeIs.exports.match = mimeMatch;
  function typeis(value, types_) {
    var i;
    var types2 = types_;
    var val = tryNormalizeType(value);
    if (!val) {
      return false;
    }
    if (types2 && !Array.isArray(types2)) {
      types2 = new Array(arguments.length - 1);
      for (i = 0; i < types2.length; i++) {
        types2[i] = arguments[i + 1];
      }
    }
    if (!types2 || !types2.length) {
      return val;
    }
    var type2;
    for (i = 0; i < types2.length; i++) {
      if (mimeMatch(normalize(type2 = types2[i]), val)) {
        return type2[0] === "+" || type2.indexOf("*") !== -1 ? val : type2;
      }
    }
    return false;
  }
  function hasbody(req) {
    return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
  }
  function typeofrequest(req, types_) {
    if (!hasbody(req)) return null;
    var types2 = arguments.length > 2 ? Array.prototype.slice.call(arguments, 1) : types_;
    var value = req.headers["content-type"];
    return typeis(value, types2);
  }
  function normalize(type2) {
    if (typeof type2 !== "string") {
      return false;
    }
    switch (type2) {
      case "urlencoded":
        return "application/x-www-form-urlencoded";
      case "multipart":
        return "multipart/*";
    }
    if (type2[0] === "+") {
      return "*/*" + type2;
    }
    return type2.indexOf("/") === -1 ? mime.lookup(type2) : type2;
  }
  function mimeMatch(expected, actual) {
    if (expected === false) {
      return false;
    }
    var actualParts = actual.split("/");
    var expectedParts = expected.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }
    if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
      return false;
    }
    if (expectedParts[1].slice(0, 2) === "*+") {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].slice(1) === actualParts[1].slice(1 - expectedParts[1].length);
    }
    if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
      return false;
    }
    return true;
  }
  function normalizeType(value) {
    var type2 = contentType2.parse(value).type;
    return typer.test(type2) ? type2 : null;
  }
  function tryNormalizeType(value) {
    try {
      return value ? normalizeType(value) : null;
    } catch (err) {
      return null;
    }
  }
  return typeIs.exports;
}
var utils$2;
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  var bytes2 = requireBytes();
  var contentType2 = requireContentType();
  var typeis = requireTypeIs();
  utils$2 = {
    getCharset,
    normalizeOptions
  };
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch {
      return void 0;
    }
  }
  function typeChecker(type2) {
    return function checkType(req) {
      return Boolean(typeis(req, type2));
    };
  }
  function normalizeOptions(options, defaultType) {
    if (!defaultType) {
      throw new TypeError("defaultType must be provided");
    }
    var inflate = options?.inflate !== false;
    var limit = typeof options?.limit !== "number" ? bytes2.parse(options?.limit || "100kb") : options?.limit;
    var type2 = options?.type || defaultType;
    var verify = options?.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type2 !== "function" ? typeChecker(type2) : type2;
    return {
      inflate,
      limit,
      verify,
      shouldParse
    };
  }
  return utils$2;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var json_1;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json_1;
  hasRequiredJson = 1;
  var createError = requireHttpErrors();
  var debug = require$$0$8("body-parser:json");
  var isFinished = requireOnFinished().isFinished;
  var read2 = requireRead();
  var typeis = requireTypeIs();
  var { getCharset, normalizeOptions } = requireUtils$2();
  json_1 = json;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  var JSON_SYNTAX_CHAR = "#";
  var JSON_SYNTAX_REGEXP = /#+/g;
  function json(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "application/json");
    var reviver = options?.reviver;
    var strict = options?.strict !== false;
    function parse3(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first = firstchar(body);
        if (first !== "{" && first !== "[") {
          debug("strict violation");
          throw createStrictSyntaxError(body, first);
        }
      }
      try {
        debug("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    return function jsonParser(req, res, next) {
      if (isFinished(req)) {
        debug("body already parsed");
        next();
        return;
      }
      if (!("body" in req)) {
        req.body = void 0;
      }
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || "utf-8";
      if (charset2.slice(0, 4) !== "utf-") {
        debug("invalid charset");
        next(createError(415, 'unsupported charset "' + charset2.toUpperCase() + '"', {
          charset: charset2,
          type: "charset.unsupported"
        }));
        return;
      }
      read2(req, res, next, parse3, debug, {
        encoding: charset2,
        inflate,
        limit,
        verify
      });
    };
  }
  function createStrictSyntaxError(str, char) {
    var index = str.indexOf(char);
    var partial = "";
    if (index !== -1) {
      partial = str.substring(0, index) + JSON_SYNTAX_CHAR;
      for (var i = index + 1; i < str.length; i++) {
        partial += JSON_SYNTAX_CHAR;
      }
    }
    try {
      JSON.parse(partial);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
          return str.substring(index, index + placeholder.length);
        }),
        stack: e.stack
      });
    }
  }
  function firstchar(str) {
    var match = FIRST_CHAR_REGEXP.exec(str);
    return match ? match[1] : void 0;
  }
  function normalizeJsonSyntaxError(error, obj) {
    var keys = Object.getOwnPropertyNames(error);
    for (var i = 0; i < keys.length; i++) {
      var key2 = keys[i];
      if (key2 !== "stack" && key2 !== "message") {
        delete error[key2];
      }
    }
    error.stack = obj.stack.replace(error.message, obj.message);
    error.message = obj.message;
    return error;
  }
  return json_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var raw_1;
var hasRequiredRaw;
function requireRaw() {
  if (hasRequiredRaw) return raw_1;
  hasRequiredRaw = 1;
  var debug = require$$0$8("body-parser:raw");
  var isFinished = requireOnFinished().isFinished;
  var read2 = requireRead();
  var typeis = requireTypeIs();
  var { normalizeOptions } = requireUtils$2();
  raw_1 = raw;
  function raw(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "application/octet-stream");
    function parse3(buf) {
      return buf;
    }
    return function rawParser(req, res, next) {
      if (isFinished(req)) {
        debug("body already parsed");
        next();
        return;
      }
      if (!("body" in req)) {
        req.body = void 0;
      }
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      read2(req, res, next, parse3, debug, {
        encoding: null,
        inflate,
        limit,
        verify
      });
    };
  }
  return raw_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var text_1;
var hasRequiredText;
function requireText() {
  if (hasRequiredText) return text_1;
  hasRequiredText = 1;
  var debug = require$$0$8("body-parser:text");
  var isFinished = requireOnFinished().isFinished;
  var read2 = requireRead();
  var typeis = requireTypeIs();
  var { getCharset, normalizeOptions } = requireUtils$2();
  text_1 = text;
  function text(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "text/plain");
    var defaultCharset = options?.defaultCharset || "utf-8";
    function parse3(buf) {
      return buf;
    }
    return function textParser(req, res, next) {
      if (isFinished(req)) {
        debug("body already parsed");
        next();
        return;
      }
      if (!("body" in req)) {
        req.body = void 0;
      }
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || defaultCharset;
      read2(req, res, next, parse3, debug, {
        encoding: charset2,
        inflate,
        limit,
        verify
      });
    };
  }
  return text_1;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList) return sideChannelList;
  hasRequiredSideChannelList = 1;
  var inspect2 = /* @__PURE__ */ requireObjectInspect();
  var $TypeError = /* @__PURE__ */ requireType();
  var listGetNode = function(list, key2, isDelete) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) != null; prev = curr) {
      if (curr.key === key2) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key2) {
    if (!objects) {
      return void 0;
    }
    var node = listGetNode(objects, key2);
    return node && node.value;
  };
  var listSet = function(objects, key2, value) {
    var node = listGetNode(objects, key2);
    if (node) {
      node.value = value;
    } else {
      objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key: key2,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key2) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key2);
  };
  var listDelete = function(objects, key2) {
    if (objects) {
      return listGetNode(objects, key2, true);
    }
  };
  sideChannelList = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError("Side channel does not contain " + inspect2(key2));
        }
      },
      "delete": function(key2) {
        var root2 = $o && $o.next;
        var deletedNode = listDelete($o, key2);
        if (deletedNode && root2 && root2 === deletedNode) {
          $o = void 0;
        }
        return !!deletedNode;
      },
      get: function(key2) {
        return listGet($o, key2);
      },
      has: function(key2) {
        return listHas($o, key2);
      },
      set: function(key2, value) {
        if (!$o) {
          $o = {
            next: void 0
          };
        }
        listSet(
          /** @type {NonNullable<typeof $o>} */
          $o,
          key2,
          value
        );
      }
    };
    return channel;
  };
  return sideChannelList;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign$1;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign$1;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign$1 = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign$1;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = requireFunctionBind();
  hasown = bind.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void undefined$1;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap) return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect2 = /* @__PURE__ */ requireObjectInspect();
  var $TypeError = /* @__PURE__ */ requireType();
  var $Map = GetIntrinsic("%Map%", true);
  var $mapGet = callBound2("Map.prototype.get", true);
  var $mapSet = callBound2("Map.prototype.set", true);
  var $mapHas = callBound2("Map.prototype.has", true);
  var $mapDelete = callBound2("Map.prototype.delete", true);
  var $mapSize = callBound2("Map.prototype.size", true);
  sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
  function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError("Side channel does not contain " + inspect2(key2));
        }
      },
      "delete": function(key2) {
        if ($m) {
          var result = $mapDelete($m, key2);
          if ($mapSize($m) === 0) {
            $m = void 0;
          }
          return result;
        }
        return false;
      },
      get: function(key2) {
        if ($m) {
          return $mapGet($m, key2);
        }
      },
      has: function(key2) {
        if ($m) {
          return $mapHas($m, key2);
        }
        return false;
      },
      set: function(key2, value) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key2, value);
      }
    };
    return channel;
  };
  return sideChannelMap;
}
var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect2 = /* @__PURE__ */ requireObjectInspect();
  var getSideChannelMap = requireSideChannelMap();
  var $TypeError = /* @__PURE__ */ requireType();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $weakMapGet = callBound2("WeakMap.prototype.get", true);
  var $weakMapSet = callBound2("WeakMap.prototype.set", true);
  var $weakMapHas = callBound2("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound2("WeakMap.prototype.delete", true);
  sideChannelWeakmap = $WeakMap ? (
    /** @type {Exclude<import('.'), false>} */
    function getSideChannelWeakMap() {
      var $wm;
      var $m;
      var channel = {
        assert: function(key2) {
          if (!channel.has(key2)) {
            throw new $TypeError("Side channel does not contain " + inspect2(key2));
          }
        },
        "delete": function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapDelete($wm, key2);
            }
          } else if (getSideChannelMap) {
            if ($m) {
              return $m["delete"](key2);
            }
          }
          return false;
        },
        get: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key2);
            }
          }
          return $m && $m.get(key2);
        },
        has: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key2);
            }
          }
          return !!$m && $m.has(key2);
        },
        set: function(key2, value) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key2, value);
          } else if (getSideChannelMap) {
            if (!$m) {
              $m = getSideChannelMap();
            }
            $m.set(key2, value);
          }
        }
      };
      return channel;
    }
  ) : getSideChannelMap;
  return sideChannelWeakmap;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var $TypeError = /* @__PURE__ */ requireType();
  var inspect2 = /* @__PURE__ */ requireObjectInspect();
  var getSideChannelList = requireSideChannelList();
  var getSideChannelMap = requireSideChannelMap();
  var getSideChannelWeakMap = requireSideChannelWeakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  sideChannel = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError("Side channel does not contain " + inspect2(key2));
        }
      },
      "delete": function(key2) {
        return !!$channelData && $channelData["delete"](key2);
      },
      get: function(key2) {
        return $channelData && $channelData.get(key2);
      },
      has: function(key2) {
        return !!$channelData && $channelData.has(key2);
      },
      set: function(key2, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key2, value);
      }
    };
    return channel;
  };
  return sideChannel;
}
var formats;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  formats = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return formats;
}
var utils$1;
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  var formats2 = /* @__PURE__ */ requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue2(queue2) {
    while (queue2.length > 1) {
      var item = queue2.pop();
      var obj = item.obj[item.prop];
      if (isArray(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject2(source2, options) {
    var obj = options && options.plainObjects ? { __proto__: null } : {};
    for (var i = 0; i < source2.length; ++i) {
      if (typeof source2[i] !== "undefined") {
        obj[i] = source2[i];
      }
    }
    return obj;
  };
  var merge = function merge2(target, source2, options) {
    if (!source2) {
      return target;
    }
    if (typeof source2 !== "object" && typeof source2 !== "function") {
      if (isArray(target)) {
        target.push(source2);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source2)) {
          target[source2] = true;
        }
      } else {
        return [target, source2];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source2);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source2)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source2)) {
      source2.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge2(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source2).reduce(function(acc, key2) {
      var value = source2[key2];
      if (has.call(acc, key2)) {
        acc[key2] = merge2(acc[key2], value, options);
      } else {
        acc[key2] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source2) {
    return Object.keys(source2).reduce(function(acc, key2) {
      acc[key2] = source2[key2];
      return acc;
    }, target);
  };
  var decode2 = function(str, defaultDecoder, charset2) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset2 === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;
  var encode2 = function encode3(str, defaultEncoder, charset2, kind, format) {
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (typeof str === "symbol") {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string = String(str);
    }
    if (charset2 === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j = 0; j < string.length; j += limit) {
      var segment = string.length >= limit ? string.slice(j, j + limit) : string;
      var arr = [];
      for (var i = 0; i < segment.length; ++i) {
        var c2 = segment.charCodeAt(i);
        if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format === formats2.RFC1738 && (c2 === 40 || c2 === 41)) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }
        if (c2 < 128) {
          arr[arr.length] = hexTable[c2];
          continue;
        }
        if (c2 < 2048) {
          arr[arr.length] = hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          arr[arr.length] = hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          continue;
        }
        i += 1;
        c2 = 65536 + ((c2 & 1023) << 10 | segment.charCodeAt(i) & 1023);
        arr[arr.length] = hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      out += arr.join("");
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue2 = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0; i < queue2.length; ++i) {
      var item = queue2[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key2 = keys[j];
        var val = obj[key2];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue2.push({ obj, prop: key2 });
          refs.push(val);
        }
      }
    }
    compactQueue(queue2);
    return value;
  };
  var isRegExp = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer = function isBuffer2(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b) {
    return [].concat(a, b);
  };
  var maybeMap = function maybeMap2(val, fn) {
    if (isArray(val)) {
      var mapped = [];
      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  utils$1 = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode: decode2,
    encode: encode2,
    isBuffer,
    isRegExp,
    maybeMap,
    merge
  };
  return utils$1;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  var getSideChannel = requireSideChannel();
  var utils2 = /* @__PURE__ */ requireUtils$1();
  var formats2 = /* @__PURE__ */ requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key2) {
      return prefix + "[" + key2 + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray = Array.isArray;
  var push2 = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push2.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats2["default"];
  var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils2.encode,
    encodeValuesOnly: false,
    filter: void 0,
    format: defaultFormat,
    formatter: formats2.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel = {};
  var stringify3 = function stringify4(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset2, sideChannel2) {
    var obj = object;
    var tmpSc = sideChannel2;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos2 = tmpSc.get(object);
      step += 1;
      if (typeof pos2 !== "undefined") {
        if (pos2 === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter === "function") {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray(obj)) {
      obj = utils2.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset2, "key", format) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset2, "key", format);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset2, "value", format))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray(obj)) {
      if (encodeValuesOnly && encoder) {
        obj = utils2.maybeMap(obj, encoder);
      }
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j = 0; j < objKeys.length; ++j) {
      var key2 = objKeys[j];
      var value = typeof key2 === "object" && key2 && typeof key2.value !== "undefined" ? key2.value : obj[key2];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? String(key2).replace(/\./g, "%2E") : String(key2);
      var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel2.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel2);
      pushToArray(values, stringify4(
        value,
        keyPrefix,
        generateArrayPrefix,
        commaRoundTrip,
        allowEmptyArrays,
        strictNullHandling,
        skipNulls,
        encodeDotInKeys,
        generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
        filter,
        sort,
        allowDots,
        serializeDate,
        format,
        formatter,
        encodeValuesOnly,
        charset2,
        valueSideChannel
      ));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset2 = opts.charset || defaults.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format = formats2["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats2.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format = opts.format;
    }
    var formatter = formats2.formatters[format];
    var filter = defaults.filter;
    if (typeof opts.filter === "function" || isArray(opts.filter)) {
      filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      arrayFormat,
      charset: charset2,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      commaRoundTrip: !!opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
      filter,
      format,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  stringify_1 = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj = filter("", obj);
    } else if (isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel2 = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key2 = objKeys[i];
      var value = obj[key2];
      if (options.skipNulls && value === null) {
        continue;
      }
      pushToArray(keys, stringify3(
        value,
        key2,
        generateArrayPrefix,
        commaRoundTrip,
        options.allowEmptyArrays,
        options.strictNullHandling,
        options.skipNulls,
        options.encodeDotInKeys,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel2
      ));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  return stringify_1;
}
var parse$1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$1;
  hasRequiredParse = 1;
  var utils2 = /* @__PURE__ */ requireUtils$1();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils2.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options, currentArrayLength) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
      throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(
      options.delimiter,
      options.throwOnLimitExceeded ? limit + 1 : limit
    );
    if (options.throwOnLimitExceeded && parts.length > limit) {
      throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
    }
    var skipIndex = -1;
    var i;
    var charset2 = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset2 = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset2 = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos2 = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key2;
      var val;
      if (pos2 === -1) {
        key2 = options.decoder(part, defaults.decoder, charset2, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key2 = options.decoder(part.slice(0, pos2), defaults.decoder, charset2, "key");
        val = utils2.maybeMap(
          parseArrayValue(
            part.slice(pos2 + 1),
            options,
            isArray(obj[key2]) ? obj[key2].length : 0
          ),
          function(encodedVal) {
            return options.decoder(encodedVal, defaults.decoder, charset2, "value");
          }
        );
      }
      if (val && options.interpretNumericEntities && charset2 === "iso-8859-1") {
        val = interpretNumericEntities(String(val));
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray(val) ? [val] : val;
      }
      var existing = has.call(obj, key2);
      if (existing && options.duplicates === "combine") {
        obj[key2] = utils2.combine(obj[key2], val);
      } else if (!existing || options.duplicates === "last") {
        obj[key2] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === "[]") {
      var parentKey = chain.slice(0, -1).join("");
      currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }
    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root2 = chain[i];
      if (root2 === "[]" && options.parseArrays) {
        obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils2.combine([], leaf);
      } else {
        obj = options.plainObjects ? { __proto__: null } : {};
        var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index) && root2 !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
          obj = [];
          obj[index] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key2 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key2);
    var parent = segment ? key2.slice(0, segment.index) : key2;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key2)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
      }
      keys.push("[" + key2.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
      throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    }
    var charset2 = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
      charset: charset2,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
      delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
      throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
    };
  };
  parse$1 = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? { __proto__: null } : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? { __proto__: null } : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key2 = keys[i];
      var newObj = parseKeys(key2, tempObj[key2], options, typeof str === "string");
      obj = utils2.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils2.compact(obj);
  };
  return parse$1;
}
var lib$1;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$1;
  hasRequiredLib = 1;
  var stringify3 = /* @__PURE__ */ requireStringify();
  var parse3 = /* @__PURE__ */ requireParse();
  var formats2 = /* @__PURE__ */ requireFormats();
  lib$1 = {
    formats: formats2,
    parse: parse3,
    stringify: stringify3
  };
  return lib$1;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var urlencoded_1;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded) return urlencoded_1;
  hasRequiredUrlencoded = 1;
  var createError = requireHttpErrors();
  var debug = require$$0$8("body-parser:urlencoded");
  var isFinished = requireOnFinished().isFinished;
  var read2 = requireRead();
  var typeis = requireTypeIs();
  var qs = /* @__PURE__ */ requireLib();
  var { getCharset, normalizeOptions } = requireUtils$2();
  urlencoded_1 = urlencoded;
  function urlencoded(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "application/x-www-form-urlencoded");
    var defaultCharset = options?.defaultCharset || "utf-8";
    if (defaultCharset !== "utf-8" && defaultCharset !== "iso-8859-1") {
      throw new TypeError("option defaultCharset must be either utf-8 or iso-8859-1");
    }
    var queryparse = createQueryParser(options);
    function parse3(body, encoding2) {
      return body.length ? queryparse(body, encoding2) : {};
    }
    return function urlencodedParser(req, res, next) {
      if (isFinished(req)) {
        debug("body already parsed");
        next();
        return;
      }
      if (!("body" in req)) {
        req.body = void 0;
      }
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || defaultCharset;
      if (charset2 !== "utf-8" && charset2 !== "iso-8859-1") {
        debug("invalid charset");
        next(createError(415, 'unsupported charset "' + charset2.toUpperCase() + '"', {
          charset: charset2,
          type: "charset.unsupported"
        }));
        return;
      }
      read2(req, res, next, parse3, debug, {
        encoding: charset2,
        inflate,
        limit,
        verify
      });
    };
  }
  function createQueryParser(options) {
    var extended = Boolean(options?.extended);
    var parameterLimit = options?.parameterLimit !== void 0 ? options?.parameterLimit : 1e3;
    var charsetSentinel = options?.charsetSentinel;
    var interpretNumericEntities = options?.interpretNumericEntities;
    var depth = extended ? options?.depth !== void 0 ? options?.depth : 32 : 0;
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isNaN(depth) || depth < 0) {
      throw new TypeError("option depth must be a zero or a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body, encoding2) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = extended ? Math.max(100, paramCount) : 0;
      debug("parse " + (extended ? "extended " : "") + "urlencoding");
      try {
        return qs.parse(body, {
          allowPrototypes: true,
          arrayLimit,
          depth,
          charsetSentinel,
          interpretNumericEntities,
          charset: encoding2,
          parameterLimit,
          strictDepth: true
        });
      } catch (err) {
        if (err instanceof RangeError) {
          throw createError(400, "The input exceeded the depth", {
            type: "querystring.parse.rangeError"
          });
        } else {
          throw err;
        }
      }
    };
  }
  function parameterCount(body, limit) {
    var len = body.split("&").length;
    return len > limit ? void 0 : len - 1;
  }
  return urlencoded_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredBodyParser;
function requireBodyParser() {
  if (hasRequiredBodyParser) return bodyParser.exports;
  hasRequiredBodyParser = 1;
  (function(module, exports) {
    exports = module.exports = bodyParser2;
    Object.defineProperty(exports, "json", {
      configurable: true,
      enumerable: true,
      get: () => requireJson()
    });
    Object.defineProperty(exports, "raw", {
      configurable: true,
      enumerable: true,
      get: () => requireRaw()
    });
    Object.defineProperty(exports, "text", {
      configurable: true,
      enumerable: true,
      get: () => requireText()
    });
    Object.defineProperty(exports, "urlencoded", {
      configurable: true,
      enumerable: true,
      get: () => requireUrlencoded()
    });
    function bodyParser2() {
      throw new Error("The bodyParser() generic has been split into individual middleware to use instead.");
    }
  })(bodyParser, bodyParser.exports);
  return bodyParser.exports;
}
var mergeDescriptors_1;
var hasRequiredMergeDescriptors;
function requireMergeDescriptors() {
  if (hasRequiredMergeDescriptors) return mergeDescriptors_1;
  hasRequiredMergeDescriptors = 1;
  function mergeDescriptors(destination, source2, overwrite = true) {
    if (!destination) {
      throw new TypeError("The `destination` argument is required.");
    }
    if (!source2) {
      throw new TypeError("The `source` argument is required.");
    }
    for (const name of Object.getOwnPropertyNames(source2)) {
      if (!overwrite && Object.hasOwn(destination, name)) {
        continue;
      }
      const descriptor = Object.getOwnPropertyDescriptor(source2, name);
      Object.defineProperty(destination, name, descriptor);
    }
    return destination;
  }
  mergeDescriptors_1 = mergeDescriptors;
  return mergeDescriptors_1;
}
var application = { exports: {} };
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var encodeurl;
var hasRequiredEncodeurl;
function requireEncodeurl() {
  if (hasRequiredEncodeurl) return encodeurl;
  hasRequiredEncodeurl = 1;
  encodeurl = encodeUrl;
  var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
  var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
  var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
  function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
  }
  return encodeurl;
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var escapeHtml_1;
var hasRequiredEscapeHtml;
function requireEscapeHtml() {
  if (hasRequiredEscapeHtml) return escapeHtml_1;
  hasRequiredEscapeHtml = 1;
  var matchHtmlRegExp = /["'&<>]/;
  escapeHtml_1 = escapeHtml;
  function escapeHtml(string) {
    var str = "" + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape2;
    var html = "";
    var index = 0;
    var lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          escape2 = "&quot;";
          break;
        case 38:
          escape2 = "&amp;";
          break;
        case 39:
          escape2 = "&#39;";
          break;
        case 60:
          escape2 = "&lt;";
          break;
        case 62:
          escape2 = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }
      lastIndex = index + 1;
      html += escape2;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  return escapeHtml_1;
}
var parseurl = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredParseurl;
function requireParseurl() {
  if (hasRequiredParseurl) return parseurl.exports;
  hasRequiredParseurl = 1;
  var url = require$$0$9;
  var parse3 = url.parse;
  var Url = url.Url;
  parseurl.exports = parseurl$1;
  parseurl.exports.original = originalurl;
  function parseurl$1(req) {
    var url2 = req.url;
    if (url2 === void 0) {
      return void 0;
    }
    var parsed = req._parsedUrl;
    if (fresh(url2, parsed)) {
      return parsed;
    }
    parsed = fastparse(url2);
    parsed._raw = url2;
    return req._parsedUrl = parsed;
  }
  function originalurl(req) {
    var url2 = req.originalUrl;
    if (typeof url2 !== "string") {
      return parseurl$1(req);
    }
    var parsed = req._parsedOriginalUrl;
    if (fresh(url2, parsed)) {
      return parsed;
    }
    parsed = fastparse(url2);
    parsed._raw = url2;
    return req._parsedOriginalUrl = parsed;
  }
  function fastparse(str) {
    if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
      return parse3(str);
    }
    var pathname = str;
    var query = null;
    var search = null;
    for (var i = 1; i < str.length; i++) {
      switch (str.charCodeAt(i)) {
        case 63:
          if (search === null) {
            pathname = str.substring(0, i);
            query = str.substring(i + 1);
            search = str.substring(i);
          }
          break;
        case 9:
        /* \t */
        case 10:
        /* \n */
        case 12:
        /* \f */
        case 13:
        /* \r */
        case 32:
        /*    */
        case 35:
        /* #  */
        case 160:
        case 65279:
          return parse3(str);
      }
    }
    var url2 = Url !== void 0 ? new Url() : {};
    url2.path = str;
    url2.href = str;
    url2.pathname = pathname;
    if (search !== null) {
      url2.query = query;
      url2.search = search;
    }
    return url2;
  }
  function fresh(url2, parsedUrl) {
    return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
  }
  return parseurl.exports;
}
const require$$0 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var statuses;
var hasRequiredStatuses;
function requireStatuses() {
  if (hasRequiredStatuses) return statuses;
  hasRequiredStatuses = 1;
  var codes = require$$0;
  statuses = status;
  status.message = codes;
  status.code = createMessageToStatusCodeMap(codes);
  status.codes = createStatusCodeList(codes);
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };
  status.empty = {
    204: true,
    205: true,
    304: true
  };
  status.retry = {
    502: true,
    503: true,
    504: true
  };
  function createMessageToStatusCodeMap(codes2) {
    var map = {};
    Object.keys(codes2).forEach(function forEachCode(code) {
      var message = codes2[code];
      var status2 = Number(code);
      map[message.toLowerCase()] = status2;
    });
    return map;
  }
  function createStatusCodeList(codes2) {
    return Object.keys(codes2).map(function mapCode(code) {
      return Number(code);
    });
  }
  function getStatusCode(message) {
    var msg = message.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
      throw new Error('invalid status message: "' + message + '"');
    }
    return status.code[msg];
  }
  function getStatusMessage(code) {
    if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
      throw new Error("invalid status code: " + code);
    }
    return status.message[code];
  }
  function status(code) {
    if (typeof code === "number") {
      return getStatusMessage(code);
    }
    if (typeof code !== "string") {
      throw new TypeError("code must be a number or string");
    }
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      return getStatusMessage(n);
    }
    return getStatusCode(code);
  }
  return statuses;
}
var finalhandler_1;
var hasRequiredFinalhandler;
function requireFinalhandler() {
  if (hasRequiredFinalhandler) return finalhandler_1;
  hasRequiredFinalhandler = 1;
  /*!
   * finalhandler
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  var debug = require$$0$8("finalhandler");
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var onFinished2 = requireOnFinished();
  var parseUrl = requireParseurl();
  var statuses2 = requireStatuses();
  var isFinished = onFinished2.isFinished;
  function createHtmlDocument(message) {
    var body = escapeHtml(message).replaceAll("\n", "<br>").replaceAll("  ", " &nbsp;");
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
  }
  finalhandler_1 = finalhandler;
  function finalhandler(req, res, options) {
    var opts = options || {};
    var env = opts.env || "production";
    var onerror = opts.onerror;
    return function(err) {
      var headers;
      var msg;
      var status;
      if (!err && res.headersSent) {
        debug("cannot 404 after headers sent");
        return;
      }
      if (err) {
        status = getErrorStatusCode(err);
        if (status === void 0) {
          status = getResponseStatusCode(res);
        } else {
          headers = getErrorHeaders(err);
        }
        msg = getErrorMessage(err, status, env);
      } else {
        status = 404;
        msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
      }
      debug("default %s", status);
      if (err && onerror) {
        setImmediate(onerror, err, req, res);
      }
      if (res.headersSent) {
        debug("cannot %d after headers sent", status);
        if (req.socket) {
          req.socket.destroy();
        }
        return;
      }
      send(req, res, status, headers, msg);
    };
  }
  function getErrorHeaders(err) {
    if (!err.headers || typeof err.headers !== "object") {
      return void 0;
    }
    return { ...err.headers };
  }
  function getErrorMessage(err, status, env) {
    var msg;
    if (env !== "production") {
      msg = err.stack;
      if (!msg && typeof err.toString === "function") {
        msg = err.toString();
      }
    }
    return msg || statuses2.message[status];
  }
  function getErrorStatusCode(err) {
    if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
      return err.status;
    }
    if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
      return err.statusCode;
    }
    return void 0;
  }
  function getResourceName(req) {
    try {
      return parseUrl.original(req).pathname;
    } catch (e) {
      return "resource";
    }
  }
  function getResponseStatusCode(res) {
    var status = res.statusCode;
    if (typeof status !== "number" || status < 400 || status > 599) {
      status = 500;
    }
    return status;
  }
  function send(req, res, status, headers, message) {
    function write() {
      var body = createHtmlDocument(message);
      res.statusCode = status;
      if (req.httpVersionMajor < 2) {
        res.statusMessage = statuses2.message[status];
      }
      res.removeHeader("Content-Encoding");
      res.removeHeader("Content-Language");
      res.removeHeader("Content-Range");
      for (const [key2, value] of Object.entries(headers ?? {})) {
        res.setHeader(key2, value);
      }
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Content-Type", "text/html; charset=utf-8");
      res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
      if (req.method === "HEAD") {
        res.end();
        return;
      }
      res.end(body, "utf8");
    }
    if (isFinished(req)) {
      write();
      return;
    }
    req.unpipe();
    onFinished2(req, write);
    req.resume();
  }
  return finalhandler_1;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var view;
var hasRequiredView;
function requireView() {
  if (hasRequiredView) return view;
  hasRequiredView = 1;
  var debug = require$$0$8("express:view");
  var path2 = path__default;
  var fs2 = fs__default;
  var dirname = path2.dirname;
  var basename = path2.basename;
  var extname = path2.extname;
  var join = path2.join;
  var resolve2 = path2.resolve;
  view = View;
  function View(name, options) {
    var opts = options || {};
    this.defaultEngine = opts.defaultEngine;
    this.ext = extname(name);
    this.name = name;
    this.root = opts.root;
    if (!this.ext && !this.defaultEngine) {
      throw new Error("No default engine was specified and no extension was provided.");
    }
    var fileName = name;
    if (!this.ext) {
      this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
      fileName += this.ext;
    }
    if (!opts.engines[this.ext]) {
      var mod2 = this.ext.slice(1);
      debug('require "%s"', mod2);
      var fn = commonjsRequire(mod2).__express;
      if (typeof fn !== "function") {
        throw new Error('Module "' + mod2 + '" does not provide a view engine.');
      }
      opts.engines[this.ext] = fn;
    }
    this.engine = opts.engines[this.ext];
    this.path = this.lookup(fileName);
  }
  View.prototype.lookup = function lookup(name) {
    var path3;
    var roots2 = [].concat(this.root);
    debug('lookup "%s"', name);
    for (var i = 0; i < roots2.length && !path3; i++) {
      var root2 = roots2[i];
      var loc = resolve2(root2, name);
      var dir = dirname(loc);
      var file = basename(loc);
      path3 = this.resolve(dir, file);
    }
    return path3;
  };
  View.prototype.render = function render(options, callback) {
    var sync = true;
    debug('render "%s"', this.path);
    this.engine(this.path, options, function onRender() {
      if (!sync) {
        return callback.apply(this, arguments);
      }
      var args = new Array(arguments.length);
      var cntx = this;
      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      return process.nextTick(function renderTick() {
        return callback.apply(cntx, args);
      });
    });
    sync = false;
  };
  View.prototype.resolve = function resolve3(dir, file) {
    var ext = this.ext;
    var path3 = join(dir, file);
    var stat2 = tryStat(path3);
    if (stat2 && stat2.isFile()) {
      return path3;
    }
    path3 = join(dir, basename(file, ext), "index" + ext);
    stat2 = tryStat(path3);
    if (stat2 && stat2.isFile()) {
      return path3;
    }
  };
  function tryStat(path3) {
    debug('stat "%s"', path3);
    try {
      return fs2.statSync(path3);
    } catch (e) {
      return void 0;
    }
  }
  return view;
}
var utils = {};
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var etag_1;
var hasRequiredEtag;
function requireEtag() {
  if (hasRequiredEtag) return etag_1;
  hasRequiredEtag = 1;
  etag_1 = etag;
  var crypto2 = require$$0$a;
  var Stats = fs$1.Stats;
  var toString = Object.prototype.toString;
  function entitytag(entity) {
    if (entity.length === 0) {
      return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }
    var hash = crypto2.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
    var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
    return '"' + len.toString(16) + "-" + hash + '"';
  }
  function etag(entity, options) {
    if (entity == null) {
      throw new TypeError("argument entity is required");
    }
    var isStats = isstats(entity);
    var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
    if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
      throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
    }
    var tag = isStats ? stattag(entity) : entitytag(entity);
    return weak ? "W/" + tag : tag;
  }
  function isstats(obj) {
    if (typeof Stats === "function" && obj instanceof Stats) {
      return true;
    }
    return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
  }
  function stattag(stat2) {
    var mtime = stat2.mtime.getTime().toString(16);
    var size = stat2.size.toString(16);
    return '"' + size + "-" + mtime + '"';
  }
  return etag_1;
}
var proxyAddr = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var forwarded_1;
var hasRequiredForwarded;
function requireForwarded() {
  if (hasRequiredForwarded) return forwarded_1;
  hasRequiredForwarded = 1;
  forwarded_1 = forwarded;
  function forwarded(req) {
    if (!req) {
      throw new TypeError("argument req is required");
    }
    var proxyAddrs = parse3(req.headers["x-forwarded-for"] || "");
    var socketAddr = getSocketAddr(req);
    var addrs = [socketAddr].concat(proxyAddrs);
    return addrs;
  }
  function getSocketAddr(req) {
    return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
  }
  function parse3(header) {
    var end = header.length;
    var list = [];
    var start = header.length;
    for (var i = header.length - 1; i >= 0; i--) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(header.substring(start, end));
          }
          start = end = i;
          break;
        default:
          start = i;
          break;
      }
    }
    if (start !== end) {
      list.push(header.substring(start, end));
    }
    return list;
  }
  return forwarded_1;
}
var ipaddr$1 = { exports: {} };
var ipaddr = ipaddr$1.exports;
var hasRequiredIpaddr;
function requireIpaddr() {
  if (hasRequiredIpaddr) return ipaddr$1.exports;
  hasRequiredIpaddr = 1;
  (function(module) {
    (function() {
      var expandIPv6, ipaddr2, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root2, zoneIndex;
      ipaddr2 = {};
      root2 = this;
      if (module !== null && module.exports) {
        module.exports = ipaddr2;
      } else {
        root2["ipaddr"] = ipaddr2;
      }
      matchCIDR = function(first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (k = 0, len = rangeSubnets.length; k < len; k++) {
            subnet = rangeSubnets[k];
            if (address.kind() === subnet[0].kind()) {
              if (address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      ipaddr2.IPv4 = function() {
        function IPv4(octets) {
          var k, len, octet;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function(other, cidrRange) {
          var ref2;
          if (cidrRange === void 0) {
            ref2 = other, other = ref2[0], cidrRange = ref2[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr2.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, octet, stop, zeros, zerotable;
          zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 3; k >= 0; i = k += -1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        return IPv4;
      }();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
        longValue: new RegExp("^" + ipv4Part + "$", "i")
      };
      ipaddr2.IPv4.parser = function(string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string2) {
          if (string2[0] === "0" && string2[1] !== "x") {
            return parseInt(string2, 8);
          } else {
            return parseInt(string2);
          }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            var k, len, ref2, results;
            ref2 = match.slice(1, 6);
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            var k, results;
            results = [];
            for (shift = k = 0; k <= 24; shift = k += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else {
          return null;
        }
      };
      ipaddr2.IPv6 = function() {
        function IPv6(parts, zoneId) {
          var i, k, l, len, part, ref2;
          if (parts.length === 16) {
            this.parts = [];
            for (i = k = 0; k <= 14; i = k += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          ref2 = this.parts;
          for (l = 0, len = ref2.length; l < len; l++) {
            part = ref2[l];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        IPv6.prototype.toRFC5952String = function() {
          var bestMatchIndex, bestMatchLength, match, regex, string;
          regex = /((^|:)(0(:|$)){2,})/g;
          string = this.toNormalizedString();
          bestMatchIndex = 0;
          bestMatchLength = -1;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function() {
          var bytes2, k, len, part, ref2;
          bytes2 = [];
          ref2 = this.parts;
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            bytes2.push(part >> 8);
            bytes2.push(part & 255);
          }
          return bytes2;
        };
        IPv6.prototype.toNormalizedString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref2, results;
            ref2 = this.parts;
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(part.toString(16));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref2, results;
            ref2 = this.parts;
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(part.toString(16).padStart(4, "0"));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.match = function(other, cidrRange) {
          var ref2;
          if (cidrRange === void 0) {
            ref2 = other, other = ref2[0], cidrRange = ref2[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.toIPv4Address = function() {
          var high, low, ref2;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          ref2 = this.parts.slice(-2), high = ref2[0], low = ref2[1];
          return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, part, stop, zeros, zerotable;
          zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 7; k >= 0; i = k += -1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        return IPv6;
      }();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      zoneIndex = "%[0-9a-z]{1,}";
      ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
      };
      expandIPv6 = function(string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          var k, len, ref2, results;
          ref2 = string.split(":");
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(parseInt(part, 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      };
      ipaddr2.IPv6.parser = function(string) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes["native"].test(string)) {
          return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes["transitional"])) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
            for (k = 0, len = octets.length; k < len; k++) {
              octet = octets[k];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr2.IPv4.isIPv4 = ipaddr2.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr2.IPv4.isValid = function(string) {
        try {
          new this(this.parser(string));
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr2.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr2.IPv6.isValid = function(string) {
        var addr;
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr2.IPv4.parse = function(string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr2.IPv6.parse = function(string) {
        var addr;
        addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr2.IPv4.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        octets = [0, 0, 0, 0];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.IPv4.broadcastAddressFromCIDR = function(string) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.networkAddressFromCIDR = function(string) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv6.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr2.isValid = function(string) {
        return ipaddr2.IPv6.isValid(string) || ipaddr2.IPv4.isValid(string);
      };
      ipaddr2.parse = function(string) {
        if (ipaddr2.IPv6.isValid(string)) {
          return ipaddr2.IPv6.parse(string);
        } else if (ipaddr2.IPv4.isValid(string)) {
          return ipaddr2.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr2.parseCIDR = function(string) {
        try {
          return ipaddr2.IPv6.parseCIDR(string);
        } catch (error1) {
          try {
            return ipaddr2.IPv4.parseCIDR(string);
          } catch (error12) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr2.fromByteArray = function(bytes2) {
        var length;
        length = bytes2.length;
        if (length === 4) {
          return new ipaddr2.IPv4(bytes2);
        } else if (length === 16) {
          return new ipaddr2.IPv6(bytes2);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr2.process = function(string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(ipaddr);
  })(ipaddr$1);
  return ipaddr$1.exports;
}
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredProxyAddr;
function requireProxyAddr() {
  if (hasRequiredProxyAddr) return proxyAddr.exports;
  hasRequiredProxyAddr = 1;
  proxyAddr.exports = proxyaddr;
  proxyAddr.exports.all = alladdrs;
  proxyAddr.exports.compile = compile;
  var forwarded = requireForwarded();
  var ipaddr2 = requireIpaddr();
  var DIGIT_REGEXP = /^[0-9]+$/;
  var isip = ipaddr2.isValid;
  var parseip = ipaddr2.parse;
  var IP_RANGES = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
  };
  function alladdrs(req, trust) {
    var addrs = forwarded(req);
    if (!trust) {
      return addrs;
    }
    if (typeof trust !== "function") {
      trust = compile(trust);
    }
    for (var i = 0; i < addrs.length - 1; i++) {
      if (trust(addrs[i], i)) continue;
      addrs.length = i + 1;
    }
    return addrs;
  }
  function compile(val) {
    if (!val) {
      throw new TypeError("argument is required");
    }
    var trust;
    if (typeof val === "string") {
      trust = [val];
    } else if (Array.isArray(val)) {
      trust = val.slice();
    } else {
      throw new TypeError("unsupported trust argument");
    }
    for (var i = 0; i < trust.length; i++) {
      val = trust[i];
      if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
        continue;
      }
      val = IP_RANGES[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
  }
  function compileRangeSubnets(arr) {
    var rangeSubnets = new Array(arr.length);
    for (var i = 0; i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
  }
  function compileTrust(rangeSubnets) {
    var len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  }
  function parseipNotation(note) {
    var pos2 = note.lastIndexOf("/");
    var str = pos2 !== -1 ? note.substring(0, pos2) : note;
    if (!isip(str)) {
      throw new TypeError("invalid IP address: " + str);
    }
    var ip = parseip(str);
    if (pos2 === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
      ip = ip.toIPv4Address();
    }
    var max2 = ip.kind() === "ipv6" ? 128 : 32;
    var range2 = pos2 !== -1 ? note.substring(pos2 + 1, note.length) : null;
    if (range2 === null) {
      range2 = max2;
    } else if (DIGIT_REGEXP.test(range2)) {
      range2 = parseInt(range2, 10);
    } else if (ip.kind() === "ipv4" && isip(range2)) {
      range2 = parseNetmask(range2);
    } else {
      range2 = null;
    }
    if (range2 <= 0 || range2 > max2) {
      throw new TypeError("invalid range on address: " + note);
    }
    return [ip, range2];
  }
  function parseNetmask(netmask) {
    var ip = parseip(netmask);
    var kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
  }
  function proxyaddr(req, trust) {
    if (!req) {
      throw new TypeError("req argument is required");
    }
    if (!trust) {
      throw new TypeError("trust argument is required");
    }
    var addrs = alladdrs(req, trust);
    var addr = addrs[addrs.length - 1];
    return addr;
  }
  function trustNone() {
    return false;
  }
  function trustMulti(subnets) {
    return function trust(addr) {
      if (!isip(addr)) return false;
      var ip = parseip(addr);
      var ipconv;
      var kind = ip.kind();
      for (var i = 0; i < subnets.length; i++) {
        var subnet = subnets[i];
        var subnetip = subnet[0];
        var subnetkind = subnetip.kind();
        var subnetrange = subnet[1];
        var trusted = ip;
        if (kind !== subnetkind) {
          if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
            continue;
          }
          if (!ipconv) {
            ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
          }
          trusted = ipconv;
        }
        if (trusted.match(subnetip, subnetrange)) {
          return true;
        }
      }
      return false;
    };
  }
  function trustSingle(subnet) {
    var subnetip = subnet[0];
    var subnetkind = subnetip.kind();
    var subnetisipv4 = subnetkind === "ipv4";
    var subnetrange = subnet[1];
    return function trust(addr) {
      if (!isip(addr)) return false;
      var ip = parseip(addr);
      var kind = ip.kind();
      if (kind !== subnetkind) {
        if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
          return false;
        }
        ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
      }
      return ip.match(subnetip, subnetrange);
    };
  }
  return proxyAddr.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  (function(exports) {
    var { METHODS } = require$$2$3;
    var contentType2 = requireContentType();
    var etag = requireEtag();
    var mime = requireMimeTypes();
    var proxyaddr = requireProxyAddr();
    var qs = /* @__PURE__ */ requireLib();
    var querystring = require$$6$1;
    exports.methods = METHODS.map((method) => method.toLowerCase());
    exports.etag = createETagGenerator({ weak: false });
    exports.wetag = createETagGenerator({ weak: true });
    exports.normalizeType = function(type2) {
      return ~type2.indexOf("/") ? acceptParams(type2) : { value: mime.lookup(type2) || "application/octet-stream", params: {} };
    };
    exports.normalizeTypes = function(types2) {
      return types2.map(exports.normalizeType);
    };
    function acceptParams(str) {
      var length = str.length;
      var colonIndex = str.indexOf(";");
      var index = colonIndex === -1 ? length : colonIndex;
      var ret = { value: str.slice(0, index).trim(), quality: 1, params: {} };
      while (index < length) {
        var splitIndex = str.indexOf("=", index);
        if (splitIndex === -1) break;
        var colonIndex = str.indexOf(";", index);
        var endIndex = colonIndex === -1 ? length : colonIndex;
        if (splitIndex > endIndex) {
          index = str.lastIndexOf(";", splitIndex - 1) + 1;
          continue;
        }
        var key2 = str.slice(index, splitIndex).trim();
        var value = str.slice(splitIndex + 1, endIndex).trim();
        if (key2 === "q") {
          ret.quality = parseFloat(value);
        } else {
          ret.params[key2] = value;
        }
        index = endIndex + 1;
      }
      return ret;
    }
    exports.compileETag = function(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "weak":
          fn = exports.wetag;
          break;
        case false:
          break;
        case "strong":
          fn = exports.etag;
          break;
        default:
          throw new TypeError("unknown value for etag function: " + val);
      }
      return fn;
    };
    exports.compileQueryParser = function compileQueryParser(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "simple":
          fn = querystring.parse;
          break;
        case false:
          break;
        case "extended":
          fn = parseExtendedQueryString;
          break;
        default:
          throw new TypeError("unknown value for query parser function: " + val);
      }
      return fn;
    };
    exports.compileTrust = function(val) {
      if (typeof val === "function") return val;
      if (val === true) {
        return function() {
          return true;
        };
      }
      if (typeof val === "number") {
        return function(a, i) {
          return i < val;
        };
      }
      if (typeof val === "string") {
        val = val.split(",").map(function(v) {
          return v.trim();
        });
      }
      return proxyaddr.compile(val || []);
    };
    exports.setCharset = function setCharset(type2, charset2) {
      if (!type2 || !charset2) {
        return type2;
      }
      var parsed = contentType2.parse(type2);
      parsed.parameters.charset = charset2;
      return contentType2.format(parsed);
    };
    function createETagGenerator(options) {
      return function generateETag(body, encoding2) {
        var buf = !Buffer.isBuffer(body) ? Buffer.from(body, encoding2) : body;
        return etag(buf, options);
      };
    }
    function parseExtendedQueryString(str) {
      return qs.parse(str, {
        allowPrototypes: true
      });
    }
  })(utils);
  return utils;
}
var once = { exports: {} };
var wrappy_1;
var hasRequiredWrappy;
function requireWrappy() {
  if (hasRequiredWrappy) return wrappy_1;
  hasRequiredWrappy = 1;
  wrappy_1 = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
  return wrappy_1;
}
var hasRequiredOnce;
function requireOnce() {
  if (hasRequiredOnce) return once.exports;
  hasRequiredOnce = 1;
  var wrappy = requireWrappy();
  once.exports = wrappy(once$1);
  once.exports.strict = wrappy(onceStrict);
  once$1.proto = once$1(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once$1(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once$1(fn) {
    var f = function() {
      if (f.called) return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
  return once.exports;
}
var router = { exports: {} };
var isPromise = { exports: {} };
var hasRequiredIsPromise;
function requireIsPromise() {
  if (hasRequiredIsPromise) return isPromise.exports;
  hasRequiredIsPromise = 1;
  isPromise.exports = isPromise$1;
  isPromise.exports.default = isPromise$1;
  function isPromise$1(obj) {
    return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
  }
  return isPromise.exports;
}
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  Object.defineProperty(dist, "__esModule", { value: true });
  dist.TokenData = void 0;
  dist.parse = parse3;
  dist.compile = compile;
  dist.match = match;
  dist.pathToRegexp = pathToRegexp;
  dist.stringify = stringify3;
  const DEFAULT_DELIMITER = "/";
  const NOOP_VALUE = (value) => value;
  const ID_START = /^[$_\p{ID_Start}]$/u;
  const ID_CONTINUE = /^[$\u200c\u200d\p{ID_Continue}]$/u;
  const DEBUG_URL = "https://git.new/pathToRegexpError";
  const SIMPLE_TOKENS = {
    // Groups.
    "{": "{",
    "}": "}",
    // Reserved.
    "(": "(",
    ")": ")",
    "[": "[",
    "]": "]",
    "+": "+",
    "?": "?",
    "!": "!"
  };
  function escapeText(str) {
    return str.replace(/[{}()\[\]+?!:*]/g, "\\$&");
  }
  function escape2(str) {
    return str.replace(/[.+*?^${}()[\]|/\\]/g, "\\$&");
  }
  function* lexer(str) {
    const chars = [...str];
    let i = 0;
    function name() {
      let value = "";
      if (ID_START.test(chars[++i])) {
        value += chars[i];
        while (ID_CONTINUE.test(chars[++i])) {
          value += chars[i];
        }
      } else if (chars[i] === '"') {
        let pos2 = i;
        while (i < chars.length) {
          if (chars[++i] === '"') {
            i++;
            pos2 = 0;
            break;
          }
          if (chars[i] === "\\") {
            value += chars[++i];
          } else {
            value += chars[i];
          }
        }
        if (pos2) {
          throw new TypeError(`Unterminated quote at ${pos2}: ${DEBUG_URL}`);
        }
      }
      if (!value) {
        throw new TypeError(`Missing parameter name at ${i}: ${DEBUG_URL}`);
      }
      return value;
    }
    while (i < chars.length) {
      const value = chars[i];
      const type2 = SIMPLE_TOKENS[value];
      if (type2) {
        yield { type: type2, index: i++, value };
      } else if (value === "\\") {
        yield { type: "ESCAPED", index: i++, value: chars[i++] };
      } else if (value === ":") {
        const value2 = name();
        yield { type: "PARAM", index: i, value: value2 };
      } else if (value === "*") {
        const value2 = name();
        yield { type: "WILDCARD", index: i, value: value2 };
      } else {
        yield { type: "CHAR", index: i, value: chars[i++] };
      }
    }
    return { type: "END", index: i, value: "" };
  }
  class Iter {
    constructor(tokens) {
      this.tokens = tokens;
    }
    peek() {
      if (!this._peek) {
        const next = this.tokens.next();
        this._peek = next.value;
      }
      return this._peek;
    }
    tryConsume(type2) {
      const token2 = this.peek();
      if (token2.type !== type2)
        return;
      this._peek = void 0;
      return token2.value;
    }
    consume(type2) {
      const value = this.tryConsume(type2);
      if (value !== void 0)
        return value;
      const { type: nextType, index } = this.peek();
      throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type2}: ${DEBUG_URL}`);
    }
    text() {
      let result = "";
      let value;
      while (value = this.tryConsume("CHAR") || this.tryConsume("ESCAPED")) {
        result += value;
      }
      return result;
    }
  }
  class TokenData {
    constructor(tokens) {
      this.tokens = tokens;
    }
  }
  dist.TokenData = TokenData;
  function parse3(str, options = {}) {
    const { encodePath = NOOP_VALUE } = options;
    const it = new Iter(lexer(str));
    function consume(endType) {
      const tokens2 = [];
      while (true) {
        const path2 = it.text();
        if (path2)
          tokens2.push({ type: "text", value: encodePath(path2) });
        const param = it.tryConsume("PARAM");
        if (param) {
          tokens2.push({
            type: "param",
            name: param
          });
          continue;
        }
        const wildcard = it.tryConsume("WILDCARD");
        if (wildcard) {
          tokens2.push({
            type: "wildcard",
            name: wildcard
          });
          continue;
        }
        const open = it.tryConsume("{");
        if (open) {
          tokens2.push({
            type: "group",
            tokens: consume("}")
          });
          continue;
        }
        it.consume(endType);
        return tokens2;
      }
    }
    const tokens = consume("END");
    return new TokenData(tokens);
  }
  function compile(path2, options = {}) {
    const { encode: encode2 = encodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const data = path2 instanceof TokenData ? path2 : parse3(path2, options);
    const fn = tokensToFunction(data.tokens, delimiter, encode2);
    return function path3(data2 = {}) {
      const [path4, ...missing] = fn(data2);
      if (missing.length) {
        throw new TypeError(`Missing parameters: ${missing.join(", ")}`);
      }
      return path4;
    };
  }
  function tokensToFunction(tokens, delimiter, encode2) {
    const encoders = tokens.map((token2) => tokenToFunction(token2, delimiter, encode2));
    return (data) => {
      const result = [""];
      for (const encoder of encoders) {
        const [value, ...extras] = encoder(data);
        result[0] += value;
        result.push(...extras);
      }
      return result;
    };
  }
  function tokenToFunction(token2, delimiter, encode2) {
    if (token2.type === "text")
      return () => [token2.value];
    if (token2.type === "group") {
      const fn = tokensToFunction(token2.tokens, delimiter, encode2);
      return (data) => {
        const [value, ...missing] = fn(data);
        if (!missing.length)
          return [value];
        return [""];
      };
    }
    const encodeValue = encode2 || NOOP_VALUE;
    if (token2.type === "wildcard" && encode2 !== false) {
      return (data) => {
        const value = data[token2.name];
        if (value == null)
          return ["", token2.name];
        if (!Array.isArray(value) || value.length === 0) {
          throw new TypeError(`Expected "${token2.name}" to be a non-empty array`);
        }
        return [
          value.map((value2, index) => {
            if (typeof value2 !== "string") {
              throw new TypeError(`Expected "${token2.name}/${index}" to be a string`);
            }
            return encodeValue(value2);
          }).join(delimiter)
        ];
      };
    }
    return (data) => {
      const value = data[token2.name];
      if (value == null)
        return ["", token2.name];
      if (typeof value !== "string") {
        throw new TypeError(`Expected "${token2.name}" to be a string`);
      }
      return [encodeValue(value)];
    };
  }
  function match(path2, options = {}) {
    const { decode: decode2 = decodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const { regexp, keys } = pathToRegexp(path2, options);
    const decoders = keys.map((key2) => {
      if (decode2 === false)
        return NOOP_VALUE;
      if (key2.type === "param")
        return decode2;
      return (value) => value.split(delimiter).map(decode2);
    });
    return function match2(input) {
      const m = regexp.exec(input);
      if (!m)
        return false;
      const path3 = m[0];
      const params = /* @__PURE__ */ Object.create(null);
      for (let i = 1; i < m.length; i++) {
        if (m[i] === void 0)
          continue;
        const key2 = keys[i - 1];
        const decoder2 = decoders[i - 1];
        params[key2.name] = decoder2(m[i]);
      }
      return { path: path3, params };
    };
  }
  function pathToRegexp(path2, options = {}) {
    const { delimiter = DEFAULT_DELIMITER, end = true, sensitive = false, trailing = true } = options;
    const keys = [];
    const sources = [];
    const flags = sensitive ? "" : "i";
    const paths = Array.isArray(path2) ? path2 : [path2];
    const items = paths.map((path3) => path3 instanceof TokenData ? path3 : parse3(path3, options));
    for (const { tokens } of items) {
      for (const seq of flatten2(tokens, 0, [])) {
        const regexp2 = sequenceToRegExp(seq, delimiter, keys);
        sources.push(regexp2);
      }
    }
    let pattern2 = `^(?:${sources.join("|")})`;
    if (trailing)
      pattern2 += `(?:${escape2(delimiter)}$)?`;
    pattern2 += end ? "$" : `(?=${escape2(delimiter)}|$)`;
    const regexp = new RegExp(pattern2, flags);
    return { regexp, keys };
  }
  function* flatten2(tokens, index, init2) {
    if (index === tokens.length) {
      return yield init2;
    }
    const token2 = tokens[index];
    if (token2.type === "group") {
      const fork = init2.slice();
      for (const seq of flatten2(token2.tokens, 0, fork)) {
        yield* flatten2(tokens, index + 1, seq);
      }
    } else {
      init2.push(token2);
    }
    yield* flatten2(tokens, index + 1, init2);
  }
  function sequenceToRegExp(tokens, delimiter, keys) {
    let result = "";
    let backtrack = "";
    let isSafeSegmentParam = true;
    for (let i = 0; i < tokens.length; i++) {
      const token2 = tokens[i];
      if (token2.type === "text") {
        result += escape2(token2.value);
        backtrack += token2.value;
        isSafeSegmentParam || (isSafeSegmentParam = token2.value.includes(delimiter));
        continue;
      }
      if (token2.type === "param" || token2.type === "wildcard") {
        if (!isSafeSegmentParam && !backtrack) {
          throw new TypeError(`Missing text after "${token2.name}": ${DEBUG_URL}`);
        }
        if (token2.type === "param") {
          result += `(${negate(delimiter, isSafeSegmentParam ? "" : backtrack)}+)`;
        } else {
          result += `([\\s\\S]+)`;
        }
        keys.push(token2);
        backtrack = "";
        isSafeSegmentParam = false;
        continue;
      }
    }
    return result;
  }
  function negate(delimiter, backtrack) {
    if (backtrack.length < 2) {
      if (delimiter.length < 2)
        return `[^${escape2(delimiter + backtrack)}]`;
      return `(?:(?!${escape2(delimiter)})[^${escape2(backtrack)}])`;
    }
    if (delimiter.length < 2) {
      return `(?:(?!${escape2(backtrack)})[^${escape2(delimiter)}])`;
    }
    return `(?:(?!${escape2(backtrack)}|${escape2(delimiter)})[\\s\\S])`;
  }
  function stringify3(data) {
    return data.tokens.map(function stringifyToken(token2, index, tokens) {
      if (token2.type === "text")
        return escapeText(token2.value);
      if (token2.type === "group") {
        return `{${token2.tokens.map(stringifyToken).join("")}}`;
      }
      const isSafe = isNameSafe(token2.name) && isNextNameSafe(tokens[index + 1]);
      const key2 = isSafe ? token2.name : JSON.stringify(token2.name);
      if (token2.type === "param")
        return `:${key2}`;
      if (token2.type === "wildcard")
        return `*${key2}`;
      throw new TypeError(`Unexpected token: ${token2}`);
    }).join("");
  }
  function isNameSafe(name) {
    const [first, ...rest] = name;
    if (!ID_START.test(first))
      return false;
    return rest.every((char) => ID_CONTINUE.test(char));
  }
  function isNextNameSafe(token2) {
    if ((token2 === null || token2 === void 0 ? void 0 : token2.type) !== "text")
      return true;
    return !ID_CONTINUE.test(token2.value[0]);
  }
  return dist;
}
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var layer;
var hasRequiredLayer;
function requireLayer() {
  if (hasRequiredLayer) return layer;
  hasRequiredLayer = 1;
  const isPromise2 = requireIsPromise();
  const pathRegexp = requireDist();
  const debug = require$$0$8("router:layer");
  const deprecate = requireBrowser()("router");
  const TRAILING_SLASH_REGEXP = /\/+$/;
  const MATCHING_GROUP_REGEXP = /\((?:\?<(.*?)>)?(?!\?)/g;
  layer = Layer;
  function Layer(path2, options, fn) {
    if (!(this instanceof Layer)) {
      return new Layer(path2, options, fn);
    }
    debug("new %o", path2);
    const opts = options || {};
    this.handle = fn;
    this.keys = [];
    this.name = fn.name || "<anonymous>";
    this.params = void 0;
    this.path = void 0;
    this.slash = path2 === "/" && opts.end === false;
    function matcher(_path) {
      if (_path instanceof RegExp) {
        const keys = [];
        let name = 0;
        let m;
        while (m = MATCHING_GROUP_REGEXP.exec(_path.source)) {
          keys.push({
            name: m[1] || name++,
            offset: m.index
          });
        }
        return function regexpMatcher(p) {
          const match = _path.exec(p);
          if (!match) {
            return false;
          }
          const params = {};
          for (let i = 1; i < match.length; i++) {
            const key2 = keys[i - 1];
            const prop = key2.name;
            const val = decodeParam(match[i]);
            if (val !== void 0) {
              params[prop] = val;
            }
          }
          return {
            params,
            path: match[0]
          };
        };
      }
      return pathRegexp.match(opts.strict ? _path : loosen(_path), {
        sensitive: opts.sensitive,
        end: opts.end,
        trailing: !opts.strict,
        decode: decodeParam
      });
    }
    this.matchers = Array.isArray(path2) ? path2.map(matcher) : [matcher(path2)];
  }
  Layer.prototype.handleError = function handleError(error, req, res, next) {
    const fn = this.handle;
    if (fn.length !== 4) {
      return next(error);
    }
    try {
      const ret = fn(error, req, res, next);
      if (isPromise2(ret)) {
        if (!(ret instanceof Promise)) {
          deprecate("handlers that are Promise-like are deprecated, use a native Promise instead");
        }
        ret.then(null, function(error2) {
          next(error2 || new Error("Rejected promise"));
        });
      }
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.handleRequest = function handleRequest(req, res, next) {
    const fn = this.handle;
    if (fn.length > 3) {
      return next();
    }
    try {
      const ret = fn(req, res, next);
      if (isPromise2(ret)) {
        if (!(ret instanceof Promise)) {
          deprecate("handlers that are Promise-like are deprecated, use a native Promise instead");
        }
        ret.then(null, function(error) {
          next(error || new Error("Rejected promise"));
        });
      }
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.match = function match(path2) {
    let match2;
    if (path2 != null) {
      if (this.slash) {
        this.params = {};
        this.path = "";
        return true;
      }
      let i = 0;
      while (!match2 && i < this.matchers.length) {
        match2 = this.matchers[i](path2);
        i++;
      }
    }
    if (!match2) {
      this.params = void 0;
      this.path = void 0;
      return false;
    }
    this.params = match2.params;
    this.path = match2.path;
    this.keys = Object.keys(match2.params);
    return true;
  };
  function decodeParam(val) {
    if (typeof val !== "string" || val.length === 0) {
      return val;
    }
    try {
      return decodeURIComponent(val);
    } catch (err) {
      if (err instanceof URIError) {
        err.message = "Failed to decode param '" + val + "'";
        err.status = 400;
      }
      throw err;
    }
  }
  function loosen(path2) {
    if (path2 instanceof RegExp || path2 === "/") {
      return path2;
    }
    return Array.isArray(path2) ? path2.map(function(p) {
      return loosen(p);
    }) : String(path2).replace(TRAILING_SLASH_REGEXP, "");
  }
  return layer;
}
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var route;
var hasRequiredRoute;
function requireRoute() {
  if (hasRequiredRoute) return route;
  hasRequiredRoute = 1;
  const debug = require$$0$8("router:route");
  const Layer = requireLayer();
  const { METHODS } = require$$2$3;
  const slice = Array.prototype.slice;
  const flatten2 = Array.prototype.flat;
  const methods2 = METHODS.map((method) => method.toLowerCase());
  route = Route;
  function Route(path2) {
    debug("new %o", path2);
    this.path = path2;
    this.stack = [];
    this.methods = /* @__PURE__ */ Object.create(null);
  }
  Route.prototype._handlesMethod = function _handlesMethod(method) {
    if (this.methods._all) {
      return true;
    }
    let name = typeof method === "string" ? method.toLowerCase() : method;
    if (name === "head" && !this.methods.head) {
      name = "get";
    }
    return Boolean(this.methods[name]);
  };
  Route.prototype._methods = function _methods() {
    const methods3 = Object.keys(this.methods);
    if (this.methods.get && !this.methods.head) {
      methods3.push("head");
    }
    for (let i = 0; i < methods3.length; i++) {
      methods3[i] = methods3[i].toUpperCase();
    }
    return methods3;
  };
  Route.prototype.dispatch = function dispatch(req, res, done) {
    let idx = 0;
    const stack2 = this.stack;
    let sync = 0;
    if (stack2.length === 0) {
      return done();
    }
    let method = typeof req.method === "string" ? req.method.toLowerCase() : req.method;
    if (method === "head" && !this.methods.head) {
      method = "get";
    }
    req.route = this;
    next();
    function next(err) {
      if (err && err === "route") {
        return done();
      }
      if (err && err === "router") {
        return done(err);
      }
      if (idx >= stack2.length) {
        return done(err);
      }
      if (++sync > 100) {
        return setImmediate(next, err);
      }
      let layer2;
      let match;
      while (match !== true && idx < stack2.length) {
        layer2 = stack2[idx++];
        match = !layer2.method || layer2.method === method;
      }
      if (match !== true) {
        return done(err);
      }
      if (err) {
        layer2.handleError(err, req, res, next);
      } else {
        layer2.handleRequest(req, res, next);
      }
      sync = 0;
    }
  };
  Route.prototype.all = function all(handler) {
    const callbacks = flatten2.call(slice.call(arguments), Infinity);
    if (callbacks.length === 0) {
      throw new TypeError("argument handler is required");
    }
    for (let i = 0; i < callbacks.length; i++) {
      const fn = callbacks[i];
      if (typeof fn !== "function") {
        throw new TypeError("argument handler must be a function");
      }
      const layer2 = Layer("/", {}, fn);
      layer2.method = void 0;
      this.methods._all = true;
      this.stack.push(layer2);
    }
    return this;
  };
  methods2.forEach(function(method) {
    Route.prototype[method] = function(handler) {
      const callbacks = flatten2.call(slice.call(arguments), Infinity);
      if (callbacks.length === 0) {
        throw new TypeError("argument handler is required");
      }
      for (let i = 0; i < callbacks.length; i++) {
        const fn = callbacks[i];
        if (typeof fn !== "function") {
          throw new TypeError("argument handler must be a function");
        }
        debug("%s %s", method, this.path);
        const layer2 = Layer("/", {}, fn);
        layer2.method = method;
        this.methods[method] = true;
        this.stack.push(layer2);
      }
      return this;
    };
  });
  return route;
}
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredRouter;
function requireRouter() {
  if (hasRequiredRouter) return router.exports;
  hasRequiredRouter = 1;
  const isPromise2 = requireIsPromise();
  const Layer = requireLayer();
  const { METHODS } = require$$2$3;
  const parseUrl = requireParseurl();
  const Route = requireRoute();
  const debug = require$$0$8("router");
  const deprecate = requireBrowser()("router");
  const slice = Array.prototype.slice;
  const flatten2 = Array.prototype.flat;
  const methods2 = METHODS.map((method) => method.toLowerCase());
  router.exports = Router;
  router.exports.Route = Route;
  function Router(options) {
    if (!(this instanceof Router)) {
      return new Router(options);
    }
    const opts = options || {};
    function router2(req, res, next) {
      router2.handle(req, res, next);
    }
    Object.setPrototypeOf(router2, this);
    router2.caseSensitive = opts.caseSensitive;
    router2.mergeParams = opts.mergeParams;
    router2.params = {};
    router2.strict = opts.strict;
    router2.stack = [];
    return router2;
  }
  Router.prototype = function() {
  };
  Router.prototype.param = function param(name, fn) {
    if (!name) {
      throw new TypeError("argument name is required");
    }
    if (typeof name !== "string") {
      throw new TypeError("argument name must be a string");
    }
    if (!fn) {
      throw new TypeError("argument fn is required");
    }
    if (typeof fn !== "function") {
      throw new TypeError("argument fn must be a function");
    }
    let params = this.params[name];
    if (!params) {
      params = this.params[name] = [];
    }
    params.push(fn);
    return this;
  };
  Router.prototype.handle = function handle(req, res, callback) {
    if (!callback) {
      throw new TypeError("argument callback is required");
    }
    debug("dispatching %s %s", req.method, req.url);
    let idx = 0;
    let methods3;
    const protohost = getProtohost(req.url) || "";
    let removed = "";
    const self2 = this;
    let slashAdded = false;
    let sync = 0;
    const paramcalled = {};
    const stack2 = this.stack;
    const parentParams = req.params;
    const parentUrl = req.baseUrl || "";
    let done = restore(callback, req, "baseUrl", "next", "params");
    req.next = next;
    if (req.method === "OPTIONS") {
      methods3 = [];
      done = wrap(done, generateOptionsResponder(res, methods3));
    }
    req.baseUrl = parentUrl;
    req.originalUrl = req.originalUrl || req.url;
    next();
    function next(err) {
      let layerError = err === "route" ? null : err;
      if (slashAdded) {
        req.url = req.url.slice(1);
        slashAdded = false;
      }
      if (removed.length !== 0) {
        req.baseUrl = parentUrl;
        req.url = protohost + removed + req.url.slice(protohost.length);
        removed = "";
      }
      if (layerError === "router") {
        setImmediate(done, null);
        return;
      }
      if (idx >= stack2.length) {
        setImmediate(done, layerError);
        return;
      }
      if (++sync > 100) {
        return setImmediate(next, err);
      }
      const path2 = getPathname(req);
      if (path2 == null) {
        return done(layerError);
      }
      let layer2;
      let match;
      let route2;
      while (match !== true && idx < stack2.length) {
        layer2 = stack2[idx++];
        match = matchLayer(layer2, path2);
        route2 = layer2.route;
        if (typeof match !== "boolean") {
          layerError = layerError || match;
        }
        if (match !== true) {
          continue;
        }
        if (!route2) {
          continue;
        }
        if (layerError) {
          match = false;
          continue;
        }
        const method = req.method;
        const hasMethod = route2._handlesMethod(method);
        if (!hasMethod && method === "OPTIONS" && methods3) {
          methods3.push.apply(methods3, route2._methods());
        }
        if (!hasMethod && method !== "HEAD") {
          match = false;
        }
      }
      if (match !== true) {
        return done(layerError);
      }
      if (route2) {
        req.route = route2;
      }
      req.params = self2.mergeParams ? mergeParams(layer2.params, parentParams) : layer2.params;
      const layerPath = layer2.path;
      processParams(self2.params, layer2, paramcalled, req, res, function(err2) {
        if (err2) {
          next(layerError || err2);
        } else if (route2) {
          layer2.handleRequest(req, res, next);
        } else {
          trimPrefix(layer2, layerError, layerPath, path2);
        }
        sync = 0;
      });
    }
    function trimPrefix(layer2, layerError, layerPath, path2) {
      if (layerPath.length !== 0) {
        if (layerPath !== path2.substring(0, layerPath.length)) {
          next(layerError);
          return;
        }
        const c2 = path2[layerPath.length];
        if (c2 && c2 !== "/") {
          next(layerError);
          return;
        }
        debug("trim prefix (%s) from url %s", layerPath, req.url);
        removed = layerPath;
        req.url = protohost + req.url.slice(protohost.length + removed.length);
        if (!protohost && req.url[0] !== "/") {
          req.url = "/" + req.url;
          slashAdded = true;
        }
        req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
      }
      debug("%s %s : %s", layer2.name, layerPath, req.originalUrl);
      if (layerError) {
        layer2.handleError(layerError, req, res, next);
      } else {
        layer2.handleRequest(req, res, next);
      }
    }
  };
  Router.prototype.use = function use(handler) {
    let offset = 0;
    let path2 = "/";
    if (typeof handler !== "function") {
      let arg = handler;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path2 = handler;
      }
    }
    const callbacks = flatten2.call(slice.call(arguments, offset), Infinity);
    if (callbacks.length === 0) {
      throw new TypeError("argument handler is required");
    }
    for (let i = 0; i < callbacks.length; i++) {
      const fn = callbacks[i];
      if (typeof fn !== "function") {
        throw new TypeError("argument handler must be a function");
      }
      debug("use %o %s", path2, fn.name || "<anonymous>");
      const layer2 = new Layer(path2, {
        sensitive: this.caseSensitive,
        strict: false,
        end: false
      }, fn);
      layer2.route = void 0;
      this.stack.push(layer2);
    }
    return this;
  };
  Router.prototype.route = function route2(path2) {
    const route3 = new Route(path2);
    const layer2 = new Layer(path2, {
      sensitive: this.caseSensitive,
      strict: this.strict,
      end: true
    }, handle);
    function handle(req, res, next) {
      route3.dispatch(req, res, next);
    }
    layer2.route = route3;
    this.stack.push(layer2);
    return route3;
  };
  methods2.concat("all").forEach(function(method) {
    Router.prototype[method] = function(path2) {
      const route2 = this.route(path2);
      route2[method].apply(route2, slice.call(arguments, 1));
      return this;
    };
  });
  function generateOptionsResponder(res, methods3) {
    return function onDone(fn, err) {
      if (err || methods3.length === 0) {
        return fn(err);
      }
      trySendOptionsResponse(res, methods3, fn);
    };
  }
  function getPathname(req) {
    try {
      return parseUrl(req).pathname;
    } catch (err) {
      return void 0;
    }
  }
  function getProtohost(url) {
    if (typeof url !== "string" || url.length === 0 || url[0] === "/") {
      return void 0;
    }
    const searchIndex = url.indexOf("?");
    const pathLength = searchIndex !== -1 ? searchIndex : url.length;
    const fqdnIndex = url.substring(0, pathLength).indexOf("://");
    return fqdnIndex !== -1 ? url.substring(0, url.indexOf("/", 3 + fqdnIndex)) : void 0;
  }
  function matchLayer(layer2, path2) {
    try {
      return layer2.match(path2);
    } catch (err) {
      return err;
    }
  }
  function mergeParams(params, parent) {
    if (typeof parent !== "object" || !parent) {
      return params;
    }
    const obj = Object.assign({}, parent);
    if (!(0 in params) || !(0 in parent)) {
      return Object.assign(obj, params);
    }
    let i = 0;
    let o = 0;
    while (i in params) {
      i++;
    }
    while (o in parent) {
      o++;
    }
    for (i--; i >= 0; i--) {
      params[i + o] = params[i];
      if (i < o) {
        delete params[i];
      }
    }
    return Object.assign(obj, params);
  }
  function processParams(params, layer2, called, req, res, done) {
    const keys = layer2.keys;
    if (!keys || keys.length === 0) {
      return done();
    }
    let i = 0;
    let paramIndex = 0;
    let key2;
    let paramVal;
    let paramCallbacks;
    let paramCalled;
    function param(err) {
      if (err) {
        return done(err);
      }
      if (i >= keys.length) {
        return done();
      }
      paramIndex = 0;
      key2 = keys[i++];
      paramVal = req.params[key2];
      paramCallbacks = params[key2];
      paramCalled = called[key2];
      if (paramVal === void 0 || !paramCallbacks) {
        return param();
      }
      if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
        req.params[key2] = paramCalled.value;
        return param(paramCalled.error);
      }
      called[key2] = paramCalled = {
        error: null,
        match: paramVal,
        value: paramVal
      };
      paramCallback();
    }
    function paramCallback(err) {
      const fn = paramCallbacks[paramIndex++];
      paramCalled.value = req.params[key2];
      if (err) {
        paramCalled.error = err;
        param(err);
        return;
      }
      if (!fn) return param();
      try {
        const ret = fn(req, res, paramCallback, paramVal, key2);
        if (isPromise2(ret)) {
          if (!(ret instanceof Promise)) {
            deprecate("parameters that are Promise-like are deprecated, use a native Promise instead");
          }
          ret.then(null, function(error) {
            paramCallback(error || new Error("Rejected promise"));
          });
        }
      } catch (e) {
        paramCallback(e);
      }
    }
    param();
  }
  function restore(fn, obj) {
    const props = new Array(arguments.length - 2);
    const vals = new Array(arguments.length - 2);
    for (let i = 0; i < props.length; i++) {
      props[i] = arguments[i + 2];
      vals[i] = obj[props[i]];
    }
    return function() {
      for (let i = 0; i < props.length; i++) {
        obj[props[i]] = vals[i];
      }
      return fn.apply(this, arguments);
    };
  }
  function sendOptionsResponse(res, methods3) {
    const options = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < methods3.length; i++) {
      options[methods3[i]] = true;
    }
    const allow = Object.keys(options).sort().join(", ");
    res.setHeader("Allow", allow);
    res.setHeader("Content-Length", Buffer.byteLength(allow));
    res.setHeader("Content-Type", "text/plain");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.end(allow);
  }
  function trySendOptionsResponse(res, methods3, next) {
    try {
      sendOptionsResponse(res, methods3);
    } catch (err) {
      next(err);
    }
  }
  function wrap(old, fn) {
    return function proxy() {
      const args = new Array(arguments.length + 1);
      args[0] = old;
      for (let i = 0, len = arguments.length; i < len; i++) {
        args[i + 1] = arguments[i];
      }
      fn.apply(this, args);
    };
  }
  return router.exports;
}
var hasRequiredApplication;
function requireApplication() {
  if (hasRequiredApplication) return application.exports;
  hasRequiredApplication = 1;
  (function(module, exports) {
    /*!
     * express
     * Copyright(c) 2009-2013 TJ Holowaychuk
     * Copyright(c) 2013 Roman Shtylman
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    var finalhandler = requireFinalhandler();
    var debug = require$$0$8("express:application");
    var View = requireView();
    var http = require$$2$3;
    var methods2 = requireUtils().methods;
    var compileETag = requireUtils().compileETag;
    var compileQueryParser = requireUtils().compileQueryParser;
    var compileTrust = requireUtils().compileTrust;
    var resolve2 = path__default.resolve;
    var once2 = requireOnce();
    var Router = requireRouter();
    var slice = Array.prototype.slice;
    var flatten2 = Array.prototype.flat;
    var app = module.exports = {};
    var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
    app.init = function init2() {
      var router2 = null;
      this.cache = /* @__PURE__ */ Object.create(null);
      this.engines = /* @__PURE__ */ Object.create(null);
      this.settings = /* @__PURE__ */ Object.create(null);
      this.defaultConfiguration();
      Object.defineProperty(this, "router", {
        configurable: true,
        enumerable: true,
        get: function getrouter() {
          if (router2 === null) {
            router2 = new Router({
              caseSensitive: this.enabled("case sensitive routing"),
              strict: this.enabled("strict routing")
            });
          }
          return router2;
        }
      });
    };
    app.defaultConfiguration = function defaultConfiguration() {
      var env = "production";
      this.enable("x-powered-by");
      this.set("etag", "weak");
      this.set("env", env);
      this.set("query parser", "simple");
      this.set("subdomain offset", 2);
      this.set("trust proxy", false);
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
      });
      debug("booting in %s mode", env);
      this.on("mount", function onmount(parent) {
        if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
          delete this.settings["trust proxy"];
          delete this.settings["trust proxy fn"];
        }
        Object.setPrototypeOf(this.request, parent.request);
        Object.setPrototypeOf(this.response, parent.response);
        Object.setPrototypeOf(this.engines, parent.engines);
        Object.setPrototypeOf(this.settings, parent.settings);
      });
      this.locals = /* @__PURE__ */ Object.create(null);
      this.mountpath = "/";
      this.locals.settings = this.settings;
      this.set("view", View);
      this.set("views", resolve2("views"));
      this.set("jsonp callback name", "callback");
      {
        this.enable("view cache");
      }
    };
    app.handle = function handle(req, res, callback) {
      var done = callback || finalhandler(req, res, {
        env: this.get("env"),
        onerror: logerror.bind(this)
      });
      if (this.enabled("x-powered-by")) {
        res.setHeader("X-Powered-By", "Express");
      }
      req.res = res;
      res.req = req;
      Object.setPrototypeOf(req, this.request);
      Object.setPrototypeOf(res, this.response);
      if (!res.locals) {
        res.locals = /* @__PURE__ */ Object.create(null);
      }
      this.router.handle(req, res, done);
    };
    app.use = function use(fn) {
      var offset = 0;
      var path2 = "/";
      if (typeof fn !== "function") {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== "function") {
          offset = 1;
          path2 = fn;
        }
      }
      var fns = flatten2.call(slice.call(arguments, offset), Infinity);
      if (fns.length === 0) {
        throw new TypeError("app.use() requires a middleware function");
      }
      var router2 = this.router;
      fns.forEach(function(fn2) {
        if (!fn2 || !fn2.handle || !fn2.set) {
          return router2.use(path2, fn2);
        }
        debug(".use app under %s", path2);
        fn2.mountpath = path2;
        fn2.parent = this;
        router2.use(path2, function mounted_app(req, res, next) {
          var orig = req.app;
          fn2.handle(req, res, function(err) {
            Object.setPrototypeOf(req, orig.request);
            Object.setPrototypeOf(res, orig.response);
            next(err);
          });
        });
        fn2.emit("mount", this);
      }, this);
      return this;
    };
    app.route = function route2(path2) {
      return this.router.route(path2);
    };
    app.engine = function engine(ext, fn) {
      if (typeof fn !== "function") {
        throw new Error("callback function required");
      }
      var extension = ext[0] !== "." ? "." + ext : ext;
      this.engines[extension] = fn;
      return this;
    };
    app.param = function param(name, fn) {
      if (Array.isArray(name)) {
        for (var i = 0; i < name.length; i++) {
          this.param(name[i], fn);
        }
        return this;
      }
      this.router.param(name, fn);
      return this;
    };
    app.set = function set(setting, val) {
      if (arguments.length === 1) {
        return this.settings[setting];
      }
      debug('set "%s" to %o', setting, val);
      this.settings[setting] = val;
      switch (setting) {
        case "etag":
          this.set("etag fn", compileETag(val));
          break;
        case "query parser":
          this.set("query parser fn", compileQueryParser(val));
          break;
        case "trust proxy":
          this.set("trust proxy fn", compileTrust(val));
          Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
            configurable: true,
            value: false
          });
          break;
      }
      return this;
    };
    app.path = function path2() {
      return this.parent ? this.parent.path() + this.mountpath : "";
    };
    app.enabled = function enabled(setting) {
      return Boolean(this.set(setting));
    };
    app.disabled = function disabled(setting) {
      return !this.set(setting);
    };
    app.enable = function enable(setting) {
      return this.set(setting, true);
    };
    app.disable = function disable(setting) {
      return this.set(setting, false);
    };
    methods2.forEach(function(method) {
      app[method] = function(path2) {
        if (method === "get" && arguments.length === 1) {
          return this.set(path2);
        }
        var route2 = this.route(path2);
        route2[method].apply(route2, slice.call(arguments, 1));
        return this;
      };
    });
    app.all = function all(path2) {
      var route2 = this.route(path2);
      var args = slice.call(arguments, 1);
      for (var i = 0; i < methods2.length; i++) {
        route2[methods2[i]].apply(route2, args);
      }
      return this;
    };
    app.render = function render(name, options, callback) {
      var cache = this.cache;
      var done = callback;
      var engines = this.engines;
      var opts = options;
      var view2;
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      var renderOptions = { ...this.locals, ...opts._locals, ...opts };
      if (renderOptions.cache == null) {
        renderOptions.cache = this.enabled("view cache");
      }
      if (renderOptions.cache) {
        view2 = cache[name];
      }
      if (!view2) {
        var View2 = this.get("view");
        view2 = new View2(name, {
          defaultEngine: this.get("view engine"),
          root: this.get("views"),
          engines
        });
        if (!view2.path) {
          var dirs = Array.isArray(view2.root) && view2.root.length > 1 ? 'directories "' + view2.root.slice(0, -1).join('", "') + '" or "' + view2.root[view2.root.length - 1] + '"' : 'directory "' + view2.root + '"';
          var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
          err.view = view2;
          return done(err);
        }
        if (renderOptions.cache) {
          cache[name] = view2;
        }
      }
      tryRender(view2, renderOptions, done);
    };
    app.listen = function listen() {
      var server = http.createServer(this);
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[args.length - 1] === "function") {
        var done = args[args.length - 1] = once2(args[args.length - 1]);
        server.once("error", done);
      }
      return server.listen.apply(server, args);
    };
    function logerror(err) {
      if (this.get("env") !== "test") console.error(err.stack || err.toString());
    }
    function tryRender(view2, options, callback) {
      try {
        view2.render(options, callback);
      } catch (err) {
        callback(err);
      }
    }
  })(application);
  return application.exports;
}
var negotiator = { exports: {} };
var charset = { exports: {} };
var hasRequiredCharset;
function requireCharset() {
  if (hasRequiredCharset) return charset.exports;
  hasRequiredCharset = 1;
  charset.exports = preferredCharsets;
  charset.exports.preferredCharsets = preferredCharsets;
  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptCharset(accept) {
    var accepts2 = accept.split(",");
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var charset2 = parseCharset(accepts2[i].trim(), i);
      if (charset2) {
        accepts2[j++] = charset2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseCharset(str, i) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match) return null;
    var charset2 = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset: charset2,
      q,
      i
    };
  }
  function getCharsetPriority(charset2, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(charset2, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(charset2, spec, index) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset2.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredCharsets(accept, provided) {
    var accepts2 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type2, index) {
      return getCharsetPriority(type2, accepts2, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullCharset(spec) {
    return spec.charset;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return charset.exports;
}
var encoding = { exports: {} };
var hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding) return encoding.exports;
  hasRequiredEncoding = 1;
  encoding.exports = preferredEncodings;
  encoding.exports.preferredEncodings = preferredEncodings;
  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptEncoding(accept) {
    var accepts2 = accept.split(",");
    var hasIdentity = false;
    var minQuality = 1;
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var encoding2 = parseEncoding(accepts2[i].trim(), i);
      if (encoding2) {
        accepts2[j++] = encoding2;
        hasIdentity = hasIdentity || specify("identity", encoding2);
        minQuality = Math.min(minQuality, encoding2.q || 1);
      }
    }
    if (!hasIdentity) {
      accepts2[j++] = {
        encoding: "identity",
        q: minQuality,
        i
      };
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseEncoding(str, i) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match) return null;
    var encoding2 = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding: encoding2,
      q,
      i
    };
  }
  function getEncodingPriority(encoding2, accepted, index) {
    var priority = { encoding: encoding2, o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(encoding2, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(encoding2, spec, index) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding2.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== "*") {
      return null;
    }
    return {
      encoding: encoding2,
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredEncodings(accept, provided, preferred) {
    var accepts2 = parseAcceptEncoding(accept || "");
    var comparator2 = preferred ? function comparator3(a, b) {
      if (a.q !== b.q) {
        return b.q - a.q;
      }
      var aPreferred = preferred.indexOf(a.encoding);
      var bPreferred = preferred.indexOf(b.encoding);
      if (aPreferred === -1 && bPreferred === -1) {
        return b.s - a.s || a.o - b.o || a.i - b.i;
      }
      if (aPreferred !== -1 && bPreferred !== -1) {
        return aPreferred - bPreferred;
      }
      return aPreferred === -1 ? 1 : -1;
    } : compareSpecs;
    if (!provided) {
      return accepts2.filter(isQuality).sort(comparator2).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type2, index) {
      return getEncodingPriority(type2, accepts2, index);
    });
    return priorities.filter(isQuality).sort(comparator2).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i;
  }
  function getFullEncoding(spec) {
    return spec.encoding;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return encoding.exports;
}
var language = { exports: {} };
var hasRequiredLanguage;
function requireLanguage() {
  if (hasRequiredLanguage) return language.exports;
  hasRequiredLanguage = 1;
  language.exports = preferredLanguages;
  language.exports.preferredLanguages = preferredLanguages;
  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  function parseAcceptLanguage(accept) {
    var accepts2 = accept.split(",");
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var language2 = parseLanguage(accepts2[i].trim(), i);
      if (language2) {
        accepts2[j++] = language2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseLanguage(str, i) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match) return null;
    var prefix = match[1];
    var suffix = match[2];
    var full = prefix;
    if (suffix) full += "-" + suffix;
    var q = 1;
    if (match[3]) {
      var params = match[3].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].split("=");
        if (p[0] === "q") q = parseFloat(p[1]);
      }
    }
    return {
      prefix,
      suffix,
      q,
      i,
      full
    };
  }
  function getLanguagePriority(language2, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(language2, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(language2, spec, index) {
    var p = parseLanguage(language2);
    if (!p) return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredLanguages(accept, provided) {
    var accepts2 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type2, index) {
      return getLanguagePriority(type2, accepts2, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullLanguage(spec) {
    return spec.full;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return language.exports;
}
var mediaType = { exports: {} };
var hasRequiredMediaType;
function requireMediaType() {
  if (hasRequiredMediaType) return mediaType.exports;
  hasRequiredMediaType = 1;
  mediaType.exports = preferredMediaTypes;
  mediaType.exports.preferredMediaTypes = preferredMediaTypes;
  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
  function parseAccept(accept) {
    var accepts2 = splitMediaTypes(accept);
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var mediaType2 = parseMediaType(accepts2[i].trim(), i);
      if (mediaType2) {
        accepts2[j++] = mediaType2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseMediaType(str, i) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match) return null;
    var params = /* @__PURE__ */ Object.create(null);
    var q = 1;
    var subtype = match[2];
    var type2 = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j = 0; j < kvps.length; j++) {
        var pair = kvps[j];
        var key2 = pair[0].toLowerCase();
        var val = pair[1];
        var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.slice(1, -1) : val;
        if (key2 === "q") {
          q = parseFloat(value);
          break;
        }
        params[key2] = value;
      }
    }
    return {
      type: type2,
      subtype,
      params,
      q,
      i
    };
  }
  function getMediaTypePriority(type2, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(type2, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(type2, spec, index) {
    var p = parseMediaType(type2);
    var s = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != "*") {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != "*") {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function(k) {
        return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredMediaTypes(accept, provided) {
    var accepts2 = parseAccept(accept === void 0 ? "*/*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type2, index) {
      return getMediaTypePriority(type2, accepts2, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullType(spec) {
    return spec.type + "/" + spec.subtype;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  function quoteCount(string) {
    var count = 0;
    var index = 0;
    while ((index = string.indexOf('"', index)) !== -1) {
      count++;
      index++;
    }
    return count;
  }
  function splitKeyValuePair(str) {
    var index = str.indexOf("=");
    var key2;
    var val;
    if (index === -1) {
      key2 = str;
    } else {
      key2 = str.slice(0, index);
      val = str.slice(index + 1);
    }
    return [key2, val];
  }
  function splitMediaTypes(accept) {
    var accepts2 = accept.split(",");
    for (var i = 1, j = 0; i < accepts2.length; i++) {
      if (quoteCount(accepts2[j]) % 2 == 0) {
        accepts2[++j] = accepts2[i];
      } else {
        accepts2[j] += "," + accepts2[i];
      }
    }
    accepts2.length = j + 1;
    return accepts2;
  }
  function splitParameters(str) {
    var parameters = str.split(";");
    for (var i = 1, j = 0; i < parameters.length; i++) {
      if (quoteCount(parameters[j]) % 2 == 0) {
        parameters[++j] = parameters[i];
      } else {
        parameters[j] += ";" + parameters[i];
      }
    }
    parameters.length = j + 1;
    for (var i = 0; i < parameters.length; i++) {
      parameters[i] = parameters[i].trim();
    }
    return parameters;
  }
  return mediaType.exports;
}
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredNegotiator;
function requireNegotiator() {
  if (hasRequiredNegotiator) return negotiator.exports;
  hasRequiredNegotiator = 1;
  var preferredCharsets = requireCharset();
  var preferredEncodings = requireEncoding();
  var preferredLanguages = requireLanguage();
  var preferredMediaTypes = requireMediaType();
  negotiator.exports = Negotiator;
  negotiator.exports.Negotiator = Negotiator;
  function Negotiator(request2) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request2);
    }
    this.request = request2;
  }
  Negotiator.prototype.charset = function charset2(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers["accept-charset"], available);
  };
  Negotiator.prototype.encoding = function encoding2(available, opts) {
    var set = this.encodings(available, opts);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings2(available, options) {
    var opts = options || {};
    return preferredEncodings(this.request.headers["accept-encoding"], available, opts.preferred);
  };
  Negotiator.prototype.language = function language2(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers["accept-language"], available);
  };
  Negotiator.prototype.mediaType = function mediaType2(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  return negotiator.exports;
}
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var accepts;
var hasRequiredAccepts;
function requireAccepts() {
  if (hasRequiredAccepts) return accepts;
  hasRequiredAccepts = 1;
  var Negotiator = requireNegotiator();
  var mime = requireMimeTypes();
  accepts = Accepts;
  function Accepts(req) {
    if (!(this instanceof Accepts)) {
      return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  }
  Accepts.prototype.type = Accepts.prototype.types = function(types_) {
    var types2 = types_;
    if (types2 && !Array.isArray(types2)) {
      types2 = new Array(arguments.length);
      for (var i = 0; i < types2.length; i++) {
        types2[i] = arguments[i];
      }
    }
    if (!types2 || types2.length === 0) {
      return this.negotiator.mediaTypes();
    }
    if (!this.headers.accept) {
      return types2[0];
    }
    var mimes = types2.map(extToMime);
    var accepts2 = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts2[0];
    return first ? types2[mimes.indexOf(first)] : false;
  };
  Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
    var encodings2 = encodings_;
    if (encodings2 && !Array.isArray(encodings2)) {
      encodings2 = new Array(arguments.length);
      for (var i = 0; i < encodings2.length; i++) {
        encodings2[i] = arguments[i];
      }
    }
    if (!encodings2 || encodings2.length === 0) {
      return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings2)[0] || false;
  };
  Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
    var charsets = charsets_;
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i = 0; i < charsets.length; i++) {
        charsets[i] = arguments[i];
      }
    }
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
  };
  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
    var languages = languages_;
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i = 0; i < languages.length; i++) {
        languages[i] = arguments[i];
      }
    }
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
  };
  function extToMime(type2) {
    return type2.indexOf("/") === -1 ? mime.lookup(type2) : type2;
  }
  function validMime(type2) {
    return typeof type2 === "string";
  }
  return accepts;
}
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var fresh_1;
var hasRequiredFresh;
function requireFresh() {
  if (hasRequiredFresh) return fresh_1;
  hasRequiredFresh = 1;
  var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
  fresh_1 = fresh;
  function fresh(reqHeaders, resHeaders) {
    var modifiedSince = reqHeaders["if-modified-since"];
    var noneMatch = reqHeaders["if-none-match"];
    if (!modifiedSince && !noneMatch) {
      return false;
    }
    var cacheControl = reqHeaders["cache-control"];
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
      return false;
    }
    if (noneMatch) {
      if (noneMatch === "*") {
        return true;
      }
      var etag = resHeaders.etag;
      if (!etag) {
        return false;
      }
      var matches = parseTokenList(noneMatch);
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        if (match === etag || match === "W/" + etag || "W/" + match === etag) {
          return true;
        }
      }
      return false;
    }
    if (modifiedSince) {
      var lastModified = resHeaders["last-modified"];
      var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
      if (modifiedStale) {
        return false;
      }
    }
    return true;
  }
  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(str.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(str.substring(start, end));
    return list;
  }
  return fresh_1;
}
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var rangeParser_1;
var hasRequiredRangeParser;
function requireRangeParser() {
  if (hasRequiredRangeParser) return rangeParser_1;
  hasRequiredRangeParser = 1;
  rangeParser_1 = rangeParser;
  function rangeParser(size, str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var index = str.indexOf("=");
    if (index === -1) {
      return -2;
    }
    var arr = str.slice(index + 1).split(",");
    var ranges = [];
    ranges.type = str.slice(0, index);
    for (var i = 0; i < arr.length; i++) {
      var range2 = arr[i].split("-");
      var start = parseInt(range2[0], 10);
      var end = parseInt(range2[1], 10);
      if (isNaN(start)) {
        start = size - end;
        end = size - 1;
      } else if (isNaN(end)) {
        end = size - 1;
      }
      if (end > size - 1) {
        end = size - 1;
      }
      if (isNaN(start) || isNaN(end) || start > end || start < 0) {
        continue;
      }
      ranges.push({
        start,
        end
      });
    }
    if (ranges.length < 1) {
      return -1;
    }
    return options && options.combine ? combineRanges(ranges) : ranges;
  }
  function combineRanges(ranges) {
    var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
    for (var j = 0, i = 1; i < ordered.length; i++) {
      var range2 = ordered[i];
      var current = ordered[j];
      if (range2.start > current.end + 1) {
        ordered[++j] = range2;
      } else if (range2.end > current.end) {
        current.end = range2.end;
        current.index = Math.min(current.index, range2.index);
      }
    }
    ordered.length = j + 1;
    var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
    combined.type = ranges.type;
    return combined;
  }
  function mapWithIndex(range2, index) {
    return {
      start: range2.start,
      end: range2.end,
      index
    };
  }
  function mapWithoutIndex(range2) {
    return {
      start: range2.start,
      end: range2.end
    };
  }
  function sortByRangeIndex(a, b) {
    return a.index - b.index;
  }
  function sortByRangeStart(a, b) {
    return a.start - b.start;
  }
  return rangeParser_1;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var request;
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request;
  hasRequiredRequest = 1;
  var accepts2 = requireAccepts();
  var isIP = require$$1$5.isIP;
  var typeis = requireTypeIs();
  var http = require$$2$3;
  var fresh = requireFresh();
  var parseRange = requireRangeParser();
  var parse3 = requireParseurl();
  var proxyaddr = requireProxyAddr();
  var req = Object.create(http.IncomingMessage.prototype);
  request = req;
  req.get = req.header = function header(name) {
    if (!name) {
      throw new TypeError("name argument is required to req.get");
    }
    if (typeof name !== "string") {
      throw new TypeError("name must be a string to req.get");
    }
    var lc = name.toLowerCase();
    switch (lc) {
      case "referer":
      case "referrer":
        return this.headers.referrer || this.headers.referer;
      default:
        return this.headers[lc];
    }
  };
  req.accepts = function() {
    var accept = accepts2(this);
    return accept.types.apply(accept, arguments);
  };
  req.acceptsEncodings = function() {
    var accept = accepts2(this);
    return accept.encodings.apply(accept, arguments);
  };
  req.acceptsCharsets = function() {
    var accept = accepts2(this);
    return accept.charsets.apply(accept, arguments);
  };
  req.acceptsLanguages = function() {
    var accept = accepts2(this);
    return accept.languages.apply(accept, arguments);
  };
  req.range = function range2(size, options) {
    var range3 = this.get("Range");
    if (!range3) return;
    return parseRange(size, range3, options);
  };
  defineGetter(req, "query", function query() {
    var queryparse = this.app.get("query parser fn");
    if (!queryparse) {
      return /* @__PURE__ */ Object.create(null);
    }
    var querystring = parse3(this).query;
    return queryparse(querystring);
  });
  req.is = function is2(types2) {
    var arr = types2;
    if (!Array.isArray(types2)) {
      arr = new Array(arguments.length);
      for (var i = 0; i < arr.length; i++) {
        arr[i] = arguments[i];
      }
    }
    return typeis(this, arr);
  };
  defineGetter(req, "protocol", function protocol() {
    var proto = this.connection.encrypted ? "https" : "http";
    var trust = this.app.get("trust proxy fn");
    if (!trust(this.connection.remoteAddress, 0)) {
      return proto;
    }
    var header = this.get("X-Forwarded-Proto") || proto;
    var index = header.indexOf(",");
    return index !== -1 ? header.substring(0, index).trim() : header.trim();
  });
  defineGetter(req, "secure", function secure() {
    return this.protocol === "https";
  });
  defineGetter(req, "ip", function ip() {
    var trust = this.app.get("trust proxy fn");
    return proxyaddr(this, trust);
  });
  defineGetter(req, "ips", function ips() {
    var trust = this.app.get("trust proxy fn");
    var addrs = proxyaddr.all(this, trust);
    addrs.reverse().pop();
    return addrs;
  });
  defineGetter(req, "subdomains", function subdomains() {
    var hostname = this.hostname;
    if (!hostname) return [];
    var offset = this.app.get("subdomain offset");
    var subdomains2 = !isIP(hostname) ? hostname.split(".").reverse() : [hostname];
    return subdomains2.slice(offset);
  });
  defineGetter(req, "path", function path2() {
    return parse3(this).pathname;
  });
  defineGetter(req, "host", function host() {
    var trust = this.app.get("trust proxy fn");
    var val = this.get("X-Forwarded-Host");
    if (!val || !trust(this.connection.remoteAddress, 0)) {
      val = this.get("Host");
    } else if (val.indexOf(",") !== -1) {
      val = val.substring(0, val.indexOf(",")).trimRight();
    }
    return val || void 0;
  });
  defineGetter(req, "hostname", function hostname() {
    var host = this.host;
    if (!host) return;
    var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
    var index = host.indexOf(":", offset);
    return index !== -1 ? host.substring(0, index) : host;
  });
  defineGetter(req, "fresh", function() {
    var method = this.method;
    var res = this.res;
    var status = res.statusCode;
    if ("GET" !== method && "HEAD" !== method) return false;
    if (status >= 200 && status < 300 || 304 === status) {
      return fresh(this.headers, {
        "etag": res.get("ETag"),
        "last-modified": res.get("Last-Modified")
      });
    }
    return false;
  });
  defineGetter(req, "stale", function stale() {
    return !this.fresh;
  });
  defineGetter(req, "xhr", function xhr() {
    var val = this.get("X-Requested-With") || "";
    return val.toLowerCase() === "xmlhttprequest";
  });
  function defineGetter(obj, name, getter) {
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable: true,
      get: getter
    });
  }
  return request;
}
var contentDisposition = { exports: {} };
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer2 = require$$0$7;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding2 === "string") {
          buf.fill(fill, encoding2);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredContentDisposition;
function requireContentDisposition() {
  if (hasRequiredContentDisposition) return contentDisposition.exports;
  hasRequiredContentDisposition = 1;
  contentDisposition.exports = contentDisposition$1;
  contentDisposition.exports.parse = parse3;
  var basename = require$$1$2.basename;
  var Buffer2 = requireSafeBuffer().Buffer;
  var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
  var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
  var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
  var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
  var QESC_REGEXP = /\\([\u0000-\u007f])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
  var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
  var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
  var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
  function contentDisposition$1(filename, options) {
    var opts = options || {};
    var type2 = opts.type || "attachment";
    var params = createparams(filename, opts.fallback);
    return format(new ContentDisposition(type2, params));
  }
  function createparams(filename, fallback) {
    if (filename === void 0) {
      return;
    }
    var params = {};
    if (typeof filename !== "string") {
      throw new TypeError("filename must be a string");
    }
    if (fallback === void 0) {
      fallback = true;
    }
    if (typeof fallback !== "string" && typeof fallback !== "boolean") {
      throw new TypeError("fallback must be a string or boolean");
    }
    if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
      throw new TypeError("fallback must be ISO-8859-1 string");
    }
    var name = basename(filename);
    var isQuotedString = TEXT_REGEXP.test(name);
    var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
    var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
      params["filename*"] = name;
    }
    if (isQuotedString || hasFallback) {
      params.filename = hasFallback ? fallbackName : name;
    }
    return params;
  }
  function format(obj) {
    var parameters = obj.parameters;
    var type2 = obj.type;
    if (!type2 || typeof type2 !== "string" || !TOKEN_REGEXP.test(type2)) {
      throw new TypeError("invalid type");
    }
    var string = String(type2).toLowerCase();
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        var val = param.slice(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
        string += "; " + param + "=" + val;
      }
    }
    return string;
  }
  function decodefield(str) {
    var match = EXT_VALUE_REGEXP.exec(str);
    if (!match) {
      throw new TypeError("invalid extended field value");
    }
    var charset2 = match[1].toLowerCase();
    var encoded = match[2];
    var value;
    var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
    switch (charset2) {
      case "iso-8859-1":
        value = getlatin1(binary);
        break;
      case "utf-8":
      case "utf8":
        value = Buffer2.from(binary, "binary").toString("utf8");
        break;
      default:
        throw new TypeError("unsupported charset in extended field");
    }
    return value;
  }
  function getlatin1(val) {
    return String(val).replace(NON_LATIN1_REGEXP, "?");
  }
  function parse3(string) {
    if (!string || typeof string !== "string") {
      throw new TypeError("argument string is required");
    }
    var match = DISPOSITION_TYPE_REGEXP.exec(string);
    if (!match) {
      throw new TypeError("invalid type format");
    }
    var index = match[0].length;
    var type2 = match[1].toLowerCase();
    var key2;
    var names = [];
    var params = {};
    var value;
    index = PARAM_REGEXP.lastIndex = match[0].slice(-1) === ";" ? index - 1 : index;
    while (match = PARAM_REGEXP.exec(string)) {
      if (match.index !== index) {
        throw new TypeError("invalid parameter format");
      }
      index += match[0].length;
      key2 = match[1].toLowerCase();
      value = match[2];
      if (names.indexOf(key2) !== -1) {
        throw new TypeError("invalid duplicate parameter");
      }
      names.push(key2);
      if (key2.indexOf("*") + 1 === key2.length) {
        key2 = key2.slice(0, -1);
        value = decodefield(value);
        params[key2] = value;
        continue;
      }
      if (typeof params[key2] === "string") {
        continue;
      }
      if (value[0] === '"') {
        value = value.slice(1, -1).replace(QESC_REGEXP, "$1");
      }
      params[key2] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError("invalid parameter format");
    }
    return new ContentDisposition(type2, params);
  }
  function pdecode(str, hex) {
    return String.fromCharCode(parseInt(hex, 16));
  }
  function pencode(char) {
    return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
  }
  function qstring(val) {
    var str = String(val);
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ustring(val) {
    var str = String(val);
    var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return "UTF-8''" + encoded;
  }
  function ContentDisposition(type2, parameters) {
    this.type = type2;
    this.parameters = parameters;
  }
  return contentDisposition.exports;
}
var cookieSignature = {};
var hasRequiredCookieSignature;
function requireCookieSignature() {
  if (hasRequiredCookieSignature) return cookieSignature;
  hasRequiredCookieSignature = 1;
  (function(exports) {
    var crypto2 = require$$0$a;
    exports.sign = function(val, secret) {
      if ("string" != typeof val) throw new TypeError("Cookie value must be provided as a string.");
      if (null == secret) throw new TypeError("Secret key must be provided.");
      return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
    };
    exports.unsign = function(input, secret) {
      if ("string" != typeof input) throw new TypeError("Signed cookie string must be provided.");
      if (null == secret) throw new TypeError("Secret key must be provided.");
      var tentativeValue = input.slice(0, input.lastIndexOf(".")), expectedInput = exports.sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
      return expectedBuffer.length === inputBuffer.length && crypto2.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : false;
    };
  })(cookieSignature);
  return cookieSignature;
}
var cookie = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredCookie;
function requireCookie() {
  if (hasRequiredCookie) return cookie;
  hasRequiredCookie = 1;
  cookie.parse = parse3;
  cookie.serialize = serialize;
  var __toString = Object.prototype.toString;
  var __hasOwnProperty = Object.prototype.hasOwnProperty;
  var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  function parse3(str, opt) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var len = str.length;
    if (len < 2) return obj;
    var dec = opt && opt.decode || decode2;
    var index = 0;
    var eqIdx = 0;
    var endIdx = 0;
    do {
      eqIdx = str.indexOf("=", index);
      if (eqIdx === -1) break;
      endIdx = str.indexOf(";", index);
      if (endIdx === -1) {
        endIdx = len;
      } else if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var keyStartIdx = startIndex(str, index, eqIdx);
      var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      var key2 = str.slice(keyStartIdx, keyEndIdx);
      if (!__hasOwnProperty.call(obj, key2)) {
        var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        var valEndIdx = endIndex(str, endIdx, valStartIdx);
        if (str.charCodeAt(valStartIdx) === 34 && str.charCodeAt(valEndIdx - 1) === 34) {
          valStartIdx++;
          valEndIdx--;
        }
        var val = str.slice(valStartIdx, valEndIdx);
        obj[key2] = tryDecode(val, dec);
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max2) {
    do {
      var code = str.charCodeAt(index);
      if (code !== 32 && code !== 9) return index;
    } while (++index < max2);
    return max2;
  }
  function endIndex(str, index, min2) {
    while (index > min2) {
      var code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9) return index + 1;
    }
    return min2;
  }
  function serialize(name, val, opt) {
    var enc = opt && opt.encode || encodeURIComponent;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (!opt) return str;
    if (null != opt.maxAge) {
      var maxAge = Math.floor(opt.maxAge);
      if (!isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + maxAge;
    }
    if (opt.domain) {
      if (!domainValueRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!pathValueRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.partitioned) {
      str += "; Partitioned";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function decode2(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
  function tryDecode(str, decode3) {
    try {
      return decode3(str);
    } catch (e) {
      return str;
    }
  }
  return cookie;
}
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var send_1;
var hasRequiredSend;
function requireSend() {
  if (hasRequiredSend) return send_1;
  hasRequiredSend = 1;
  var createError = requireHttpErrors();
  var debug = require$$0$8("send");
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var etag = requireEtag();
  var fresh = requireFresh();
  var fs2 = fs$1;
  var mime = requireMimeTypes();
  var ms = require$$8;
  var onFinished2 = requireOnFinished();
  var parseRange = requireRangeParser();
  var path2 = require$$1$2;
  var statuses2 = requireStatuses();
  var Stream = require$$2$1;
  var util2 = require$$1$3;
  var extname = path2.extname;
  var join = path2.join;
  var normalize = path2.normalize;
  var resolve2 = path2.resolve;
  var sep = path2.sep;
  var BYTES_RANGE_REGEXP = /^ *bytes=/;
  var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
  var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
  send_1 = send;
  function send(req, path3, options) {
    return new SendStream(req, path3, options);
  }
  function SendStream(req, path3, options) {
    Stream.call(this);
    var opts = options || {};
    this.options = opts;
    this.path = path3;
    this.req = req;
    this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
    this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
    this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
    this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
    if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
      throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
    }
    this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
    this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
    this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
    this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
    this._maxage = opts.maxAge || opts.maxage;
    this._maxage = typeof this._maxage === "string" ? ms(this._maxage) : Number(this._maxage);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    this._root = opts.root ? resolve2(opts.root) : null;
  }
  util2.inherits(SendStream, Stream);
  SendStream.prototype.error = function error(status, err) {
    if (hasListeners(this, "error")) {
      return this.emit("error", createHttpError(status, err));
    }
    var res = this.res;
    var msg = statuses2.message[status] || String(status);
    var doc = createHtmlDocument("Error", escapeHtml(msg));
    clearHeaders(res);
    if (err && err.headers) {
      setHeaders(res, err.headers);
    }
    res.statusCode = status;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.end(doc);
  };
  SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
    return this.path[this.path.length - 1] === "/";
  };
  SendStream.prototype.isConditionalGET = function isConditionalGET() {
    return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
  };
  SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
    var req = this.req;
    var res = this.res;
    var match = req.headers["if-match"];
    if (match) {
      var etag2 = res.getHeader("ETag");
      return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
        return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
      });
    }
    var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
    if (!isNaN(unmodifiedSince)) {
      var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
      return isNaN(lastModified) || lastModified > unmodifiedSince;
    }
    return false;
  };
  SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
    var res = this.res;
    res.removeHeader("Content-Encoding");
    res.removeHeader("Content-Language");
    res.removeHeader("Content-Length");
    res.removeHeader("Content-Range");
    res.removeHeader("Content-Type");
  };
  SendStream.prototype.notModified = function notModified() {
    var res = this.res;
    debug("not modified");
    this.removeContentHeaderFields();
    res.statusCode = 304;
    res.end();
  };
  SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
    var err = new Error("Can't set headers after they are sent.");
    debug("headers already sent");
    this.error(500, err);
  };
  SendStream.prototype.isCachable = function isCachable() {
    var statusCode = this.res.statusCode;
    return statusCode >= 200 && statusCode < 300 || statusCode === 304;
  };
  SendStream.prototype.onStatError = function onStatError(error) {
    switch (error.code) {
      case "ENAMETOOLONG":
      case "ENOENT":
      case "ENOTDIR":
        this.error(404, error);
        break;
      default:
        this.error(500, error);
        break;
    }
  };
  SendStream.prototype.isFresh = function isFresh() {
    return fresh(this.req.headers, {
      etag: this.res.getHeader("ETag"),
      "last-modified": this.res.getHeader("Last-Modified")
    });
  };
  SendStream.prototype.isRangeFresh = function isRangeFresh() {
    var ifRange = this.req.headers["if-range"];
    if (!ifRange) {
      return true;
    }
    if (ifRange.indexOf('"') !== -1) {
      var etag2 = this.res.getHeader("ETag");
      return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
    }
    var lastModified = this.res.getHeader("Last-Modified");
    return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
  };
  SendStream.prototype.redirect = function redirect(path3) {
    var res = this.res;
    if (hasListeners(this, "directory")) {
      this.emit("directory", res, path3);
      return;
    }
    if (this.hasTrailingSlash()) {
      this.error(403);
      return;
    }
    var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
    var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
    res.statusCode = 301;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Location", loc);
    res.end(doc);
  };
  SendStream.prototype.pipe = function pipe(res) {
    var root2 = this._root;
    this.res = res;
    var path3 = decode2(this.path);
    if (path3 === -1) {
      this.error(400);
      return res;
    }
    if (~path3.indexOf("\0")) {
      this.error(400);
      return res;
    }
    var parts;
    if (root2 !== null) {
      if (path3) {
        path3 = normalize("." + sep + path3);
      }
      if (UP_PATH_REGEXP.test(path3)) {
        debug('malicious path "%s"', path3);
        this.error(403);
        return res;
      }
      parts = path3.split(sep);
      path3 = normalize(join(root2, path3));
    } else {
      if (UP_PATH_REGEXP.test(path3)) {
        debug('malicious path "%s"', path3);
        this.error(403);
        return res;
      }
      parts = normalize(path3).split(sep);
      path3 = resolve2(path3);
    }
    if (containsDotFile(parts)) {
      debug('%s dotfile "%s"', this._dotfiles, path3);
      switch (this._dotfiles) {
        case "allow":
          break;
        case "deny":
          this.error(403);
          return res;
        case "ignore":
        default:
          this.error(404);
          return res;
      }
    }
    if (this._index.length && this.hasTrailingSlash()) {
      this.sendIndex(path3);
      return res;
    }
    this.sendFile(path3);
    return res;
  };
  SendStream.prototype.send = function send2(path3, stat2) {
    var len = stat2.size;
    var options = this.options;
    var opts = {};
    var res = this.res;
    var req = this.req;
    var ranges = req.headers.range;
    var offset = options.start || 0;
    if (res.headersSent) {
      this.headersAlreadySent();
      return;
    }
    debug('pipe "%s"', path3);
    this.setHeader(path3, stat2);
    this.type(path3);
    if (this.isConditionalGET()) {
      if (this.isPreconditionFailure()) {
        this.error(412);
        return;
      }
      if (this.isCachable() && this.isFresh()) {
        this.notModified();
        return;
      }
    }
    len = Math.max(0, len - offset);
    if (options.end !== void 0) {
      var bytes2 = options.end - offset + 1;
      if (len > bytes2) len = bytes2;
    }
    if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
      ranges = parseRange(len, ranges, {
        combine: true
      });
      if (!this.isRangeFresh()) {
        debug("range stale");
        ranges = -2;
      }
      if (ranges === -1) {
        debug("range unsatisfiable");
        res.setHeader("Content-Range", contentRange("bytes", len));
        return this.error(416, {
          headers: { "Content-Range": res.getHeader("Content-Range") }
        });
      }
      if (ranges !== -2 && ranges.length === 1) {
        debug("range %j", ranges);
        res.statusCode = 206;
        res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
        offset += ranges[0].start;
        len = ranges[0].end - ranges[0].start + 1;
      }
    }
    for (var prop in options) {
      opts[prop] = options[prop];
    }
    opts.start = offset;
    opts.end = Math.max(offset, offset + len - 1);
    res.setHeader("Content-Length", len);
    if (req.method === "HEAD") {
      res.end();
      return;
    }
    this.stream(path3, opts);
  };
  SendStream.prototype.sendFile = function sendFile(path3) {
    var i = 0;
    var self2 = this;
    debug('stat "%s"', path3);
    fs2.stat(path3, function onstat(err, stat2) {
      var pathEndsWithSep = path3[path3.length - 1] === sep;
      if (err && err.code === "ENOENT" && !extname(path3) && !pathEndsWithSep) {
        return next(err);
      }
      if (err) return self2.onStatError(err);
      if (stat2.isDirectory()) return self2.redirect(path3);
      if (pathEndsWithSep) return self2.error(404);
      self2.emit("file", path3, stat2);
      self2.send(path3, stat2);
    });
    function next(err) {
      if (self2._extensions.length <= i) {
        return err ? self2.onStatError(err) : self2.error(404);
      }
      var p = path3 + "." + self2._extensions[i++];
      debug('stat "%s"', p);
      fs2.stat(p, function(err2, stat2) {
        if (err2) return next(err2);
        if (stat2.isDirectory()) return next();
        self2.emit("file", p, stat2);
        self2.send(p, stat2);
      });
    }
  };
  SendStream.prototype.sendIndex = function sendIndex(path3) {
    var i = -1;
    var self2 = this;
    function next(err) {
      if (++i >= self2._index.length) {
        if (err) return self2.onStatError(err);
        return self2.error(404);
      }
      var p = join(path3, self2._index[i]);
      debug('stat "%s"', p);
      fs2.stat(p, function(err2, stat2) {
        if (err2) return next(err2);
        if (stat2.isDirectory()) return next();
        self2.emit("file", p, stat2);
        self2.send(p, stat2);
      });
    }
    next();
  };
  SendStream.prototype.stream = function stream(path3, options) {
    var self2 = this;
    var res = this.res;
    var stream2 = fs2.createReadStream(path3, options);
    this.emit("stream", stream2);
    stream2.pipe(res);
    function cleanup() {
      stream2.destroy();
    }
    onFinished2(res, cleanup);
    stream2.on("error", function onerror(err) {
      cleanup();
      self2.onStatError(err);
    });
    stream2.on("end", function onend() {
      self2.emit("end");
    });
  };
  SendStream.prototype.type = function type2(path3) {
    var res = this.res;
    if (res.getHeader("Content-Type")) return;
    var ext = extname(path3);
    var type3 = mime.contentType(ext) || "application/octet-stream";
    debug("content-type %s", type3);
    res.setHeader("Content-Type", type3);
  };
  SendStream.prototype.setHeader = function setHeader(path3, stat2) {
    var res = this.res;
    this.emit("headers", res, path3, stat2);
    if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
      debug("accept ranges");
      res.setHeader("Accept-Ranges", "bytes");
    }
    if (this._cacheControl && !res.getHeader("Cache-Control")) {
      var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
      if (this._immutable) {
        cacheControl += ", immutable";
      }
      debug("cache-control %s", cacheControl);
      res.setHeader("Cache-Control", cacheControl);
    }
    if (this._lastModified && !res.getHeader("Last-Modified")) {
      var modified = stat2.mtime.toUTCString();
      debug("modified %s", modified);
      res.setHeader("Last-Modified", modified);
    }
    if (this._etag && !res.getHeader("ETag")) {
      var val = etag(stat2);
      debug("etag %s", val);
      res.setHeader("ETag", val);
    }
  };
  function clearHeaders(res) {
    for (const header of res.getHeaderNames()) {
      res.removeHeader(header);
    }
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0; i < str.length; i++) {
      if (str[i] !== "/") {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function containsDotFile(parts) {
    for (var i = 0; i < parts.length; i++) {
      var part = parts[i];
      if (part.length > 1 && part[0] === ".") {
        return true;
      }
    }
    return false;
  }
  function contentRange(type2, size, range2) {
    return type2 + " " + (range2 ? range2.start + "-" + range2.end : "*") + "/" + size;
  }
  function createHtmlDocument(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createHttpError(status, err) {
    if (!err) {
      return createError(status);
    }
    return err instanceof Error ? createError(status, err, { expose: false }) : createError(status, err);
  }
  function decode2(path3) {
    try {
      return decodeURIComponent(path3);
    } catch (err) {
      return -1;
    }
  }
  function hasListeners(emitter, type2) {
    var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type2).length : emitter.listenerCount(type2);
    return count > 0;
  }
  function normalizeList(val, name) {
    var list = [].concat(val || []);
    for (var i = 0; i < list.length; i++) {
      if (typeof list[i] !== "string") {
        throw new TypeError(name + " must be array of strings or false");
      }
    }
    return list;
  }
  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(str.substring(start, end));
          }
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    if (start !== end) {
      list.push(str.substring(start, end));
    }
    return list;
  }
  function setHeaders(res, headers) {
    var keys = Object.keys(headers);
    for (var i = 0; i < keys.length; i++) {
      var key2 = keys[i];
      res.setHeader(key2, headers[key2]);
    }
  }
  return send_1;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var response;
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse) return response;
  hasRequiredResponse = 1;
  var contentDisposition2 = requireContentDisposition();
  var createError = requireHttpErrors();
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var http = require$$2$3;
  var onFinished2 = requireOnFinished();
  var mime = requireMimeTypes();
  var path2 = path__default;
  var pathIsAbsolute = path__default.isAbsolute;
  var statuses2 = requireStatuses();
  var sign2 = requireCookieSignature().sign;
  var normalizeType = requireUtils().normalizeType;
  var normalizeTypes = requireUtils().normalizeTypes;
  var setCharset = requireUtils().setCharset;
  var cookie2 = requireCookie();
  var send = requireSend();
  var extname = path2.extname;
  var resolve2 = path2.resolve;
  var vary2 = requireVary();
  var res = Object.create(http.ServerResponse.prototype);
  response = res;
  res.status = function status(code) {
    if (!Number.isInteger(code)) {
      throw new TypeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be an integer.`);
    }
    if (code < 100 || code > 999) {
      throw new RangeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be greater than 99 and less than 1000.`);
    }
    this.statusCode = code;
    return this;
  };
  res.links = function(links) {
    var link = this.get("Link") || "";
    if (link) link += ", ";
    return this.set("Link", link + Object.keys(links).map(function(rel) {
      if (Array.isArray(links[rel])) {
        return links[rel].map(function(singleLink) {
          return `<${singleLink}>; rel="${rel}"`;
        }).join(", ");
      } else {
        return `<${links[rel]}>; rel="${rel}"`;
      }
    }).join(", "));
  };
  res.send = function send2(body) {
    var chunk = body;
    var encoding2;
    var req = this.req;
    var type2;
    var app = this.app;
    switch (typeof chunk) {
      // string defaulting to html
      case "string":
        if (!this.get("Content-Type")) {
          this.type("html");
        }
        break;
      case "boolean":
      case "number":
      case "object":
        if (chunk === null) {
          chunk = "";
        } else if (ArrayBuffer.isView(chunk)) {
          if (!this.get("Content-Type")) {
            this.type("bin");
          }
        } else {
          return this.json(chunk);
        }
        break;
    }
    if (typeof chunk === "string") {
      encoding2 = "utf8";
      type2 = this.get("Content-Type");
      if (typeof type2 === "string") {
        this.set("Content-Type", setCharset(type2, "utf-8"));
      }
    }
    var etagFn = app.get("etag fn");
    var generateETag = !this.get("ETag") && typeof etagFn === "function";
    var len;
    if (chunk !== void 0) {
      if (Buffer.isBuffer(chunk)) {
        len = chunk.length;
      } else if (!generateETag && chunk.length < 1e3) {
        len = Buffer.byteLength(chunk, encoding2);
      } else {
        chunk = Buffer.from(chunk, encoding2);
        encoding2 = void 0;
        len = chunk.length;
      }
      this.set("Content-Length", len);
    }
    var etag;
    if (generateETag && len !== void 0) {
      if (etag = etagFn(chunk, encoding2)) {
        this.set("ETag", etag);
      }
    }
    if (req.fresh) this.status(304);
    if (204 === this.statusCode || 304 === this.statusCode) {
      this.removeHeader("Content-Type");
      this.removeHeader("Content-Length");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (this.statusCode === 205) {
      this.set("Content-Length", "0");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (req.method === "HEAD") {
      this.end();
    } else {
      this.end(chunk, encoding2);
    }
    return this;
  };
  res.json = function json(obj) {
    var app = this.app;
    var escape2 = app.get("json escape");
    var replacer = app.get("json replacer");
    var spaces = app.get("json spaces");
    var body = stringify3(obj, replacer, spaces, escape2);
    if (!this.get("Content-Type")) {
      this.set("Content-Type", "application/json");
    }
    return this.send(body);
  };
  res.jsonp = function jsonp(obj) {
    var app = this.app;
    var escape2 = app.get("json escape");
    var replacer = app.get("json replacer");
    var spaces = app.get("json spaces");
    var body = stringify3(obj, replacer, spaces, escape2);
    var callback = this.req.query[app.get("jsonp callback name")];
    if (!this.get("Content-Type")) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "application/json");
    }
    if (Array.isArray(callback)) {
      callback = callback[0];
    }
    if (typeof callback === "string" && callback.length !== 0) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "text/javascript");
      callback = callback.replace(/[^\[\]\w$.]/g, "");
      if (body === void 0) {
        body = "";
      } else if (typeof body === "string") {
        body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
    }
    return this.send(body);
  };
  res.sendStatus = function sendStatus(statusCode) {
    var body = statuses2.message[statusCode] || String(statusCode);
    this.status(statusCode);
    this.type("txt");
    return this.send(body);
  };
  res.sendFile = function sendFile(path3, options, callback) {
    var done = callback;
    var req = this.req;
    var res2 = this;
    var next = req.next;
    var opts = options || {};
    if (!path3) {
      throw new TypeError("path argument is required to res.sendFile");
    }
    if (typeof path3 !== "string") {
      throw new TypeError("path must be a string to res.sendFile");
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (!opts.root && !pathIsAbsolute(path3)) {
      throw new TypeError("path must be absolute or specify root to res.sendFile");
    }
    var pathname = encodeURI(path3);
    opts.etag = this.app.enabled("etag");
    var file = send(req, pathname, opts);
    sendfile(res2, file, opts, function(err) {
      if (done) return done(err);
      if (err && err.code === "EISDIR") return next();
      if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
        next(err);
      }
    });
  };
  res.download = function download(path3, filename, options, callback) {
    var done = callback;
    var name = filename;
    var opts = options || null;
    if (typeof filename === "function") {
      done = filename;
      name = null;
      opts = null;
    } else if (typeof options === "function") {
      done = options;
      opts = null;
    }
    if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
      name = null;
      opts = filename;
    }
    var headers = {
      "Content-Disposition": contentDisposition2(name || path3)
    };
    if (opts && opts.headers) {
      var keys = Object.keys(opts.headers);
      for (var i = 0; i < keys.length; i++) {
        var key2 = keys[i];
        if (key2.toLowerCase() !== "content-disposition") {
          headers[key2] = opts.headers[key2];
        }
      }
    }
    opts = Object.create(opts);
    opts.headers = headers;
    var fullPath = !opts.root ? resolve2(path3) : path3;
    return this.sendFile(fullPath, opts, done);
  };
  res.contentType = res.type = function contentType2(type2) {
    var ct = type2.indexOf("/") === -1 ? mime.contentType(type2) || "application/octet-stream" : type2;
    return this.set("Content-Type", ct);
  };
  res.format = function(obj) {
    var req = this.req;
    var next = req.next;
    var keys = Object.keys(obj).filter(function(v) {
      return v !== "default";
    });
    var key2 = keys.length > 0 ? req.accepts(keys) : false;
    this.vary("Accept");
    if (key2) {
      this.set("Content-Type", normalizeType(key2).value);
      obj[key2](req, this, next);
    } else if (obj.default) {
      obj.default(req, this, next);
    } else {
      next(createError(406, {
        types: normalizeTypes(keys).map(function(o) {
          return o.value;
        })
      }));
    }
    return this;
  };
  res.attachment = function attachment(filename) {
    if (filename) {
      this.type(extname(filename));
    }
    this.set("Content-Disposition", contentDisposition2(filename));
    return this;
  };
  res.append = function append(field, val) {
    var prev = this.get(field);
    var value = val;
    if (prev) {
      value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
    }
    return this.set(field, value);
  };
  res.set = res.header = function header(field, val) {
    if (arguments.length === 2) {
      var value = Array.isArray(val) ? val.map(String) : String(val);
      if (field.toLowerCase() === "content-type") {
        if (Array.isArray(value)) {
          throw new TypeError("Content-Type cannot be set to an Array");
        }
        value = mime.contentType(value);
      }
      this.setHeader(field, value);
    } else {
      for (var key2 in field) {
        this.set(key2, field[key2]);
      }
    }
    return this;
  };
  res.get = function(field) {
    return this.getHeader(field);
  };
  res.clearCookie = function clearCookie(name, options) {
    const opts = { path: "/", ...options, expires: /* @__PURE__ */ new Date(1) };
    delete opts.maxAge;
    return this.cookie(name, "", opts);
  };
  res.cookie = function(name, value, options) {
    var opts = { ...options };
    var secret = this.req.secret;
    var signed = opts.signed;
    if (signed && !secret) {
      throw new Error('cookieParser("secret") required for signed cookies');
    }
    var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
    if (signed) {
      val = "s:" + sign2(val, secret);
    }
    if (opts.maxAge != null) {
      var maxAge = opts.maxAge - 0;
      if (!isNaN(maxAge)) {
        opts.expires = new Date(Date.now() + maxAge);
        opts.maxAge = Math.floor(maxAge / 1e3);
      }
    }
    if (opts.path == null) {
      opts.path = "/";
    }
    this.append("Set-Cookie", cookie2.serialize(name, String(val), opts));
    return this;
  };
  res.location = function location(url) {
    return this.set("Location", encodeUrl(url));
  };
  res.redirect = function redirect(url) {
    var address = url;
    var body;
    var status = 302;
    if (arguments.length === 2) {
      status = arguments[0];
      address = arguments[1];
    }
    address = this.location(address).get("Location");
    this.format({
      text: function() {
        body = statuses2.message[status] + ". Redirecting to " + address;
      },
      html: function() {
        var u = escapeHtml(address);
        body = "<p>" + statuses2.message[status] + ". Redirecting to " + u + "</p>";
      },
      default: function() {
        body = "";
      }
    });
    this.status(status);
    this.set("Content-Length", Buffer.byteLength(body));
    if (this.req.method === "HEAD") {
      this.end();
    } else {
      this.end(body);
    }
  };
  res.vary = function(field) {
    vary2(this, field);
    return this;
  };
  res.render = function render(view2, options, callback) {
    var app = this.req.app;
    var done = callback;
    var opts = options || {};
    var req = this.req;
    var self2 = this;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    opts._locals = self2.locals;
    done = done || function(err, str) {
      if (err) return req.next(err);
      self2.send(str);
    };
    app.render(view2, opts, done);
  };
  function sendfile(res2, file, options, callback) {
    var done = false;
    var streaming;
    function onaborted() {
      if (done) return;
      done = true;
      var err = new Error("Request aborted");
      err.code = "ECONNABORTED";
      callback(err);
    }
    function ondirectory() {
      if (done) return;
      done = true;
      var err = new Error("EISDIR, read");
      err.code = "EISDIR";
      callback(err);
    }
    function onerror(err) {
      if (done) return;
      done = true;
      callback(err);
    }
    function onend() {
      if (done) return;
      done = true;
      callback();
    }
    function onfile() {
      streaming = false;
    }
    function onfinish(err) {
      if (err && err.code === "ECONNRESET") return onaborted();
      if (err) return onerror(err);
      if (done) return;
      setImmediate(function() {
        if (streaming !== false && !done) {
          onaborted();
          return;
        }
        if (done) return;
        done = true;
        callback();
      });
    }
    function onstream() {
      streaming = true;
    }
    file.on("directory", ondirectory);
    file.on("end", onend);
    file.on("error", onerror);
    file.on("file", onfile);
    file.on("stream", onstream);
    onFinished2(res2, onfinish);
    if (options.headers) {
      file.on("headers", function headers(res3) {
        var obj = options.headers;
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          res3.setHeader(k, obj[k]);
        }
      });
    }
    file.pipe(res2);
  }
  function stringify3(value, replacer, spaces, escape2) {
    var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
    if (escape2 && typeof json === "string") {
      json = json.replace(/[<>&]/g, function(c2) {
        switch (c2.charCodeAt(0)) {
          case 60:
            return "\\u003c";
          case 62:
            return "\\u003e";
          case 38:
            return "\\u0026";
          /* istanbul ignore next: unreachable default */
          default:
            return c2;
        }
      });
    }
    return json;
  }
  return response;
}
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var serveStatic_1;
var hasRequiredServeStatic;
function requireServeStatic() {
  if (hasRequiredServeStatic) return serveStatic_1;
  hasRequiredServeStatic = 1;
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var parseUrl = requireParseurl();
  var resolve2 = require$$1$2.resolve;
  var send = requireSend();
  var url = require$$0$9;
  serveStatic_1 = serveStatic;
  function serveStatic(root2, options) {
    if (!root2) {
      throw new TypeError("root path required");
    }
    if (typeof root2 !== "string") {
      throw new TypeError("root path must be a string");
    }
    var opts = Object.create(options || null);
    var fallthrough = opts.fallthrough !== false;
    var redirect = opts.redirect !== false;
    var setHeaders = opts.setHeaders;
    if (setHeaders && typeof setHeaders !== "function") {
      throw new TypeError("option setHeaders must be function");
    }
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve2(root2);
    var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic2(req, res, next) {
      if (req.method !== "GET" && req.method !== "HEAD") {
        if (fallthrough) {
          return next();
        }
        res.statusCode = 405;
        res.setHeader("Allow", "GET, HEAD");
        res.setHeader("Content-Length", "0");
        res.end();
        return;
      }
      var forwardError = !fallthrough;
      var originalUrl = parseUrl.original(req);
      var path2 = parseUrl(req).pathname;
      if (path2 === "/" && originalUrl.pathname.substr(-1) !== "/") {
        path2 = "";
      }
      var stream = send(req, path2, opts);
      stream.on("directory", onDirectory);
      if (setHeaders) {
        stream.on("headers", setHeaders);
      }
      if (fallthrough) {
        stream.on("file", function onFile() {
          forwardError = true;
        });
      }
      stream.on("error", function error(err) {
        if (forwardError || !(err.statusCode < 500)) {
          next(err);
          return;
        }
        next();
      });
      stream.pipe(res);
    };
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0; i < str.length; i++) {
      if (str.charCodeAt(i) !== 47) {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function createHtmlDocument(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createNotFoundDirectoryListener() {
    return function notFound() {
      this.error(404);
    };
  }
  function createRedirectDirectoryListener() {
    return function redirect(res) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var originalUrl = parseUrl.original(this.req);
      originalUrl.path = null;
      originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
      var loc = encodeUrl(url.format(originalUrl));
      var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
      res.statusCode = 301;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Location", loc);
      res.end(doc);
    };
  }
  return serveStatic_1;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredExpress$1;
function requireExpress$1() {
  if (hasRequiredExpress$1) return express$2.exports;
  hasRequiredExpress$1 = 1;
  (function(module, exports) {
    var bodyParser2 = requireBodyParser();
    var EventEmitter = require$$1$6.EventEmitter;
    var mixin = /* @__PURE__ */ requireMergeDescriptors();
    var proto = requireApplication();
    var Router = requireRouter();
    var req = requireRequest();
    var res = requireResponse();
    exports = module.exports = createApplication;
    function createApplication() {
      var app = function(req2, res2, next) {
        app.handle(req2, res2, next);
      };
      mixin(app, EventEmitter.prototype, false);
      mixin(app, proto, false);
      app.request = Object.create(req, {
        app: { configurable: true, enumerable: true, writable: true, value: app }
      });
      app.response = Object.create(res, {
        app: { configurable: true, enumerable: true, writable: true, value: app }
      });
      app.init();
      return app;
    }
    exports.application = proto;
    exports.request = req;
    exports.response = res;
    exports.Route = Router.Route;
    exports.Router = Router;
    exports.json = bodyParser2.json;
    exports.raw = bodyParser2.raw;
    exports.static = requireServeStatic();
    exports.text = bodyParser2.text;
    exports.urlencoded = bodyParser2.urlencoded;
  })(express$2, express$2.exports);
  return express$2.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var express$1;
var hasRequiredExpress;
function requireExpress() {
  if (hasRequiredExpress) return express$1;
  hasRequiredExpress = 1;
  express$1 = requireExpress$1();
  return express$1;
}
var expressExports = requireExpress();
const express = /* @__PURE__ */ getDefaultExportFromCjs(expressExports);
const sysface = /* @__PURE__ */ JSON.parse('[{"QSid":"419","QDes":"/","IQLid":"419","AQLid":"419","EMCode":"10419","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"47"},{"QSid":"424","QDes":"/","IQLid":"424","AQLid":"424","EMCode":"10424","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"52"},{"QSid":"425","QDes":"/","IQLid":"425","AQLid":"425","EMCode":"10425","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"53"},{"QSid":"426","QDes":"/","IQLid":"426","AQLid":"426","EMCode":"10426","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"54"},{"QSid":"427","QDes":"/","IQLid":"427","AQLid":"427","EMCode":"10427","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"55"},{"QSid":"428","QDes":"/","IQLid":"428","AQLid":"428","EMCode":"10428"},{"QSid":"429","QDes":"/","IQLid":"429","AQLid":"429","EMCode":"10429","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"56"},{"QSid":"364","QDes":"/","IQLid":"364","AQLid":"364","EMCode":"10364","QHide":"1","AniStickerType":1,"AniStickerId":"1","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"366","QDes":"/","IQLid":"366","AQLid":"366","EMCode":"10366","QHide":"1","AniStickerType":1,"AniStickerId":"2","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"362","QDes":"/","IQLid":"362","AQLid":"362","EMCode":"10362","QHide":"1","AniStickerType":1,"AniStickerId":"3","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"397","QDes":"/","IQLid":"397","AQLid":"397","EMCode":"10397","QHide":"1","AniStickerType":1,"AniStickerId":"4","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"396","QDes":"/","IQLid":"396","AQLid":"396","EMCode":"10396","QHide":"1","AniStickerType":1,"AniStickerId":"5","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"360","QDes":"/","IQLid":"360","AQLid":"360","EMCode":"10360","QHide":"1","AniStickerType":1,"AniStickerId":"6","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"361","QDes":"/","IQLid":"361","AQLid":"361","EMCode":"10361","QHide":"1","AniStickerType":1,"AniStickerId":"7","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"363","QDes":"/","IQLid":"363","AQLid":"363","EMCode":"10363","QHide":"1","AniStickerType":1,"AniStickerId":"8","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"365","QDes":"/","IQLid":"365","AQLid":"365","EMCode":"10365","QHide":"1","AniStickerType":1,"AniStickerId":"9","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"367","QDes":"/","IQLid":"367","AQLid":"367","EMCode":"10367","QHide":"1","AniStickerType":1,"AniStickerId":"10","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"399","QDes":"/tui","IQLid":"399","AQLid":"399","EMCode":"10399","QHide":"1","AniStickerType":1,"AniStickerId":"1","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"398","QDes":"/ok","IQLid":"398","AQLid":"398","EMCode":"10398","QHide":"1","AniStickerType":1,"AniStickerId":"2","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"373","QDes":"/","IQLid":"373","AQLid":"373","EMCode":"10373","QHide":"1","AniStickerType":1,"AniStickerId":"3","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"370","QDes":"/","IQLid":"370","AQLid":"370","EMCode":"10370","QHide":"1","AniStickerType":1,"AniStickerId":"4","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"375","QDes":"/","IQLid":"375","AQLid":"375","EMCode":"10375","QHide":"1","AniStickerType":1,"AniStickerId":"5","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"368","QDes":"/","IQLid":"368","AQLid":"368","EMCode":"10368","QHide":"1","AniStickerType":1,"AniStickerId":"6","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"369","QDes":"/","IQLid":"369","AQLid":"369","EMCode":"10369","QHide":"1","AniStickerType":1,"AniStickerId":"7","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"371","QDes":"/","IQLid":"371","AQLid":"371","EMCode":"10371","QHide":"1","AniStickerType":1,"AniStickerId":"8","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"372","QDes":"/","IQLid":"372","AQLid":"372","EMCode":"10372","QHide":"1","AniStickerType":1,"AniStickerId":"9","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"374","QDes":"/","IQLid":"374","AQLid":"374","EMCode":"10374","QHide":"1","AniStickerType":1,"AniStickerId":"10","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"382","QDes":"/emo","IQLid":"382","AQLid":"382","EMCode":"10382","QHide":"1","AniStickerType":1,"AniStickerId":"1","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"383","QDes":"/","IQLid":"383","AQLid":"383","EMCode":"10383","QHide":"1","AniStickerType":1,"AniStickerId":"2","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"401","QDes":"/","IQLid":"401","AQLid":"401","EMCode":"10401","QHide":"1","AniStickerType":1,"AniStickerId":"3","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"400","QDes":"/","IQLid":"400","AQLid":"400","EMCode":"10400","QHide":"1","AniStickerType":1,"AniStickerId":"4","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"380","QDes":"/","IQLid":"380","AQLid":"380","EMCode":"10380","QHide":"1","AniStickerType":1,"AniStickerId":"5","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"381","QDes":"/","IQLid":"381","AQLid":"381","EMCode":"10381","QHide":"1","AniStickerType":1,"AniStickerId":"6","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"379","QDes":"/","IQLid":"379","AQLid":"379","EMCode":"10379","QHide":"1","AniStickerType":1,"AniStickerId":"7","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"376","QDes":"/","IQLid":"376","AQLid":"376","EMCode":"10376","QHide":"1","AniStickerType":1,"AniStickerId":"8","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"378","QDes":"/","IQLid":"378","AQLid":"378","EMCode":"10378","QHide":"1","AniStickerType":1,"AniStickerId":"9","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"377","QDes":"/","IQLid":"377","AQLid":"377","EMCode":"10377","QHide":"1","AniStickerType":1,"AniStickerId":"10","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"403","QDes":"/","IQLid":"403","AQLid":"403","EMCode":"10403","QHide":"1","AniStickerType":1,"AniStickerId":"1","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"402","QDes":"/","IQLid":"402","AQLid":"402","EMCode":"10402","QHide":"1","AniStickerType":1,"AniStickerId":"2","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"390","QDes":"/","IQLid":"390","AQLid":"390","EMCode":"10390","QHide":"1","AniStickerType":1,"AniStickerId":"3","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"391","QDes":"/","IQLid":"391","AQLid":"391","EMCode":"10391","QHide":"1","AniStickerType":1,"AniStickerId":"4","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"388","QDes":"/","IQLid":"388","AQLid":"388","EMCode":"10388","QHide":"1","AniStickerType":1,"AniStickerId":"5","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"389","QDes":"/","IQLid":"389","AQLid":"389","EMCode":"10389","QHide":"1","AniStickerType":1,"AniStickerId":"6","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"386","QDes":"/","IQLid":"386","AQLid":"386","EMCode":"10386","QHide":"1","AniStickerType":1,"AniStickerId":"7","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"385","QDes":"/","IQLid":"385","AQLid":"385","EMCode":"10385","QHide":"1","AniStickerType":1,"AniStickerId":"8","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"384","QDes":"/","IQLid":"384","AQLid":"384","EMCode":"10384","QHide":"1","AniStickerType":1,"AniStickerId":"9","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"387","QDes":"/","IQLid":"387","AQLid":"387","EMCode":"10387","QHide":"1","AniStickerType":1,"AniStickerId":"10","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"413","QDes":"/","IQLid":"413","AQLid":"413","EMCode":"10413","QHide":"1","AniStickerType":1,"AniStickerId":"1","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"405","QDes":"/","IQLid":"405","AQLid":"405","EMCode":"10405","QHide":"1","AniStickerType":1,"AniStickerId":"2","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"404","QDes":"/","IQLid":"404","AQLid":"404","EMCode":"10404","QHide":"1","AniStickerType":1,"AniStickerId":"3","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"406","QDes":"/","IQLid":"406","AQLid":"406","EMCode":"10406","QHide":"1","AniStickerType":1,"AniStickerId":"4","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"410","QDes":"/","IQLid":"410","AQLid":"410","EMCode":"10410","QHide":"1","AniStickerType":1,"AniStickerId":"5","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"411","QDes":"/","IQLid":"411","AQLid":"411","EMCode":"10411","QHide":"1","AniStickerType":1,"AniStickerId":"6","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"407","QDes":"/","IQLid":"407","AQLid":"407","EMCode":"10407","QHide":"1","AniStickerType":1,"AniStickerId":"7","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"408","QDes":"/","IQLid":"408","AQLid":"408","EMCode":"10408","QHide":"1","AniStickerType":1,"AniStickerId":"8","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"412","QDes":"/","IQLid":"412","AQLid":"412","EMCode":"10412","QHide":"1","AniStickerType":1,"AniStickerId":"9","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"409","QDes":"/","IQLid":"409","AQLid":"409","EMCode":"10409","QHide":"1","AniStickerType":1,"AniStickerId":"10","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"14","QDes":"/","IQLid":"23","AQLid":"23","EMCode":"100"},{"QSid":"1","QDes":"/","IQLid":"40","AQLid":"40","EMCode":"101"},{"QSid":"2","QDes":"/","IQLid":"19","AQLid":"19","EMCode":"102"},{"QSid":"3","QDes":"/","IQLid":"43","AQLid":"43","EMCode":"103"},{"QSid":"4","QDes":"/","IQLid":"21","AQLid":"21","EMCode":"104"},{"QSid":"6","QDes":"/","IQLid":"20","AQLid":"20","EMCode":"106"},{"QSid":"7","QDes":"/","IQLid":"104","AQLid":"106","EMCode":"107"},{"QSid":"8","QDes":"/","IQLid":"35","AQLid":"35","EMCode":"108"},{"QSid":"9","QDes":"/","IQLid":"10","AQLid":"10","EMCode":"109"},{"QSid":"5","QDes":"/","IQLid":"9","AQLid":"9","EMCode":"105","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"16"},{"QSid":"10","QDes":"/","IQLid":"25","AQLid":"25","EMCode":"110"},{"QSid":"11","QDes":"/","IQLid":"24","AQLid":"24","EMCode":"111"},{"QSid":"12","QDes":"/","IQLid":"1","AQLid":"1","EMCode":"112"},{"QSid":"13","QDes":"/","IQLid":"0","AQLid":"0","EMCode":"113"},{"QSid":"0","QDes":"/","IQLid":"33","AQLid":"33","EMCode":"114"},{"QSid":"15","QDes":"/","IQLid":"32","AQLid":"32","EMCode":"115"},{"QSid":"16","QDes":"/","IQLid":"12","AQLid":"12","EMCode":"116"},{"QSid":"96","QDes":"/","IQLid":"27","AQLid":"27","EMCode":"117"},{"QSid":"18","QDes":"/","IQLid":"13","AQLid":"13","EMCode":"118"},{"QSid":"19","QDes":"/","IQLid":"22","AQLid":"22","EMCode":"119"},{"QSid":"20","QDes":"/","IQLid":"3","AQLid":"3","EMCode":"120"},{"QSid":"21","QDes":"/","IQLid":"18","AQLid":"18","EMCode":"121"},{"QSid":"22","QDes":"/","IQLid":"30","AQLid":"30","EMCode":"122"},{"QSid":"23","QDes":"/","IQLid":"31","AQLid":"31","EMCode":"123"},{"QSid":"24","QDes":"/","IQLid":"79","AQLid":"81","EMCode":"124"},{"QSid":"25","QDes":"/","IQLid":"80","AQLid":"82","EMCode":"125"},{"QSid":"26","QDes":"/","IQLid":"26","AQLid":"26","EMCode":"126"},{"QSid":"27","QDes":"/","IQLid":"2","AQLid":"2","EMCode":"127"},{"QSid":"28","QDes":"/","IQLid":"37","AQLid":"37","EMCode":"128"},{"QSid":"29","QDes":"/","IQLid":"50","AQLid":"50","EMCode":"129"},{"QSid":"30","QDes":"/","IQLid":"42","AQLid":"42","EMCode":"130"},{"QSid":"31","QDes":"/","IQLid":"81","AQLid":"83","EMCode":"131"},{"QSid":"32","QDes":"/","IQLid":"34","AQLid":"34","EMCode":"132"},{"QSid":"33","QDes":"/","IQLid":"11","AQLid":"11","EMCode":"133"},{"QSid":"34","QDes":"/","IQLid":"49","AQLid":"49","EMCode":"134"},{"QSid":"35","QDes":"/","IQLid":"82","AQLid":"84","EMCode":"135"},{"QSid":"36","QDes":"/","IQLid":"39","AQLid":"39","EMCode":"136"},{"QSid":"37","QDes":"/","isStatic":"1","IQLid":"76","AQLid":"78","EMCode":"137"},{"QSid":"38","QDes":"/","IQLid":"5","AQLid":"5","EMCode":"138"},{"QSid":"39","QDes":"/","IQLid":"4","AQLid":"4","EMCode":"139"},{"QSid":"97","QDes":"/","IQLid":"6","AQLid":"6","EMCode":"140"},{"QSid":"98","QDes":"/","IQLid":"83","AQLid":"85","EMCode":"141"},{"QSid":"99","QDes":"/","IQLid":"84","AQLid":"86","EMCode":"142"},{"QSid":"100","QDes":"/","IQLid":"85","AQLid":"87","EMCode":"143"},{"QSid":"101","QDes":"/","IQLid":"46","AQLid":"46","EMCode":"144"},{"QSid":"102","QDes":"/","IQLid":"86","AQLid":"88","EMCode":"145"},{"QSid":"103","QDes":"/","IQLid":"44","AQLid":"44","EMCode":"146"},{"QSid":"104","QDes":"/","IQLid":"87","AQLid":"89","EMCode":"147"},{"QSid":"105","QDes":"/","IQLid":"48","AQLid":"48","EMCode":"148"},{"QSid":"106","QDes":"/","IQLid":"14","AQLid":"14","EMCode":"149"},{"QSid":"107","QDes":"/","IQLid":"88","AQLid":"90","EMCode":"150"},{"QSid":"108","QDes":"/","IQLid":"41","AQLid":"41","EMCode":"151"},{"QSid":"305","QDes":"/","IQLid":"305","AQLid":"305","EMCode":"10305"},{"QSid":"109","QDes":"/","IQLid":"36","AQLid":"36","EMCode":"152"},{"QSid":"110","QDes":"/","IQLid":"89","AQLid":"91","EMCode":"153"},{"QSid":"111","QDes":"/","IQLid":"51","AQLid":"51","EMCode":"154"},{"QSid":"172","QDes":"/","IQLid":"142","AQLid":"164","EMCode":"242"},{"QSid":"182","QDes":"/","IQLid":"152","AQLid":"174","EMCode":"252"},{"QSid":"179","QDes":"/doge","IQLid":"149","AQLid":"171","EMCode":"249"},{"QSid":"173","QDes":"/","IQLid":"143","AQLid":"165","EMCode":"243"},{"QSid":"174","QDes":"/","IQLid":"144","AQLid":"166","EMCode":"244"},{"QSid":"212","QDes":"/","IQLid":"182","AQLid":"161","EMCode":"282"},{"QSid":"175","QDes":"/","IQLid":"145","AQLid":"167","EMCode":"245"},{"QSid":"178","QDes":"/","IQLid":"148","AQLid":"170","EMCode":"248"},{"QSid":"177","QDes":"/","IQLid":"147","AQLid":"169","EMCode":"247"},{"QSid":"176","QDes":"/","IQLid":"146","AQLid":"168","EMCode":"246"},{"QSid":"183","QDes":"/","IQLid":"153","AQLid":"175","EMCode":"253"},{"QSid":"262","QDes":"/","IQLid":"262","AQLid":"262","EMCode":"10262"},{"QSid":"263","QDes":"/","IQLid":"263","AQLid":"263","EMCode":"10263"},{"QSid":"264","QDes":"/","IQLid":"264","AQLid":"264","EMCode":"10264"},{"QSid":"265","QDes":"/","IQLid":"265","AQLid":"265","EMCode":"10265"},{"QSid":"266","QDes":"/","IQLid":"266","AQLid":"266","EMCode":"10266"},{"QSid":"267","QDes":"/","IQLid":"267","AQLid":"267","EMCode":"10267"},{"QSid":"268","QDes":"/","IQLid":"268","AQLid":"268","EMCode":"10268"},{"QSid":"269","QDes":"/","IQLid":"269","AQLid":"269","EMCode":"10269"},{"QSid":"270","QDes":"/emm","IQLid":"270","AQLid":"270","EMCode":"10270"},{"QSid":"271","QDes":"/","IQLid":"271","AQLid":"271","EMCode":"10271"},{"QSid":"272","QDes":"/","IQLid":"272","AQLid":"272","EMCode":"10272"},{"QSid":"277","QDes":"/","IQLid":"277","AQLid":"277","EMCode":"10277"},{"QSid":"307","QDes":"/","IQLid":"307","AQLid":"307","EMCode":"10307"},{"QSid":"306","QDes":"/","isStatic":"1","IQLid":"306","AQLid":"306","EMCode":"10306"},{"QSid":"281","QDes":"/","IQLid":"281","AQLid":"281","EMCode":"10281"},{"QSid":"282","QDes":"/","IQLid":"282","AQLid":"282","EMCode":"10282"},{"QSid":"283","QDes":"/","IQLid":"283","AQLid":"283","EMCode":"10283"},{"QSid":"284","QDes":"/","IQLid":"284","AQLid":"284","EMCode":"10284"},{"QSid":"285","QDes":"/","IQLid":"285","AQLid":"285","EMCode":"10285"},{"QSid":"293","QDes":"/","IQLid":"293","AQLid":"293","EMCode":"10293"},{"QSid":"286","QDes":"/","IQLid":"286","AQLid":"286","EMCode":"10286"},{"QSid":"287","QDes":"/","IQLid":"287","AQLid":"287","EMCode":"10287"},{"QSid":"289","QDes":"/","IQLid":"289","AQLid":"289","EMCode":"10289"},{"QSid":"294","QDes":"/","IQLid":"294","AQLid":"294","EMCode":"10294"},{"QSid":"297","QDes":"/","IQLid":"297","AQLid":"297","EMCode":"10297"},{"QSid":"298","QDes":"/","IQLid":"298","AQLid":"298","EMCode":"10298"},{"QSid":"299","QDes":"/","IQLid":"299","AQLid":"299","EMCode":"10299"},{"QSid":"300","QDes":"/","IQLid":"300","AQLid":"300","EMCode":"10300"},{"QSid":"323","QDes":"/","IQLid":"323","AQLid":"323","EMCode":"10323"},{"QSid":"332","QDes":"/","IQLid":"332","AQLid":"332","EMCode":"10332"},{"QSid":"336","QDes":"/","IQLid":"336","AQLid":"336","EMCode":"10336"},{"QSid":"353","QDes":"/","IQLid":"353","AQLid":"353","EMCode":"10353"},{"QSid":"355","QDes":"/","IQLid":"355","AQLid":"355","EMCode":"10355"},{"QSid":"356","QDes":"/666","IQLid":"356","AQLid":"356","EMCode":"10356"},{"QSid":"354","QDes":"/","IQLid":"354","AQLid":"354","EMCode":"10354"},{"QSid":"352","QDes":"/","IQLid":"352","AQLid":"352","EMCode":"10352"},{"QSid":"357","QDes":"/","IQLid":"357","AQLid":"357","EMCode":"10357"},{"QSid":"334","QDes":"/","IQLid":"334","AQLid":"334","EMCode":"10334"},{"QSid":"347","QDes":"/","IQLid":"347","AQLid":"347","EMCode":"10347"},{"QSid":"303","QDes":"/","IQLid":"303","AQLid":"303","EMCode":"10303"},{"QSid":"302","QDes":"/","IQLid":"302","AQLid":"302","EMCode":"10302"},{"QSid":"295","QDes":"/","IQLid":"295","AQLid":"295","EMCode":"10295"},{"QSid":"311","QDes":"/call","IQLid":"311","AQLid":"311","EMCode":"10311","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"1"},{"QSid":"312","QDes":"/","IQLid":"312","AQLid":"312","EMCode":"10312","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"2"},{"QSid":"314","QDes":"/","IQLid":"314","AQLid":"314","EMCode":"10314","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"4"},{"QSid":"317","QDes":"/","IQLid":"317","AQLid":"317","EMCode":"10317","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"7"},{"QSid":"318","QDes":"/","IQLid":"318","AQLid":"318","EMCode":"10318","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"8"},{"QSid":"319","QDes":"/","IQLid":"319","AQLid":"319","EMCode":"10319","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"9"},{"QSid":"320","QDes":"/","IQLid":"320","AQLid":"320","EMCode":"10320","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"10"},{"QSid":"324","QDes":"/","IQLid":"324","AQLid":"324","EMCode":"10324","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"12"},{"QSid":"325","QDes":"/","IQLid":"325","AQLid":"325","EMCode":"10325","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"14"},{"QSid":"337","QDes":"/","IQLid":"337","AQLid":"337","EMCode":"10337","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"22"},{"QSid":"338","QDes":"/","IQLid":"338","AQLid":"338","EMCode":"10338","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"20"},{"QSid":"339","QDes":"/","IQLid":"339","AQLid":"339","EMCode":"10339","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"21"},{"QSid":"341","QDes":"/","IQLid":"341","AQLid":"341","EMCode":"10341","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"24"},{"QSid":"342","QDes":"/Q","IQLid":"342","AQLid":"342","EMCode":"10342","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"26"},{"QSid":"343","QDes":"/","IQLid":"343","AQLid":"343","EMCode":"10343","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"27"},{"QSid":"344","QDes":"/","IQLid":"344","AQLid":"344","EMCode":"10344","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"28"},{"QSid":"345","QDes":"/","IQLid":"345","AQLid":"345","EMCode":"10345","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"29"},{"QSid":"346","QDes":"/","IQLid":"346","AQLid":"346","EMCode":"10346","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"25"},{"QSid":"181","QDes":"/","IQLid":"151","AQLid":"173","EMCode":"251","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"37"},{"QSid":"74","QDes":"/","isStatic":"1","IQLid":"73","AQLid":"75","EMCode":"176","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"35"},{"QSid":"75","QDes":"/","isStatic":"1","IQLid":"67","AQLid":"68","EMCode":"175","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"36"},{"QSid":"351","QDes":"/","IQLid":"351","AQLid":"351","EMCode":"10351","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"30"},{"QSid":"349","QDes":"/","IQLid":"349","AQLid":"349","EMCode":"10349","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"32"},{"QSid":"350","QDes":"/","IQLid":"350","AQLid":"350","EMCode":"10350","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"31"},{"QSid":"395","QDes":"/","IQLid":"395","AQLid":"395","EMCode":"10395","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"41"},{"QSid":"114","QDes":"/","IQLid":"90","AQLid":"92","EMCode":"158","AniStickerType":2,"AniStickerPackId":"1","AniStickerId":"13"},{"QSid":"358","QDes":"/","IQLid":"358","AQLid":"358","QHide":"1","EMCode":"10358","AniStickerType":2,"AniStickerPackId":"1","AniStickerId":"33"},{"QSid":"359","QDes":"/","IQLid":"359","AQLid":"359","QHide":"1","EMCode":"10359","AniStickerType":2,"AniStickerPackId":"1","AniStickerId":"34"},{"QSid":"326","QDes":"/","IQLid":"326","AQLid":"326","EMCode":"10326","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"15"},{"QSid":"53","QDes":"/","IQLid":"59","AQLid":"59","EMCode":"168","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"17"},{"QSid":"49","QDes":"/","IQLid":"45","AQLid":"45","EMCode":"178"},{"QSid":"66","QDes":"/","IQLid":"28","AQLid":"28","EMCode":"166"},{"QSid":"63","QDes":"/","IQLid":"8","AQLid":"8","EMCode":"163"},{"QSid":"64","QDes":"/","IQLid":"57","AQLid":"57","EMCode":"164"},{"QSid":"187","QDes":"/","IQLid":"157","AQLid":"179","EMCode":"257"},{"QSid":"146","QDes":"/","IQLid":"116","AQLid":"118","EMCode":"121011"},{"QSid":"116","QDes":"/","IQLid":"29","AQLid":"29","EMCode":"165"},{"QSid":"67","QDes":"/","IQLid":"72","AQLid":"74","EMCode":"167"},{"QSid":"60","QDes":"/","IQLid":"66","AQLid":"66","EMCode":"160"},{"QSid":"185","QDes":"/","IQLid":"155","AQLid":"177","EMCode":"255"},{"QSid":"137","QDes":"/","isStatic":"1","IQLid":"107","AQLid":"109","EMCode":"121002","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"18"},{"QSid":"333","QDes":"/","isStatic":"1","IQLid":"333","AQLid":"333","EMCode":"10333","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"19"},{"QSid":"415","QDes":"/","IQLid":"415","AQLid":"415","EMCode":"10415","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"43","AniStickerWidth":192,"AniStickerHeight":76},{"QSid":"416","QDes":"/","IQLid":"416","AQLid":"416","EMCode":"10416","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"44","AniStickerWidth":192,"AniStickerHeight":76,"QHide":"1"},{"QSid":"417","QDes":"/","IQLid":"417","AQLid":"417","EMCode":"10417","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"45","AniStickerWidth":192,"AniStickerHeight":96,"QHide":"1"},{"QSid":"392","QDes":"/","IQLid":"392","AQLid":"392","EMCode":"10392","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"38","AniStickerWidth":129,"AniStickerHeight":57},{"QSid":"393","QDes":"/","IQLid":"393","AQLid":"393","EMCode":"10393","QHide":"1","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"39","AniStickerWidth":159,"AniStickerHeight":72},{"QSid":"394","QDes":"/","IQLid":"394","AQLid":"394","EMCode":"10394","QHide":"1","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"40","AniStickerWidth":220,"AniStickerHeight":91},{"QSid":"76","QDes":"/","IQLid":"52","AQLid":"52","EMCode":"179"},{"QSid":"124","QDes":"/OK","IQLid":"64","AQLid":"64","EMCode":"189"},{"QSid":"118","QDes":"/","IQLid":"56","AQLid":"56","EMCode":"183"},{"QSid":"78","QDes":"/","IQLid":"54","AQLid":"54","EMCode":"181"},{"QSid":"119","QDes":"/","IQLid":"63","AQLid":"63","EMCode":"184"},{"QSid":"79","QDes":"/","IQLid":"55","AQLid":"55","EMCode":"182"},{"QSid":"120","QDes":"/","IQLid":"71","AQLid":"73","EMCode":"185"},{"QSid":"121","QDes":"/","IQLid":"70","AQLid":"72","EMCode":"186"},{"QSid":"77","QDes":"/","IQLid":"53","AQLid":"53","EMCode":"180"},{"QSid":"123","QDes":"/NO","IQLid":"92","AQLid":"94","EMCode":"188"},{"QSid":"201","QDes":"/","IQLid":"171","AQLid":"150","EMCode":"271"},{"QSid":"273","QDes":"/","isStatic":"1","IQLid":"273","AQLid":"273","EMCode":"10273"},{"QSid":"46","QDes":"/","isStatic":"1","IQLid":"7","AQLid":"7","EMCode":"162"},{"QSid":"112","QDes":"/","IQLid":"17","AQLid":"17","EMCode":"155"},{"QSid":"56","QDes":"/","IQLid":"68","AQLid":"70","EMCode":"171"},{"QSid":"169","QDes":"/","isStatic":"1","IQLid":"139","AQLid":"141","EMCode":"121034"},{"QSid":"171","QDes":"/","IQLid":"141","AQLid":"163","EMCode":"241"},{"QSid":"59","QDes":"/","IQLid":"15","AQLid":"15","EMCode":"174"},{"QSid":"144","QDes":"/","isStatic":"1","IQLid":"114","AQLid":"116","EMCode":"121009"},{"QSid":"147","QDes":"/","isStatic":"1","IQLid":"117","AQLid":"119","EMCode":"121012"},{"QSid":"89","QDes":"/","isStatic":"1","IQLid":"60","AQLid":"60","EMCode":"156"},{"QSid":"148","QDes":"/","isStatic":"1","IQLid":"118","AQLid":"120","QHide":"1","EMCode":"121013"},{"QSid":"55","QDes":"/","isStatic":"1","IQLid":"16","AQLid":"16","QHide":"1","EMCode":"170"},{"QSid":"41","QDes":"/","isStatic":"1","IQLid":"69","AQLid":"71","EMCode":"193"},{"QSid":"125","QDes":"/","IQLid":"95","AQLid":"97","EMCode":"195"},{"QSid":"42","QDes":"/","IQLid":"38","AQLid":"38","EMCode":"190"},{"QSid":"43","QDes":"/","IQLid":"93","AQLid":"95","EMCode":"192"},{"QSid":"86","QDes":"/","IQLid":"94","AQLid":"96","EMCode":"194"},{"QSid":"129","QDes":"/","IQLid":"77","AQLid":"79","EMCode":"199"},{"QSid":"226","QDes":"/","IQLid":"196","isCMEmoji":"1","AQLid":"198","QHide":"1","EMCode":"297"},{"QSid":"85","QDes":"/","isStatic":"1","IQLid":"47","AQLid":"47","EMCode":"191"},{"QSid":"215","QDes":"/","IQLid":"185","isCMEmoji":"1","AQLid":"187","QHide":"1","EMCode":"285"},{"QSid":"214","QDes":"/","IQLid":"184","isCMEmoji":"1","AQLid":"186","QHide":"1","EMCode":"284"},{"QSid":"222","QDes":"/","IQLid":"192","isCMEmoji":"1","AQLid":"194","QHide":"1","EMCode":"292"},{"QSid":"203","QDes":"/","IQLid":"173","AQLid":"152","QHide":"1","EMCode":"273"},{"QSid":"235","QDes":"/","IQLid":"205","isCMEmoji":"1","AQLid":"207","QHide":"1","EMCode":"305"},{"QSid":"241","QDes":"/","IQLid":"211","isCMEmoji":"1","AQLid":"213","QHide":"1","EMCode":"311"},{"QSid":"237","QDes":"/","IQLid":"207","isCMEmoji":"1","AQLid":"209","QHide":"1","EMCode":"307"},{"QSid":"218","QDes":"/","IQLid":"188","isCMEmoji":"1","AQLid":"190","QHide":"1","EMCode":"288"},{"QSid":"233","QDes":"/","IQLid":"203","isCMEmoji":"1","AQLid":"205","QHide":"1","EMCode":"303"},{"QSid":"232","QDes":"/","IQLid":"202","isCMEmoji":"1","AQLid":"204","QHide":"1","EMCode":"302"},{"QSid":"238","QDes":"/","IQLid":"208","isCMEmoji":"1","AQLid":"210","QHide":"1","EMCode":"308"},{"QSid":"217","QDes":"/","IQLid":"187","isCMEmoji":"1","AQLid":"189","QHide":"1","EMCode":"287"},{"QSid":"225","QDes":"/","IQLid":"195","isCMEmoji":"1","AQLid":"197","QHide":"1","EMCode":"296"},{"QSid":"230","QDes":"/","IQLid":"200","isCMEmoji":"1","AQLid":"202","QHide":"1","EMCode":"300"},{"QSid":"194","QDes":"/","IQLid":"164","AQLid":"143","QHide":"1","EMCode":"264"},{"QSid":"210","QDes":"/","IQLid":"180","AQLid":"159","QHide":"1","EMCode":"280"},{"QSid":"193","QDes":"/","IQLid":"163","AQLid":"185","QHide":"1","EMCode":"263"},{"QSid":"204","QDes":"/","IQLid":"174","AQLid":"153","QHide":"1","EMCode":"274"},{"QSid":"200","QDes":"/","IQLid":"170","AQLid":"149","QHide":"1","EMCode":"270"},{"QSid":"290","QDes":"/","IQLid":"290","isCMEmoji":"1","AQLid":"290","QHide":"1","EMCode":"20240"},{"QSid":"224","QDes":"/","IQLid":"194","isCMEmoji":"1","AQLid":"196","QHide":"1","EMCode":"295"},{"QSid":"229","QDes":"/","IQLid":"199","isCMEmoji":"1","AQLid":"201","QHide":"1","EMCode":"299"},{"QSid":"221","QDes":"/","IQLid":"191","isCMEmoji":"1","AQLid":"193","QHide":"1","EMCode":"291"},{"QSid":"219","QDes":"/","IQLid":"189","isCMEmoji":"1","AQLid":"191","QHide":"1","EMCode":"289"},{"QSid":"227","QDes":"/","IQLid":"197","isCMEmoji":"1","AQLid":"199","QHide":"1","EMCode":"294"},{"QSid":"216","QDes":"/","IQLid":"186","isCMEmoji":"1","AQLid":"188","QHide":"1","EMCode":"286"},{"QSid":"231","QDes":"/","IQLid":"201","isCMEmoji":"1","AQLid":"203","QHide":"1","EMCode":"301"},{"QSid":"244","QDes":"/","IQLid":"214","isCMEmoji":"1","AQLid":"216","QHide":"1","EMCode":"312"},{"QSid":"223","QDes":"/","IQLid":"193","isCMEmoji":"1","AQLid":"195","QHide":"1","EMCode":"293"},{"QSid":"243","QDes":"/","IQLid":"213","isCMEmoji":"1","AQLid":"215","QHide":"1","EMCode":"313"},{"QSid":"211","QDes":"/","IQLid":"181","AQLid":"160","QHide":"1","EMCode":"281"},{"QSid":"292","QDes":"/","IQLid":"292","isCMEmoji":"1","AQLid":"292","QHide":"1","EMCode":"20242"},{"QSid":"240","QDes":"/","IQLid":"210","isCMEmoji":"1","AQLid":"212","QHide":"1","EMCode":"310"},{"QSid":"180","QDes":"/","IQLid":"150","AQLid":"172","QHide":"1","EMCode":"250"},{"QSid":"122","QDes":"/","IQLid":"65","AQLid":"65","QHide":"1","EMCode":"187"},{"QSid":"202","QDes":"/","IQLid":"172","AQLid":"151","QHide":"1","EMCode":"272"},{"QSid":"278","QDes":"/","IQLid":"278","isCMEmoji":"1","AQLid":"278","QHide":"1","EMCode":"20237"},{"QSid":"301","QDes":"/","IQLid":"301","AQLid":"301","QHide":"1","EMCode":"10301"},{"QSid":"288","QDes":"/","IQLid":"288","AQLid":"288","QHide":"1","EMCode":"10288"},{"QSid":"322","QDes":"/","IQLid":"322","AQLid":"322","QHide":"1","EMCode":"10322"},{"QSid":"198","QDes":"/","IQLid":"168","AQLid":"147","QHide":"1","EMCode":"268"},{"QSid":"348","QDes":"/","IQLid":"348","AQLid":"348","QHide":"1","EMCode":"10348"},{"QSid":"206","QDes":"/","IQLid":"176","AQLid":"155","QHide":"1","EMCode":"276"},{"QSid":"239","QDes":"/","IQLid":"209","isCMEmoji":"1","AQLid":"211","QHide":"1","EMCode":"309"}]');
const faceConfig = {
  sysface
};
var decoder = new TextDecoder();
var toUTF8String = (input, start = 0, end = input.length) => decoder.decode(input.slice(start, end));
var toHexString = (input, start = 0, end = input.length) => input.slice(start, end).reduce((memo, i) => memo + `0${i.toString(16)}`.slice(-2), "");
var getView = (input, offset) => new DataView(input.buffer, input.byteOffset + offset);
var readInt16LE = (input, offset = 0) => getView(input, offset).getInt16(0, true);
var readUInt16BE = (input, offset = 0) => getView(input, offset).getUint16(0, false);
var readUInt16LE = (input, offset = 0) => getView(input, offset).getUint16(0, true);
var readUInt24LE = (input, offset = 0) => {
  const view2 = getView(input, offset);
  return view2.getUint16(0, true) + (view2.getUint8(2) << 16);
};
var readInt32LE = (input, offset = 0) => getView(input, offset).getInt32(0, true);
var readUInt32BE = (input, offset = 0) => getView(input, offset).getUint32(0, false);
var readUInt32LE = (input, offset = 0) => getView(input, offset).getUint32(0, true);
var readUInt64 = (input, offset, isBigEndian) => getView(input, offset).getBigUint64(0, !isBigEndian);
var methods = {
  readUInt16BE,
  readUInt16LE,
  readUInt32BE,
  readUInt32LE
};
function readUInt(input, bits, offset = 0, isBigEndian = false) {
  const endian = isBigEndian ? "BE" : "LE";
  const methodName = `readUInt${bits}${endian}`;
  return methods[methodName](input, offset);
}
function readBox(input, offset) {
  if (input.length - offset < 4) return;
  const boxSize = readUInt32BE(input, offset);
  if (input.length - offset < boxSize) return;
  return {
    name: toUTF8String(input, 4 + offset, 8 + offset),
    offset,
    size: boxSize
  };
}
function findBox(input, boxName, currentOffset) {
  while (currentOffset < input.length) {
    const box = readBox(input, currentOffset);
    if (!box) break;
    if (box.name === boxName) return box;
    currentOffset += box.size > 0 ? box.size : 8;
  }
}
var BMP = {
  validate: (input) => toUTF8String(input, 0, 2) === "BM",
  calculate: (input) => ({
    height: Math.abs(readInt32LE(input, 22)),
    width: readUInt32LE(input, 18)
  })
};
var TYPE_ICON = 1;
var SIZE_HEADER = 2 + 2 + 2;
var SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
function getSizeFromOffset(input, offset) {
  const value = input[offset];
  return value === 0 ? 256 : value;
}
function getImageSize$1(input, imageIndex) {
  const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;
  return {
    height: getSizeFromOffset(input, offset + 1),
    width: getSizeFromOffset(input, offset)
  };
}
var ICO = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0) return false;
    const imageType = readUInt16LE(input, 2);
    return imageType === TYPE_ICON;
  },
  calculate(input) {
    const nbImages = readUInt16LE(input, 4);
    const imageSize2 = getImageSize$1(input, 0);
    if (nbImages === 1) return imageSize2;
    const images = [];
    for (let imageIndex = 0; imageIndex < nbImages; imageIndex += 1) {
      images.push(getImageSize$1(input, imageIndex));
    }
    return {
      width: imageSize2.width,
      height: imageSize2.height,
      images
    };
  }
};
var TYPE_CURSOR = 2;
var CUR = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0) return false;
    const imageType = readUInt16LE(input, 2);
    return imageType === TYPE_CURSOR;
  },
  calculate: (input) => ICO.calculate(input)
};
var DDS = {
  validate: (input) => readUInt32LE(input, 0) === 542327876,
  calculate: (input) => ({
    height: readUInt32LE(input, 12),
    width: readUInt32LE(input, 16)
  })
};
var gifRegexp = /^GIF8[79]a/;
var GIF = {
  validate: (input) => gifRegexp.test(toUTF8String(input, 0, 6)),
  calculate: (input) => ({
    height: readUInt16LE(input, 8),
    width: readUInt16LE(input, 6)
  })
};
var brandMap = {
  avif: "avif",
  mif1: "heif",
  msf1: "heif",
  // heif-sequence
  heic: "heic",
  heix: "heic",
  hevc: "heic",
  // heic-sequence
  hevx: "heic"
  // heic-sequence
};
var HEIF = {
  validate(input) {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "ftyp") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand in brandMap;
  },
  calculate(input) {
    const metaBox = findBox(input, "meta", 0);
    const iprpBox = metaBox && findBox(input, "iprp", metaBox.offset + 12);
    const ipcoBox = iprpBox && findBox(input, "ipco", iprpBox.offset + 8);
    if (!ipcoBox) {
      throw new TypeError("Invalid HEIF, no ipco box found");
    }
    const type2 = toUTF8String(input, 8, 12);
    const images = [];
    let currentOffset = ipcoBox.offset + 8;
    while (currentOffset < ipcoBox.offset + ipcoBox.size) {
      const ispeBox = findBox(input, "ispe", currentOffset);
      if (!ispeBox) break;
      const rawWidth = readUInt32BE(input, ispeBox.offset + 12);
      const rawHeight = readUInt32BE(input, ispeBox.offset + 16);
      const clapBox = findBox(input, "clap", currentOffset);
      let width = rawWidth;
      let height = rawHeight;
      if (clapBox && clapBox.offset < ipcoBox.offset + ipcoBox.size) {
        const cropRight = readUInt32BE(input, clapBox.offset + 12);
        width = rawWidth - cropRight;
      }
      images.push({ height, width });
      currentOffset = ispeBox.offset + ispeBox.size;
    }
    if (images.length === 0) {
      throw new TypeError("Invalid HEIF, no sizes found");
    }
    return {
      width: images[0].width,
      height: images[0].height,
      type: type2,
      ...images.length > 1 ? { images } : {}
    };
  }
};
var SIZE_HEADER2 = 4 + 4;
var FILE_LENGTH_OFFSET = 4;
var ENTRY_LENGTH_OFFSET = 4;
var ICON_TYPE_SIZE = {
  ICON: 32,
  "ICN#": 32,
  // m => 16 x 16
  "icm#": 16,
  icm4: 16,
  icm8: 16,
  // s => 16 x 16
  "ics#": 16,
  ics4: 16,
  ics8: 16,
  is32: 16,
  s8mk: 16,
  icp4: 16,
  // l => 32 x 32
  icl4: 32,
  icl8: 32,
  il32: 32,
  l8mk: 32,
  icp5: 32,
  ic11: 32,
  // h => 48 x 48
  ich4: 48,
  ich8: 48,
  ih32: 48,
  h8mk: 48,
  // . => 64 x 64
  icp6: 64,
  ic12: 32,
  // t => 128 x 128
  it32: 128,
  t8mk: 128,
  ic07: 128,
  // . => 256 x 256
  ic08: 256,
  ic13: 256,
  // . => 512 x 512
  ic09: 512,
  ic14: 512,
  // . => 1024 x 1024
  ic10: 1024
};
function readImageHeader(input, imageOffset) {
  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
  return [
    toUTF8String(input, imageOffset, imageLengthOffset),
    readUInt32BE(input, imageLengthOffset)
  ];
}
function getImageSize2(type2) {
  const size = ICON_TYPE_SIZE[type2];
  return { width: size, height: size, type: type2 };
}
var ICNS = {
  validate: (input) => toUTF8String(input, 0, 4) === "icns",
  calculate(input) {
    const inputLength = input.length;
    const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);
    let imageOffset = SIZE_HEADER2;
    const images = [];
    while (imageOffset < fileLength && imageOffset < inputLength) {
      const imageHeader = readImageHeader(input, imageOffset);
      const imageSize2 = getImageSize2(imageHeader[0]);
      images.push(imageSize2);
      imageOffset += imageHeader[1];
    }
    if (images.length === 0) {
      throw new TypeError("Invalid ICNS, no sizes found");
    }
    return {
      width: images[0].width,
      height: images[0].height,
      ...images.length > 1 ? { images } : {}
    };
  }
};
var J2C = {
  // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
  validate: (input) => readUInt32BE(input, 0) === 4283432785,
  calculate: (input) => ({
    height: readUInt32BE(input, 12),
    width: readUInt32BE(input, 8)
  })
};
var JP2 = {
  validate(input) {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "jP  ") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand === "jp2 ";
  },
  calculate(input) {
    const jp2hBox = findBox(input, "jp2h", 0);
    const ihdrBox = jp2hBox && findBox(input, "ihdr", jp2hBox.offset + 8);
    if (ihdrBox) {
      return {
        height: readUInt32BE(input, ihdrBox.offset + 8),
        width: readUInt32BE(input, ihdrBox.offset + 12)
      };
    }
    throw new TypeError("Unsupported JPEG 2000 format");
  }
};
var EXIF_MARKER = "45786966";
var APP1_DATA_SIZE_BYTES = 2;
var EXIF_HEADER_BYTES = 6;
var TIFF_BYTE_ALIGN_BYTES = 2;
var BIG_ENDIAN_BYTE_ALIGN = "4d4d";
var LITTLE_ENDIAN_BYTE_ALIGN = "4949";
var IDF_ENTRY_BYTES = 12;
var NUM_DIRECTORY_ENTRIES_BYTES = 2;
function isEXIF(input) {
  return toHexString(input, 2, 6) === EXIF_MARKER;
}
function extractSize(input, index) {
  return {
    height: readUInt16BE(input, index),
    width: readUInt16BE(input, index + 2)
  };
}
function extractOrientation(exifBlock, isBigEndian) {
  const idfOffset = 8;
  const offset = EXIF_HEADER_BYTES + idfOffset;
  const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);
  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
    const end = start + IDF_ENTRY_BYTES;
    if (start > exifBlock.length) {
      return;
    }
    const block = exifBlock.slice(start, end);
    const tagNumber = readUInt(block, 16, 0, isBigEndian);
    if (tagNumber === 274) {
      const dataFormat = readUInt(block, 16, 2, isBigEndian);
      if (dataFormat !== 3) {
        return;
      }
      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);
      if (numberOfComponents !== 1) {
        return;
      }
      return readUInt(block, 16, 8, isBigEndian);
    }
  }
}
function validateExifBlock(input, index) {
  const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index);
  const byteAlign = toHexString(
    exifBlock,
    EXIF_HEADER_BYTES,
    EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES
  );
  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
  if (isBigEndian || isLittleEndian) {
    return extractOrientation(exifBlock, isBigEndian);
  }
}
function validateInput(input, index) {
  if (index > input.length) {
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  }
}
var JPG = {
  validate: (input) => toHexString(input, 0, 2) === "ffd8",
  calculate(_input) {
    let input = _input.slice(4);
    let orientation;
    let next;
    while (input.length) {
      const i = readUInt16BE(input, 0);
      validateInput(input, i);
      if (input[i] !== 255) {
        input = input.slice(1);
        continue;
      }
      if (isEXIF(input)) {
        orientation = validateExifBlock(input, i);
      }
      next = input[i + 1];
      if (next === 192 || next === 193 || next === 194) {
        const size = extractSize(input, i + 5);
        if (!orientation) {
          return size;
        }
        return {
          height: size.height,
          orientation,
          width: size.width
        };
      }
      input = input.slice(i + 2);
    }
    throw new TypeError("Invalid JPG, no size found");
  }
};
var BitReader = class {
  constructor(input, endianness) {
    this.input = input;
    this.endianness = endianness;
    this.byteOffset = 2;
    this.bitOffset = 0;
  }
  /** Reads a specified number of bits, and move the offset */
  getBits(length = 1) {
    let result = 0;
    let bitsRead = 0;
    while (bitsRead < length) {
      if (this.byteOffset >= this.input.length) {
        throw new Error("Reached end of input");
      }
      const currentByte = this.input[this.byteOffset];
      const bitsLeft = 8 - this.bitOffset;
      const bitsToRead = Math.min(length - bitsRead, bitsLeft);
      if (this.endianness === "little-endian") {
        const mask = (1 << bitsToRead) - 1;
        const bits = currentByte >> this.bitOffset & mask;
        result |= bits << bitsRead;
      } else {
        const mask = (1 << bitsToRead) - 1 << 8 - this.bitOffset - bitsToRead;
        const bits = (currentByte & mask) >> 8 - this.bitOffset - bitsToRead;
        result = result << bitsToRead | bits;
      }
      bitsRead += bitsToRead;
      this.bitOffset += bitsToRead;
      if (this.bitOffset === 8) {
        this.byteOffset++;
        this.bitOffset = 0;
      }
    }
    return result;
  }
};
function calculateImageDimension(reader2, isSmallImage) {
  if (isSmallImage) {
    return 8 * (1 + reader2.getBits(5));
  }
  const sizeClass = reader2.getBits(2);
  const extraBits = [9, 13, 18, 30][sizeClass];
  return 1 + reader2.getBits(extraBits);
}
function calculateImageWidth(reader2, isSmallImage, widthMode, height) {
  if (isSmallImage && widthMode === 0) {
    return 8 * (1 + reader2.getBits(5));
  }
  if (widthMode === 0) {
    return calculateImageDimension(reader2, false);
  }
  const aspectRatios = [1, 1.2, 4 / 3, 1.5, 16 / 9, 5 / 4, 2];
  return Math.floor(height * aspectRatios[widthMode - 1]);
}
var JXLStream = {
  validate: (input) => {
    return toHexString(input, 0, 2) === "ff0a";
  },
  calculate(input) {
    const reader2 = new BitReader(input, "little-endian");
    const isSmallImage = reader2.getBits(1) === 1;
    const height = calculateImageDimension(reader2, isSmallImage);
    const widthMode = reader2.getBits(3);
    const width = calculateImageWidth(reader2, isSmallImage, widthMode, height);
    return { width, height };
  }
};
function extractCodestream(input) {
  const jxlcBox = findBox(input, "jxlc", 0);
  if (jxlcBox) {
    return input.slice(jxlcBox.offset + 8, jxlcBox.offset + jxlcBox.size);
  }
  const partialStreams = extractPartialStreams(input);
  if (partialStreams.length > 0) {
    return concatenateCodestreams(partialStreams);
  }
  return void 0;
}
function extractPartialStreams(input) {
  const partialStreams = [];
  let offset = 0;
  while (offset < input.length) {
    const jxlpBox = findBox(input, "jxlp", offset);
    if (!jxlpBox) break;
    partialStreams.push(
      input.slice(jxlpBox.offset + 12, jxlpBox.offset + jxlpBox.size)
    );
    offset = jxlpBox.offset + jxlpBox.size;
  }
  return partialStreams;
}
function concatenateCodestreams(partialCodestreams) {
  const totalLength = partialCodestreams.reduce(
    (acc, curr) => acc + curr.length,
    0
  );
  const codestream = new Uint8Array(totalLength);
  let position = 0;
  for (const partial of partialCodestreams) {
    codestream.set(partial, position);
    position += partial.length;
  }
  return codestream;
}
var JXL = {
  validate: (input) => {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "JXL ") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand === "jxl ";
  },
  calculate(input) {
    const codestream = extractCodestream(input);
    if (codestream) return JXLStream.calculate(codestream);
    throw new Error("No codestream found in JXL container");
  }
};
var KTX = {
  validate: (input) => {
    const signature = toUTF8String(input, 1, 7);
    return ["KTX 11", "KTX 20"].includes(signature);
  },
  calculate: (input) => {
    const type2 = input[5] === 49 ? "ktx" : "ktx2";
    const offset = type2 === "ktx" ? 36 : 20;
    return {
      height: readUInt32LE(input, offset + 4),
      width: readUInt32LE(input, offset),
      type: type2
    };
  }
};
var pngSignature = "PNG\r\n\n";
var pngImageHeaderChunkName = "IHDR";
var pngFriedChunkName = "CgBI";
var PNG = {
  validate(input) {
    if (pngSignature === toUTF8String(input, 1, 8)) {
      let chunkName = toUTF8String(input, 12, 16);
      if (chunkName === pngFriedChunkName) {
        chunkName = toUTF8String(input, 28, 32);
      }
      if (chunkName !== pngImageHeaderChunkName) {
        throw new TypeError("Invalid PNG");
      }
      return true;
    }
    return false;
  },
  calculate(input) {
    if (toUTF8String(input, 12, 16) === pngFriedChunkName) {
      return {
        height: readUInt32BE(input, 36),
        width: readUInt32BE(input, 32)
      };
    }
    return {
      height: readUInt32BE(input, 20),
      width: readUInt32BE(input, 16)
    };
  }
};
var PNMTypes = {
  P1: "pbm/ascii",
  P2: "pgm/ascii",
  P3: "ppm/ascii",
  P4: "pbm",
  P5: "pgm",
  P6: "ppm",
  P7: "pam",
  PF: "pfm"
};
var handlers$1 = {
  default: (lines) => {
    let dimensions = [];
    while (lines.length > 0) {
      const line2 = lines.shift();
      if (line2[0] === "#") {
        continue;
      }
      dimensions = line2.split(" ");
      break;
    }
    if (dimensions.length === 2) {
      return {
        height: Number.parseInt(dimensions[1], 10),
        width: Number.parseInt(dimensions[0], 10)
      };
    }
    throw new TypeError("Invalid PNM");
  },
  pam: (lines) => {
    const size = {};
    while (lines.length > 0) {
      const line2 = lines.shift();
      if (line2.length > 16 || line2.charCodeAt(0) > 128) {
        continue;
      }
      const [key2, value] = line2.split(" ");
      if (key2 && value) {
        size[key2.toLowerCase()] = Number.parseInt(value, 10);
      }
      if (size.height && size.width) {
        break;
      }
    }
    if (size.height && size.width) {
      return {
        height: size.height,
        width: size.width
      };
    }
    throw new TypeError("Invalid PAM");
  }
};
var PNM = {
  validate: (input) => toUTF8String(input, 0, 2) in PNMTypes,
  calculate(input) {
    const signature = toUTF8String(input, 0, 2);
    const type2 = PNMTypes[signature];
    const lines = toUTF8String(input, 3).split(/[\r\n]+/);
    const handler = handlers$1[type2] || handlers$1.default;
    return handler(lines);
  }
};
var PSD = {
  validate: (input) => toUTF8String(input, 0, 4) === "8BPS",
  calculate: (input) => ({
    height: readUInt32BE(input, 14),
    width: readUInt32BE(input, 18)
  })
};
var svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
var extractorRegExps = {
  height: /\sheight=(['"])([^%]+?)\1/,
  root: svgReg,
  viewbox: /\sviewBox=(['"])(.+?)\1/i,
  width: /\swidth=(['"])([^%]+?)\1/
};
var INCH_CM = 2.54;
var units = {
  in: 96,
  cm: 96 / INCH_CM,
  em: 16,
  ex: 8,
  m: 96 / INCH_CM * 100,
  mm: 96 / INCH_CM / 10,
  pc: 96 / 72 / 12,
  pt: 96 / 72,
  px: 1
};
var unitsReg = new RegExp(
  `^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`
);
function parseLength(len) {
  const m = unitsReg.exec(len);
  if (!m) {
    return void 0;
  }
  return Math.round(Number(m[1]) * (units[m[2]] || 1));
}
function parseViewbox(viewbox) {
  const bounds = viewbox.split(" ");
  return {
    height: parseLength(bounds[3]),
    width: parseLength(bounds[2])
  };
}
function parseAttributes(root2) {
  const width = root2.match(extractorRegExps.width);
  const height = root2.match(extractorRegExps.height);
  const viewbox = root2.match(extractorRegExps.viewbox);
  return {
    height: height && parseLength(height[2]),
    viewbox: viewbox && parseViewbox(viewbox[2]),
    width: width && parseLength(width[2])
  };
}
function calculateByDimensions(attrs) {
  return {
    height: attrs.height,
    width: attrs.width
  };
}
function calculateByViewbox(attrs, viewbox) {
  const ratio = viewbox.width / viewbox.height;
  if (attrs.width) {
    return {
      height: Math.floor(attrs.width / ratio),
      width: attrs.width
    };
  }
  if (attrs.height) {
    return {
      height: attrs.height,
      width: Math.floor(attrs.height * ratio)
    };
  }
  return {
    height: viewbox.height,
    width: viewbox.width
  };
}
var SVG = {
  // Scan only the first kilo-byte to speed up the check on larger files
  validate: (input) => svgReg.test(toUTF8String(input, 0, 1e3)),
  calculate(input) {
    const root2 = toUTF8String(input).match(extractorRegExps.root);
    if (root2) {
      const attrs = parseAttributes(root2[0]);
      if (attrs.width && attrs.height) {
        return calculateByDimensions(attrs);
      }
      if (attrs.viewbox) {
        return calculateByViewbox(attrs, attrs.viewbox);
      }
    }
    throw new TypeError("Invalid SVG");
  }
};
var TGA = {
  validate(input) {
    return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;
  },
  calculate(input) {
    return {
      height: readUInt16LE(input, 14),
      width: readUInt16LE(input, 12)
    };
  }
};
var CONSTANTS = {
  TAG: {
    WIDTH: 256,
    HEIGHT: 257,
    COMPRESSION: 259
  },
  TYPE: {
    SHORT: 3,
    LONG: 4,
    LONG8: 16
  },
  ENTRY_SIZE: {
    STANDARD: 12,
    BIG: 20
  },
  COUNT_SIZE: {
    STANDARD: 2,
    BIG: 8
  }
};
function readIFD(input, { isBigEndian, isBigTiff }) {
  const ifdOffset = isBigTiff ? Number(readUInt64(input, 8, isBigEndian)) : readUInt(input, 32, 4, isBigEndian);
  const entryCountSize = isBigTiff ? CONSTANTS.COUNT_SIZE.BIG : CONSTANTS.COUNT_SIZE.STANDARD;
  return input.slice(ifdOffset + entryCountSize);
}
function readTagValue(input, type2, offset, isBigEndian) {
  switch (type2) {
    case CONSTANTS.TYPE.SHORT:
      return readUInt(input, 16, offset, isBigEndian);
    case CONSTANTS.TYPE.LONG:
      return readUInt(input, 32, offset, isBigEndian);
    case CONSTANTS.TYPE.LONG8: {
      const value = Number(readUInt64(input, offset, isBigEndian));
      if (value > Number.MAX_SAFE_INTEGER) {
        throw new TypeError("Value too large");
      }
      return value;
    }
    default:
      return 0;
  }
}
function nextTag(input, isBigTiff) {
  const entrySize = isBigTiff ? CONSTANTS.ENTRY_SIZE.BIG : CONSTANTS.ENTRY_SIZE.STANDARD;
  if (input.length > entrySize) {
    return input.slice(entrySize);
  }
}
function extractTags(input, { isBigEndian, isBigTiff }) {
  const tags = {};
  let temp = input;
  while (temp?.length) {
    const code = readUInt(temp, 16, 0, isBigEndian);
    const type2 = readUInt(temp, 16, 2, isBigEndian);
    const length = isBigTiff ? Number(readUInt64(temp, 4, isBigEndian)) : readUInt(temp, 32, 4, isBigEndian);
    if (code === 0) break;
    if (length === 1 && (type2 === CONSTANTS.TYPE.SHORT || type2 === CONSTANTS.TYPE.LONG || isBigTiff && type2 === CONSTANTS.TYPE.LONG8)) {
      const valueOffset = isBigTiff ? 12 : 8;
      tags[code] = readTagValue(temp, type2, valueOffset, isBigEndian);
    }
    temp = nextTag(temp, isBigTiff);
  }
  return tags;
}
function determineFormat(input) {
  const signature = toUTF8String(input, 0, 2);
  const version2 = readUInt(input, 16, 2, signature === "MM");
  return {
    isBigEndian: signature === "MM",
    isBigTiff: version2 === 43
  };
}
function validateBigTIFFHeader(input, isBigEndian) {
  const byteSize = readUInt(input, 16, 4, isBigEndian);
  const reserved = readUInt(input, 16, 6, isBigEndian);
  if (byteSize !== 8 || reserved !== 0) {
    throw new TypeError("Invalid BigTIFF header");
  }
}
var signatures = /* @__PURE__ */ new Set([
  "49492a00",
  // Little Endian
  "4d4d002a",
  // Big Endian
  "49492b00",
  // BigTIFF Little Endian
  "4d4d002b"
  // BigTIFF Big Endian
]);
var TIFF = {
  validate: (input) => {
    const signature = toHexString(input, 0, 4);
    return signatures.has(signature);
  },
  calculate(input) {
    const format = determineFormat(input);
    if (format.isBigTiff) {
      validateBigTIFFHeader(input, format.isBigEndian);
    }
    const ifdBuffer = readIFD(input, format);
    const tags = extractTags(ifdBuffer, format);
    const info = {
      height: tags[CONSTANTS.TAG.HEIGHT],
      width: tags[CONSTANTS.TAG.WIDTH],
      type: format.isBigTiff ? "bigtiff" : "tiff"
    };
    if (tags[CONSTANTS.TAG.COMPRESSION]) {
      info.compression = tags[CONSTANTS.TAG.COMPRESSION];
    }
    if (!info.width || !info.height) {
      throw new TypeError("Invalid Tiff. Missing tags");
    }
    return info;
  }
};
function calculateExtended(input) {
  return {
    height: 1 + readUInt24LE(input, 7),
    width: 1 + readUInt24LE(input, 4)
  };
}
function calculateLossless(input) {
  return {
    height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),
    width: 1 + ((input[2] & 63) << 8 | input[1])
  };
}
function calculateLossy(input) {
  return {
    height: readInt16LE(input, 8) & 16383,
    width: readInt16LE(input, 6) & 16383
  };
}
var WEBP = {
  validate(input) {
    const riffHeader = "RIFF" === toUTF8String(input, 0, 4);
    const webpHeader = "WEBP" === toUTF8String(input, 8, 12);
    const vp8Header = "VP8" === toUTF8String(input, 12, 15);
    return riffHeader && webpHeader && vp8Header;
  },
  calculate(_input) {
    const chunkHeader = toUTF8String(_input, 12, 16);
    const input = _input.slice(20, 30);
    if (chunkHeader === "VP8X") {
      const extendedHeader = input[0];
      const validStart = (extendedHeader & 192) === 0;
      const validEnd = (extendedHeader & 1) === 0;
      if (validStart && validEnd) {
        return calculateExtended(input);
      }
      throw new TypeError("Invalid WebP");
    }
    if (chunkHeader === "VP8 " && input[0] !== 47) {
      return calculateLossy(input);
    }
    const signature = toHexString(input, 3, 6);
    if (chunkHeader === "VP8L" && signature !== "9d012a") {
      return calculateLossless(input);
    }
    throw new TypeError("Invalid WebP");
  }
};
var typeHandlers = /* @__PURE__ */ new Map([
  ["bmp", BMP],
  ["cur", CUR],
  ["dds", DDS],
  ["gif", GIF],
  ["heif", HEIF],
  ["icns", ICNS],
  ["ico", ICO],
  ["j2c", J2C],
  ["jp2", JP2],
  ["jpg", JPG],
  ["jxl", JXL],
  ["jxl-stream", JXLStream],
  ["ktx", KTX],
  ["png", PNG],
  ["pnm", PNM],
  ["psd", PSD],
  ["svg", SVG],
  ["tga", TGA],
  ["tiff", TIFF],
  ["webp", WEBP]
]);
var types = Array.from(typeHandlers.keys());
var firstBytes = /* @__PURE__ */ new Map([
  [0, "heif"],
  [56, "psd"],
  [66, "bmp"],
  [68, "dds"],
  [71, "gif"],
  [73, "tiff"],
  [77, "tiff"],
  [82, "webp"],
  [105, "icns"],
  [137, "png"],
  [255, "jpg"]
]);
function detector(input) {
  const byte = input[0];
  const type2 = firstBytes.get(byte);
  if (type2 && typeHandlers.get(type2).validate(input)) {
    return type2;
  }
  return types.find((type22) => typeHandlers.get(type22).validate(input));
}
var globalOptions = {
  disabledTypes: []
};
function imageSize(input) {
  const type2 = detector(input);
  if (typeof type2 !== "undefined") {
    if (globalOptions.disabledTypes.indexOf(type2) > -1) {
      throw new TypeError(`disabled file type: ${type2}`);
    }
    const size = typeHandlers.get(type2).calculate(input);
    if (size !== void 0) {
      size.type = size.type ?? type2;
      if (size.images && size.images.length > 1) {
        const largestImage = size.images.reduce((largest, current) => {
          return current.width * current.height > largest.width * largest.height ? current : largest;
        }, size.images[0]);
        size.width = largestImage.width;
        size.height = largestImage.height;
      }
      return size;
    }
  }
  throw new TypeError(`unsupported file type: ${type2}`);
}
var MaxInputSize = 512 * 1024;
var queue = [];
var concurrency = 100;
var processQueue = async () => {
  const jobs = queue.splice(0, concurrency);
  const promises2 = jobs.map(async ({ filePath, resolve: resolve2, reject }) => {
    let handle;
    try {
      handle = await fs.promises.open(path.resolve(filePath), "r");
    } catch (err) {
      return reject(err);
    }
    try {
      const { size } = await handle.stat();
      if (size <= 0) {
        throw new Error("Empty file");
      }
      const inputSize = Math.min(size, MaxInputSize);
      const input = new Uint8Array(inputSize);
      await handle.read(input, 0, inputSize, 0);
      resolve2(imageSize(input));
    } catch (err) {
      reject(err);
    } finally {
      await handle.close();
    }
  });
  await Promise.allSettled(promises2);
  if (queue.length) setTimeout(processQueue, 100);
};
var imageSizeFromFile = async (filePath) => new Promise((resolve2, reject) => {
  queue.push({ filePath, resolve: resolve2, reject });
  processQueue();
});
function checkFileReceived(path2, timeout2 = 3e3) {
  return new Promise((resolve2, reject) => {
    const startTime = Date.now();
    function check() {
      if (fs__default.existsSync(path2)) {
        resolve2();
      } else if (Date.now() - startTime > timeout2) {
        reject(new Error(`: ${path2}`));
      } else {
        setTimeout(check, 200);
      }
    }
    check();
  });
}
function calculateFileMD5(filePath) {
  return new Promise((resolve2, reject) => {
    const hash = createHash("md5");
    const stream = fs__default.createReadStream(filePath);
    stream.on("data", (data) => {
      hash.update(data);
    });
    stream.on("end", () => {
      const md5 = hash.digest("hex");
      resolve2(md5);
    });
    stream.on("error", (err) => {
      reject(err);
    });
  });
}
function checkUriType(uri2) {
  if (uri2.startsWith("base64://")) {
    return {
      type: 3
      /* OneBotBase64 */
    };
  }
  if (uri2.startsWith("data:")) {
    return {
      type: 4
      /* DataURL */
    };
  }
  if (uri2.startsWith("http://") || uri2.startsWith("https://")) {
    return {
      type: 2
      /* RemoteURL */
    };
  }
  if (uri2.startsWith("file://")) {
    return {
      type: 1
      /* FileURL */
    };
  }
  try {
    if (fs__default.existsSync(uri2)) return {
      type: 5
      /* Path */
    };
  } catch {
  }
  return {
    type: 0
    /* Unknown */
  };
}
async function fetchFile(url, headersInit) {
  const headers = new Headers({
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36",
    "Host": new URL(url).hostname,
    ...headersInit
  });
  let raw = await fetch(url, { headers }).catch((err) => {
    if (err.cause) {
      throw err.cause;
    }
    throw err;
  });
  if (raw.status === 403 && !headers.has("Referer")) {
    headers.set("Referer", url);
    raw = await fetch(url, { headers }).catch((err) => {
      if (err.cause) {
        throw err.cause;
      }
      throw err;
    });
  }
  if (!raw.ok) throw new Error(`statusText: ${raw.statusText}`);
  return {
    data: Buffer.from(await raw.arrayBuffer()),
    url: raw.url
  };
}
async function uri2local(ctx, uri2, needExt) {
  const { type: type2 } = checkUriType(uri2);
  if (type2 === 1) {
    const filePath = fileURLToPath(uri2);
    const fileName = path__default.basename(filePath);
    return { success: true, errMsg: "", fileName, path: filePath, isLocal: true };
  }
  if (type2 === 5) {
    const fileName = path__default.basename(uri2);
    return { success: true, errMsg: "", fileName, path: uri2, isLocal: true };
  }
  if (type2 === 2) {
    try {
      const res = await fetchFile(uri2);
      let fileName = randomUUID();
      let filePath = path__default.join(TEMP_DIR, fileName);
      await fsPromise.writeFile(filePath, res.data);
      if (needExt) {
        const ext = (await ctx.ntFileApi.getFileType(filePath)).ext;
        fileName += `.${ext}`;
        const newPath = `${filePath}.${ext}`;
        await fsPromise.rename(filePath, newPath);
        filePath = newPath;
      }
      return { success: true, errMsg: "", fileName, path: filePath, isLocal: false };
    } catch (e) {
      const errMsg = `${uri2} , ${e.message}`;
      return { success: false, errMsg, fileName: "", path: "", isLocal: false };
    }
  }
  if (type2 === 3) {
    let filename = randomUUID();
    let filePath = path__default.join(TEMP_DIR, filename);
    const base642 = uri2.replace(/^base64:\/\//, "");
    await fsPromise.writeFile(filePath, base642, "base64");
    if (needExt) {
      const ext = (await ctx.ntFileApi.getFileType(filePath)).ext;
      filename += `.${ext}`;
      await fsPromise.rename(filePath, `${filePath}.${ext}`);
      filePath = `${filePath}.${ext}`;
    }
    return { success: true, errMsg: "", fileName: filename, path: filePath, isLocal: false };
  }
  if (type2 === 4) {
    const capture = /^data:([\w/.+-]+);base64,(.*)$/.exec(uri2);
    if (capture) {
      let filename = randomUUID();
      const [, _type, base642] = capture;
      let filePath = path__default.join(TEMP_DIR, filename);
      await fsPromise.writeFile(filePath, base642, "base64");
      if (needExt) {
        const ext = (await ctx.ntFileApi.getFileType(filePath)).ext;
        filename += `.${ext}`;
        await fsPromise.rename(filePath, `${filePath}.${ext}`);
        filePath = `${filePath}.${ext}`;
      }
      return { success: true, errMsg: "", fileName: filename, path: filePath, isLocal: false };
    }
  }
  if (type2 === 0) {
    let fileCache = await ctx.store.getFileCacheById(uri2);
    if (!fileCache?.length) {
      fileCache = await ctx.store.getFileCacheByName(uri2);
    }
    if (fileCache?.length) {
      const downloadPath = await ctx.ntFileApi.downloadMedia(
        fileCache[0].msgId,
        fileCache[0].chatType,
        fileCache[0].peerUid,
        fileCache[0].elementId,
        "",
        ""
      );
      return { success: true, errMsg: "", fileName: fileCache[0].fileName, path: downloadPath, isLocal: true };
    }
  }
  return { success: false, errMsg: "", fileName: "", path: "", isLocal: false };
}
async function getFileType(filePath) {
  try {
    const type2 = await fileType.fileTypeFromFile(filePath);
    if (!type2) {
      return {
        mime: "application/octet-stream",
        ext: path__default.extname(filePath).slice(0) || ""
      };
    }
    return {
      mime: type2.mime,
      ext: type2.ext
    };
  } catch (error) {
    console.error("Error detecting file type:", error);
    return {
      mime: "",
      ext: ""
    };
  }
}
async function getImageSize(path2) {
  return await imageSizeFromFile(path2);
}
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
var unicode = {
  Space_Separator,
  ID_Start,
  ID_Continue
};
var util = {
  isSpaceSeparator(c2) {
    return typeof c2 === "string" && unicode.Space_Separator.test(c2);
  },
  isIdStartChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
  },
  isIdContinueChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "" || c2 === "" || unicode.ID_Continue.test(c2));
  },
  isDigit(c2) {
    return typeof c2 === "string" && /[0-9]/.test(c2);
  },
  isHexDigit(c2) {
    return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
  }
};
let source;
let parseState;
let stack;
let pos;
let line;
let column;
let token;
let key;
let root;
var parse = function parse2(text, reviver) {
  source = String(text);
  parseState = "start";
  stack = [];
  pos = 0;
  line = 1;
  column = 0;
  token = void 0;
  key = void 0;
  root = void 0;
  do {
    token = lex();
    parseStates[parseState]();
  } while (token.type !== "eof");
  if (typeof reviver === "function") {
    return internalize({ "": root }, "", reviver);
  }
  return root;
};
function internalize(holder, name, reviver) {
  const value = holder[name];
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const key2 = String(i);
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    } else {
      for (const key2 in value) {
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    }
  }
  return reviver.call(holder, name, value);
}
let lexState;
let buffer;
let doubleQuote;
let sign;
let c;
function lex() {
  lexState = "default";
  buffer = "";
  doubleQuote = false;
  sign = 1;
  for (; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2) {
      return token2;
    }
  }
}
function peek() {
  if (source[pos]) {
    return String.fromCodePoint(source.codePointAt(pos));
  }
}
function read() {
  const c2 = peek();
  if (c2 === "\n") {
    line++;
    column = 0;
  } else if (c2) {
    column += c2.length;
  } else {
    column++;
  }
  if (c2) {
    pos += c2.length;
  }
  return c2;
}
const lexStates = {
  default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "":
      case "\uFEFF":
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read();
        lexState = "comment";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    if (util.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineComment";
        return;
      case "/":
        read();
        lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read();
        lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
    lexState = "multiLineComment";
  },
  singleLineComment() {
    switch (c) {
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        lexState = "default";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    read();
  },
  value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        read();
        literal("ull");
        return newToken("null", null);
      case "t":
        read();
        literal("rue");
        return newToken("boolean", true);
      case "f":
        read();
        literal("alse");
        return newToken("boolean", false);
      case "-":
      case "+":
        if (read() === "-") {
          sign = -1;
        }
        lexState = "sign";
        return;
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"';
        buffer = "";
        lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
        break;
      default:
        if (!util.isIdStartChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "":
      case "":
        buffer += read();
        return;
      case "\\":
        read();
        lexState = "identifierNameEscape";
        return;
    }
    if (util.isIdContinueChar(c)) {
      buffer += read();
      return;
    }
    return newToken("identifier", buffer);
  },
  identifierNameEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
      case "":
      case "":
        break;
      default:
        if (!util.isIdContinueChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  sign() {
    switch (c) {
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", sign * Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer += read();
        lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", sign * 0);
  },
  decimalInteger() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalPointLeading() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer += read();
        lexState = "decimalExponentSign";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  hexadecimal() {
    if (util.isHexDigit(c)) {
      buffer += read();
      lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util.isHexDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  string() {
    switch (c) {
      case "\\":
        read();
        buffer += escape$1();
        return;
      case '"':
        if (doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "'":
        if (!doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "\n":
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer += read();
  },
  start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer = read();
        lexState = "identifierName";
        return;
      case "\\":
        read();
        lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"';
        lexState = "string";
        return;
    }
    if (util.isIdStartChar(c)) {
      buffer += read();
      lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ":") {
      return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = "value";
  },
  afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === "]") {
      return newToken("punctuator", read());
    }
    lexState = "value";
  },
  afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  }
};
function newToken(type2, value) {
  return {
    type: type2,
    value,
    line,
    column
  };
}
function literal(s) {
  for (const c2 of s) {
    const p = peek();
    if (p !== c2) {
      throw invalidChar(read());
    }
    read();
  }
}
function escape$1() {
  const c2 = peek();
  switch (c2) {
    case "b":
      read();
      return "\b";
    case "f":
      read();
      return "\f";
    case "n":
      read();
      return "\n";
    case "r":
      read();
      return "\r";
    case "t":
      read();
      return "	";
    case "v":
      read();
      return "\v";
    case "0":
      read();
      if (util.isDigit(peek())) {
        throw invalidChar(read());
      }
      return "\0";
    case "x":
      read();
      return hexEscape();
    case "u":
      read();
      return unicodeEscape();
    case "\n":
    case "\u2028":
    case "\u2029":
      read();
      return "";
    case "\r":
      read();
      if (peek() === "\n") {
        read();
      }
      return "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "";
  let c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "";
  let count = 4;
  while (count-- > 0) {
    const c2 = peek();
    if (!util.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
const parseStates = {
  start() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value;
        parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    parseState = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforeArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end() {
  }
};
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0) {
    root = value;
  } else {
    const parent = stack[stack.length - 1];
    if (Array.isArray(parent)) {
      parent.push(value);
    } else {
      Object.defineProperty(parent, key, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  if (value !== null && typeof value === "object") {
    stack.push(value);
    if (Array.isArray(value)) {
      parseState = "beforeArrayValue";
    } else {
      parseState = "beforePropertyName";
    }
  } else {
    const current = stack[stack.length - 1];
    if (current == null) {
      parseState = "end";
    } else if (Array.isArray(current)) {
      parseState = "afterArrayValue";
    } else {
      parseState = "afterPropertyValue";
    }
  }
}
function pop() {
  stack.pop();
  const current = stack[stack.length - 1];
  if (current == null) {
    parseState = "end";
  } else if (Array.isArray(current)) {
    parseState = "afterArrayValue";
  } else {
    parseState = "afterPropertyValue";
  }
}
function invalidChar(c2) {
  if (c2 === void 0) {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
  }
  return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
function invalidIdentifier() {
  column -= 5;
  return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2]) {
    return replacements[c2];
  }
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  const err = new SyntaxError(message);
  err.lineNumber = line;
  err.columnNumber = column;
  return err;
}
var stringify = function stringify2(value, replacer, space) {
  const stack2 = [];
  let indent = "";
  let propertyList;
  let replacerFunc;
  let gap = "";
  let quote;
  if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
    space = replacer.space;
    quote = replacer.quote;
    replacer = replacer.replacer;
  }
  if (typeof replacer === "function") {
    replacerFunc = replacer;
  } else if (Array.isArray(replacer)) {
    propertyList = [];
    for (const v of replacer) {
      let item;
      if (typeof v === "string") {
        item = v;
      } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
        item = String(v);
      }
      if (item !== void 0 && propertyList.indexOf(item) < 0) {
        propertyList.push(item);
      }
    }
  }
  if (space instanceof Number) {
    space = Number(space);
  } else if (space instanceof String) {
    space = String(space);
  }
  if (typeof space === "number") {
    if (space > 0) {
      space = Math.min(10, Math.floor(space));
      gap = "          ".substr(0, space);
    }
  } else if (typeof space === "string") {
    gap = space.substr(0, 10);
  }
  return serializeProperty("", { "": value });
  function serializeProperty(key2, holder) {
    let value2 = holder[key2];
    if (value2 != null) {
      if (typeof value2.toJSON5 === "function") {
        value2 = value2.toJSON5(key2);
      } else if (typeof value2.toJSON === "function") {
        value2 = value2.toJSON(key2);
      }
    }
    if (replacerFunc) {
      value2 = replacerFunc.call(holder, key2, value2);
    }
    if (value2 instanceof Number) {
      value2 = Number(value2);
    } else if (value2 instanceof String) {
      value2 = String(value2);
    } else if (value2 instanceof Boolean) {
      value2 = value2.valueOf();
    }
    switch (value2) {
      case null:
        return "null";
      case true:
        return "true";
      case false:
        return "false";
    }
    if (typeof value2 === "string") {
      return quoteString(value2);
    }
    if (typeof value2 === "number") {
      return String(value2);
    }
    if (typeof value2 === "object") {
      return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
    }
    return void 0;
  }
  function quoteString(value2) {
    const quotes = {
      "'": 0.1,
      '"': 0.2
    };
    const replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let product = "";
    for (let i = 0; i < value2.length; i++) {
      const c2 = value2[i];
      switch (c2) {
        case "'":
        case '"':
          quotes[c2]++;
          product += c2;
          continue;
        case "\0":
          if (util.isDigit(value2[i + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[c2]) {
        product += replacements[c2];
        continue;
      }
      if (c2 < " ") {
        let hexString = c2.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += c2;
    }
    const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
    product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
    return quoteChar + product + quoteChar;
  }
  function serializeObject(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let keys = propertyList || Object.keys(value2);
    let partial = [];
    for (const key2 of keys) {
      const propertyString = serializeProperty(key2, value2);
      if (propertyString !== void 0) {
        let member = serializeKey(key2) + ":";
        if (gap !== "") {
          member += " ";
        }
        member += propertyString;
        partial.push(member);
      }
    }
    let final;
    if (partial.length === 0) {
      final = "{}";
    } else {
      let properties;
      if (gap === "") {
        properties = partial.join(",");
        final = "{" + properties + "}";
      } else {
        let separator = ",\n" + indent;
        properties = partial.join(separator);
        final = "{\n" + indent + properties + ",\n" + stepback + "}";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
  function serializeKey(key2) {
    if (key2.length === 0) {
      return quoteString(key2);
    }
    const firstChar = String.fromCodePoint(key2.codePointAt(0));
    if (!util.isIdStartChar(firstChar)) {
      return quoteString(key2);
    }
    for (let i = firstChar.length; i < key2.length; i++) {
      if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i)))) {
        return quoteString(key2);
      }
    }
    return key2;
  }
  function serializeArray(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let partial = [];
    for (let i = 0; i < value2.length; i++) {
      const propertyString = serializeProperty(String(i), value2);
      partial.push(propertyString !== void 0 ? propertyString : "null");
    }
    let final;
    if (partial.length === 0) {
      final = "[]";
    } else {
      if (gap === "") {
        let properties = partial.join(",");
        final = "[" + properties + "]";
      } else {
        let separator = ",\n" + indent;
        let properties = partial.join(separator);
        final = "[\n" + indent + properties + ",\n" + stepback + "]";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
};
const JSON5 = {
  parse,
  stringify
};
var lib = JSON5;
class ConfigUtil {
  configPath;
  config = null;
  watch = false;
  constructor(configPath) {
    this.configPath = configPath;
  }
  listenChange(cb) {
    console.log("", this.configPath);
    this.setConfig(this.getConfig());
    fs__default.watchFile(this.configPath, { persistent: true, interval: 1e3 }, () => {
      if (!this.watch) {
        return;
      }
      console.log("");
      const c2 = this.reloadConfig();
      cb(c2);
    });
  }
  getConfig(cache = true) {
    if (this.config && cache) {
      return this.config;
    }
    return this.reloadConfig();
  }
  reloadConfig() {
    const ob11Default = {
      enable: true,
      token: "",
      httpPort: 3e3,
      httpPostUrls: [],
      httpSecret: "",
      wsPort: 3001,
      wsReverseUrls: [],
      enableHttp: true,
      enableHttpPost: true,
      enableWs: true,
      enableWsReverse: true,
      messagePostFormat: "array",
      enableHttpHeart: false,
      reportSelfMessage: false
    };
    const satoriDefault = {
      enable: false,
      port: 5600,
      token: ""
    };
    const webuiDefault = {
      enable: true,
      port: 3080,
      token: ""
    };
    const defaultConfig = {
      webui: webuiDefault,
      onlyLocalhost: true,
      satori: satoriDefault,
      ob11: ob11Default,
      heartInterval: 6e4,
      enableLocalFile2Url: false,
      debug: false,
      log: true,
      autoDeleteFile: false,
      autoDeleteFileSecond: 60,
      musicSignUrl: "https://llob.linyuchen.net/sign/music",
      msgCacheExpire: 120,
      ffmpeg: ""
    };
    if (!fs__default.existsSync(this.configPath)) {
      const defaultConfigPath = path__default.join(path__default.dirname(fileURLToPath(import.meta.url)), "default_config.json");
      const defaultConfigData = fs__default.readFileSync(defaultConfigPath, "utf-8");
      try {
        this.config = lib.parse(defaultConfigData);
      } catch (e) {
        console.error(" default_config.json ");
        this.config = defaultConfig;
      }
      this.setConfig(this.config);
      return this.config;
    } else {
      const data = fs__default.readFileSync(this.configPath, "utf-8");
      let jsonData = defaultConfig;
      try {
        jsonData = lib.parse(data);
        console.info("");
      } catch (e) {
        console.error(`${this.configPath} json `, e);
        this.config = defaultConfig;
        return this.config;
      }
      mergeNewProperties(defaultConfig, jsonData);
      this.checkOldConfig(jsonData.ob11, jsonData.ob11, "wsReverseUrls", "wsHosts");
      this.checkOldConfig(jsonData.ob11, jsonData.ob11, "httpPostUrls", "httpHosts");
      this.checkOldConfig(jsonData, jsonData.ob11, "onlyLocalhost", "listenLocalhost");
      this.setConfig(jsonData);
      this.config = jsonData;
      return this.config;
    }
  }
  setConfig(config) {
    this.config = config;
    this.writeConfig(config);
  }
  writeConfig(config, watch = false) {
    this.watch = watch;
    fs__default.writeFileSync(this.configPath, JSON.stringify(config, null, 2), "utf-8");
    setTimeout(() => {
      this.watch = true;
    }, 3e3);
  }
  checkOldConfig(currentConfig, oldConfig, currentKey, oldKey) {
    const oldValue = oldConfig[oldKey];
    if (oldValue !== void 0) {
      Object.assign(currentConfig, { [currentKey]: oldValue });
      delete oldConfig[oldKey];
    }
  }
}
let globalConfigUtil = null;
function getConfigUtil() {
  const configFilePath = path__default.join(DATA_DIR, `config_${selfInfo.uin}.json`);
  if (!globalConfigUtil) {
    globalConfigUtil = new ConfigUtil(configFilePath);
  }
  return globalConfigUtil;
}
const logFileName = `llonebot-${(/* @__PURE__ */ new Date()).toLocaleString("zh-CN")}.log`.replace(/\//g, "-").replace(/:/g, "-");
const defaultVideoThumbB64 = "/9j/4AAQSkZJRgABAQAAAQABAAD//gAXR2VuZXJhdGVkIGJ5IFNuaXBhc3Rl/9sAhAAKBwcIBwYKCAgICwoKCw4YEA4NDQ4dFRYRGCMfJSQiHyIhJis3LyYpNCkhIjBBMTQ5Oz4+PiUuRElDPEg3PT47AQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAF/APADAREAAhEBAxEB/8QBogAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoLEAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+foBAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKCxEAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDiAayNxwagBwNAC5oAM0xBmgBM0ANJoAjY0AQsaBkTGgCM0DEpAFAC0AFMBaACgAoEJTASgQlACUwCgQ4UAOFADhQA4UAOFADxQIkBqDQUGgBwagBQaBC5pgGaAELUAMLUARs1AETGgBhNAxhoASkAUALQIKYxaBBQAUwEoAQ0CEoASmAUAOoEKKAHCgBwoAeKAHigQ7NZmoZpgLmgBd1Ahd1ABupgNLUAMLUAMY0AMJoAYaAENACUCCgAoAWgAoAWgBKYCUAJQISgApgLQAooEOFACigB4oAeKBDxQAVmaiZpgGaAFzQAbqAE3UAIWpgNJoAYTQIaaAEoAQ0CEoASgBaACgBaACmAUAJQAlAgoAKYC0AKKBCigB4FADgKBDwKAHigBuazNRM0DEzTAM0AJmgAzQAhNAhpNACGmA2gQlACUCEoAKACgBaAFpgFACUAJQAUCCmAUALQIcBQA4CgB4FADgKBDhQA4UAMzWZqNzTGJQAZoATNABmgBKAEoEIaYCUCEoASgQlABQAtABQAtMBKACgAoEFABimAYoEKBQA4CgB4FADwKBDgKAFFADhQBCazNhKAEpgFACUAFACUAFAhDTAbQISgAoEJQAUALQAtMAoAKADFABigQYoAMUALimIUCgBwFAh4FADgKAHUALQAtAENZmwlACUwEoAKAEoAKACgQlMBpoEJQAUCCgBcUAFABTAXFAC4oAMUAGKBBigAxQIKYCigQ8UAOFADhQAtAC0ALQBDWZqJQMSgBKYBQAlABQISgBKYCGgQlAC0CCgBcUAFABTAUCkA7FMAxQAYoEJQAUCCmAooEOFADxQA4UAFAC0ALQBDWZqJQAlACUxhQAlABQIKAEoASmISgBcUCCgBaACgBcUAKBQAuKYC0CEoAQ0AJQISmAooEPFADhQA4UALQAtAC0AQ1maiUAFACUAJTAKAEoAKAEoAMUxBigAxQIWgAoAKAFAoAWgBaYBQIQ0ANNACUCCmIUUAOFADxQA4UALQAtABQBFWZqFACUAFACYpgFACUAFACUAFAgxTEFABQAUALQAooAWgAoAKYDTQIaaAEpiCgQ4UAOFAh4oGOFAC0ALSAKYEdZmglABQAUDDFACUwEoASgAoAKBBQIKYBQAUALQAtAC0AJQAhpgNJoENJoATNMQCgQ8UCHigB4oAWgYtABQAUAMrM0CgAoAKADFACUxiUAJQAlAgoAKYgoAKACgYtAC0AFAhDTAQmgBhNAhpNACZpiFBoEPFAEi0CHigB1ABQAUDEoAbWZoFABQAtABTAQ0ANNAxDQAlAhaAEpiCgAoGFAC0AFABmgBCaYhpNADCaBDSaBBmgABpiJFNAEimgB4NADqAFzQAlACE0AJWZoFAC0AFAC0wEIoAaaAG0AJQAUCCgApjCgAoAKADNABmgBpNMQ0mgBpNAhhNAgzQAoNADwaAHqaAJAaBDgaYC5oATNACZoAWszQKACgBaBDqYCGgBpoAYaBiUCCgBKYBQMKACgAoAM0AITQIaTQA0mmA0mgQ3NAhKAHCgBwNADwaAHg0AOBpiFzQAZoATNAD6zNAoAKAFoEOpgBoAaaAGGmAw0AJmgAzQMM0AGaADNABmgBM0AITQIaTQAhNMQw0AJQIKAFFADhQA4GgBwNADs0xC5oAM0CDNAEtZmoUCCgBaAHUwCgBppgRtQAw0ANzQAZoAM0AGaADNABmgBKAEoAQ0ANNMQhoEJQAlMBaQDgaAFBoAcDTAdmgQuaADNAgzQBPWZqFAgoAWgBaYC0CGmmBG1AyM0ANJoATNACZoAXNABmgAzQAUAJQAhoAQ0xDTQISmAUALQAUgHA0AKDTAdmgQuaBBQAtAFiszQKACgBaAFFMAoEIaYEbUDI2oAYaAEoASgAzQAuaACgAoAKAENMQ00AJTEFAhKACgAoAXNACg0AOBoAWgQtAC0AWazNAoAKACgBaYBQIQ0AMNMYw0AMIoAbQAlMAoAKACgAzSAKYhKAENACUxBQIKACgBKACgBaAHCgQ4UALQAUAWqzNAoAKACgApgFACGgQ00xjTQAwigBCKAG4pgJQAlABQAUCCgBKACgBKYgoEFABQISgAoAWgBRQA4UALQAUCLdZmoUAFABQAlMAoASgBDQA00wENACYoATFMBpFADSKAEoEJQAUAFABQAlMQtAgoASgQUAJQAUAKKAHCgBaBBQBbrM1CgAoAKACmAUAJQAlADaYBQAlACYpgIRQA0igBpFAhtABQAUAFMAoEFABQIKAEoASgQUALQAooAWgQUAW81mbC0CCgApgFACUAIaAEpgJQAUAFABQAhFMBpFADSKAGkUCExQAYoAMUAGKADFMQYoAMUCExSATFABQIKYBQAtABQIt5qDYM0ALmgQtIApgIaAENADaACmAlAC0ALQAUwGkUANIoAaRQAmKBBigAxQAYoAMUAGKBBigBMUAJigQmKAExTAKBC0AFAFnNQaig0AKDQAtAgoASgBDQAlMBKACgAFADhQAtMBCKAGkUAIRQAmKADFABigQmKADFACYoAXFABigQmKAExQAmKBCYpgJigAoAnzUGgZoAcDQAuaBC0AJQAhoASmAlABQAtADhQAtMAoATFACEUAJigAxQAYoATFAhMUAFABQAuKADFABigBpWgBCKBCYpgJigB+ag0DNADgaBDgaAFzQITNACUAJTAKACgBRQAopgOoAWgBKAEoAKACgAoASgBpoEJQAooAWgBaBhigBMUCEIoAQigBMUAJSLCgBQaBDgaQC5oEFACUwCgBKACmAtADhQA4UALQAUAJQAUAJQAUAJQAhoENoAWgBRQAooGLQAUAGKAGkUAIRQIZSKEoGKKBDhQAUCCgAoAKBBQAUwFoGKKAHCgBaACgAoASgAoASgBCaAEoEJmgAoAUGgBQaAHZoGFABQAUANoAjpDEoAWgBaAFoEFACUALQAUCCmAUAOFAxRQAtAC0AJQAUAJQAmaBDSaAEzQAmaYBmgBQaAHA0gFzQAuaBhmgAzQAlAEdIYUALQAtAgoAKAEoEFAC0AFMAoAUUDFFAC0ALQAUAJQAhoENNACE0wEoATNABmgBc0ALmgBc0gDNAC5oATNABmgBKRQlACigB1AgoASgQlABTAWgBKACgBaBi0ALQAZoAM0AFACGgQ00wENACUAJQAUCFzQMM0ALmgAzQAZoAM0AGaQC0igoAUUALQIWgBDQISmAUAFACUAFABQAuaBi5oAM0AGaBBmgBKAEpgIaAG0AJQAUCFoAM0DDNAC5oATNABmgAzQBJUlBQAooAWgQtACGmIaaACgAoASgBKACgBc0DCgQUAGaADNABTASgBDQAlACUAFAgoAKBhQAUAFABQAlAE1SUFAxRQIWgQtMBDQIQ0AJQAlAhKBiUAFABmgBc0AGaADNABTAKACgBKAEoASgQlABQAUAFAC0AFACUAFAE1SaBQAUCHCgQtMBKBCUAJQISgBDQA00DEzQAuaADNMBc0AGaADNABQAUAJQAlABQISgAoAKACgBaACgBKAEoAnqTQSgBRQIcKBC0xCUAJQISgBKAENADDQAmaYwzQAuaADNAC0AFABQAUAFAhKACgBKACgAoAWgAoELQAlAxKAJqk0EoAWgQooELTEFADaBCUABoENNMY00ANNAwzQAZoAXNAC0AFAC0CFoASgAoASgBKACgAoAWgQtABQAUANNAyWpNAoAKBCimIWgQUCEoASmIQ0ANNADTQMaaAEoGLmgAzQAtADhQIWgBaACgQhoASgYlACUALQIWgBaACgBKAENAyWpNBKYBQIcKBC0CEoEJTAKBCUANNADDQMQ0ANoGFAC5oAUGgBwNAhRQIWgBaAENACGgBtAwoAKAFzQIXNABmgAoAQ0DJKRoJQAtAhRQSLQIKYCUCCgBDQA00AMNAxpoGNoAM0AGaAFBoAcDQIcKBDqACgBDQAhoAQ0DEoAKADNAC5oEGaBhmgAoAkpGgUCCgQooELQIKYhKACgBKAGmgBpoGMNAxDQAlAwzQIUUAOFAhwoAcKBC0AJQAhoGNNACUAFABQAZoAXNABQAUAS0ixKACgQoNAhaYgoEFACUABoAaaAGmgYw0DENAxtABQAooEOFADhQIcKAFoASgBDQAhoGJQAUAFACUALQIKBi0CJDSLEoATNAhc0CHZpiCgQUAJQIKBjTQAhoGNNAxpoATFABigBQKAHCgBwoAWgAoAKACgBKAEoASgAoASgBaAAUAOoEONIoaTQAZoAUGmIUGgQtAgzQISgAoAQ0DGmgYlAxKACgAxQAtACigBRQAtAxaACgAoATFABigBCKAG0CEoAWgBRTAUUAf//Z";
const defaultVideoThumb = Buffer.from(defaultVideoThumbB64, "base64");
async function getVideoInfo(filePath) {
  const size = fs__default.statSync(filePath).size;
  return new Promise((resolve2, reject) => {
    ffmpeg(filePath).ffprobe((err, metadata) => {
      if (err) {
        reject(err);
      } else {
        const videoStream = metadata.streams.find((s) => s.codec_type === "video");
        resolve2({
          width: videoStream?.width,
          height: videoStream?.height,
          time: parseInt(videoStream?.duration),
          format: metadata.format.format_name,
          size,
          filePath
        });
      }
    });
  });
}
function convert(ctx, input, options, outputPath) {
  return new Promise((resolve2, reject) => {
    const chunks = [];
    let command = ffmpeg(input).on("error", (err) => {
      ctx.logger.error(`FFmpeg: `, err.message);
      reject(err);
    }).on("end", () => {
      if (!outputPath) {
        resolve2(Buffer.concat(chunks));
      } else {
        resolve2(outputPath);
      }
    });
    if (options.input) {
      command = command.inputOptions(options.input);
    }
    if (options.output) {
      command = command.outputOptions(options.output);
    }
    if (!outputPath) {
      const stream = command.pipe();
      stream.on("data", (chunk) => {
        chunks.push(chunk);
      });
    } else {
      command.save(outputPath);
    }
  });
}
async function encodeSilk(ctx, filePath) {
  const file = await fsPromise.readFile(filePath);
  if (!isSilk(file)) {
    ctx.logger.info(`${filePath}silk`);
    let result;
    const allowSampleRate = [8e3, 12e3, 16e3, 24e3, 32e3, 44100, 48e3];
    if (isWav(file) && allowSampleRate.includes(getWavFileInfo(file).fmt.sampleRate)) {
      result = await encode(file, 0);
    } else {
      const input = await convert(ctx, filePath, {
        output: [
          "-ar 24000",
          "-ac 1",
          "-f s16le"
        ]
      });
      result = await encode(input, 24e3);
    }
    const pttPath = path__default.join(TEMP_DIR, randomUUID());
    await fsPromise.writeFile(pttPath, result.data);
    ctx.logger.info(`${filePath}!`, pttPath, `:`, result.duration);
    return {
      converted: true,
      path: pttPath,
      duration: result.duration / 1e3
    };
  } else {
    const silk = file;
    let duration = 1;
    try {
      duration = getDuration(silk) / 1e3;
    } catch (e) {
      ctx.logger.warn(", 1", filePath, e.stack);
    }
    return {
      converted: false,
      path: filePath,
      duration
    };
  }
}
async function decodeSilk(ctx, inputFilePath, outFormat) {
  const silk = await fsPromise.readFile(inputFilePath);
  const { data } = await decode(silk, 24e3);
  const tmpPath = path__default.join(TEMP_DIR, path__default.basename(inputFilePath));
  const outFilePath = tmpPath + `.${outFormat}`;
  const pcmFilePath = tmpPath + ".pcm";
  await fsPromise.writeFile(pcmFilePath, data);
  return convert(ctx, pcmFilePath, {
    input: [
      "-f s16le",
      "-ar 24000",
      "-ac 1"
    ]
  }, outFilePath);
}
var SendElement;
((SendElement2) => {
  function text(content) {
    return {
      elementType: ElementType.Text,
      elementId: "",
      textElement: {
        content,
        atType: AtType.Unknown,
        atUid: "",
        atTinyId: "",
        atNtUid: ""
      }
    };
  }
  SendElement2.text = text;
  function at(atUid, atNtUid, atType, display) {
    return {
      elementType: ElementType.Text,
      elementId: "",
      textElement: {
        content: display,
        atType,
        atUid,
        atTinyId: "",
        atNtUid
      }
    };
  }
  SendElement2.at = at;
  function reply(msgSeq, msgId, senderUin) {
    return {
      elementType: ElementType.Reply,
      elementId: "",
      replyElement: {
        replayMsgSeq: msgSeq,
        replayMsgId: msgId,
        senderUin,
        senderUinStr: senderUin
      }
    };
  }
  SendElement2.reply = reply;
  async function pic(ctx, picPath, summary = "", subType = 0, isFlashPic) {
    const { md5, fileName, path: path2, fileSize } = await ctx.ntFileApi.uploadFile(picPath, ElementType.Pic, subType);
    if (fileSize === 0) {
      throw " 0";
    }
    const imageSize2 = await ctx.ntFileApi.getImageSize(picPath);
    const picElement = {
      md5HexStr: md5,
      fileSize: fileSize.toString(),
      picWidth: imageSize2.width,
      picHeight: imageSize2.height,
      fileName,
      sourcePath: path2,
      original: true,
      picType: imageSize2.type === "gif" ? PicType.GIF : PicType.JPEG,
      picSubType: subType,
      fileUuid: "",
      fileSubId: "",
      thumbFileSize: 0,
      summary,
      isFlashPic
    };
    ctx.logger.info("", picElement);
    return {
      elementType: ElementType.Pic,
      elementId: "",
      picElement
    };
  }
  SendElement2.pic = pic;
  async function file(ctx, filePath, fileName, folderId = "") {
    const fileSize = (await stat(filePath)).size.toString();
    if (fileSize === "0") {
      ctx.logger.warn(`${fileName} 0`);
      throw new Error(" 0");
    }
    const element = {
      elementType: ElementType.File,
      elementId: "",
      fileElement: {
        fileName,
        folderId,
        filePath,
        fileSize
      }
    };
    return element;
  }
  SendElement2.file = file;
  async function video2(ctx, filePath, diyThumbPath = "") {
    await access(filePath);
    const { fileName, path: path2, fileSize, md5 } = await ctx.ntFileApi.uploadFile(filePath, ElementType.Video);
    if (fileSize === 0) {
      throw new Error(" 0");
    }
    const maxMB = 100;
    if (fileSize > 1024 * 1024 * maxMB) {
      throw new Error(`${maxMB}MB${fileSize}B`);
    }
    const thumbDir = path__default.dirname(path2.replaceAll("\\", "/").replace(`/Ori/`, `/Thumb/`));
    let videoInfo = {
      width: 1920,
      height: 1080,
      time: 15,
      format: "mp4",
      size: fileSize,
      filePath
    };
    try {
      videoInfo = await getVideoInfo(path2);
      ctx.logger.info("", videoInfo);
    } catch (e) {
      ctx.logger.info("", e);
    }
    const createThumb = new Promise((resolve2, reject) => {
      const thumbFileName = `${md5}_0.png`;
      const thumbPath2 = path__default.join(thumbDir, thumbFileName);
      ctx.logger.info("", filePath);
      let completed = false;
      function useDefaultThumb() {
        if (completed) return;
        ctx.logger.info("");
        writeFile(thumbPath2, defaultVideoThumb).then(() => {
          resolve2(thumbPath2);
        }).catch(reject);
      }
      setTimeout(useDefaultThumb, 5e3);
      ffmpeg(filePath).on("error", () => {
        if (diyThumbPath) {
          copyFile(diyThumbPath, thumbPath2).then(() => {
            completed = true;
            resolve2(thumbPath2);
          }).catch(reject);
        } else {
          useDefaultThumb();
        }
      }).screenshots({
        timestamps: [0],
        filename: thumbFileName,
        folder: thumbDir,
        size: videoInfo.width + "x" + videoInfo.height
      }).on("end", () => {
        completed = true;
        resolve2(thumbPath2);
      });
    });
    const thumbPath = /* @__PURE__ */ new Map();
    const _thumbPath = await createThumb;
    ctx.logger.info("", _thumbPath);
    const thumbSize = (await stat(_thumbPath)).size;
    thumbPath.set(0, _thumbPath);
    const thumbMd5 = await calculateFileMD5(_thumbPath);
    const element = {
      elementType: ElementType.Video,
      elementId: "",
      videoElement: {
        fileName,
        filePath: path2,
        videoMd5: md5,
        thumbMd5,
        fileTime: videoInfo.time,
        thumbPath,
        thumbSize,
        thumbWidth: videoInfo.width,
        thumbHeight: videoInfo.height,
        fileSize: String(fileSize)
      }
    };
    ctx.logger.info("videoElement", element);
    return element;
  }
  SendElement2.video = video2;
  async function ptt(ctx, pttPath) {
    const { converted, path: silkPath, duration } = await encodeSilk(ctx, pttPath);
    const { md5, fileName, path: path2, fileSize } = await ctx.ntFileApi.uploadFile(silkPath, ElementType.Ptt);
    if (fileSize === 0) {
      throw new Error(" 0");
    }
    if (converted) {
      unlink(silkPath).then().catch((e) => {
      });
    }
    return {
      elementType: ElementType.Ptt,
      elementId: "",
      pttElement: {
        fileName,
        filePath: path2,
        md5HexStr: md5,
        fileSize: String(fileSize),
        duration,
        formatType: 1,
        voiceType: 1,
        voiceChangeType: 0,
        canConvert2Text: true,
        waveAmplitudes: [0, 18, 9, 23, 16, 17, 16, 15, 44, 17, 24, 20, 14, 15, 17],
        fileSubId: "",
        playState: 1,
        autoConvertText: 0
      }
    };
  }
  SendElement2.ptt = ptt;
  function face(faceId, faceType) {
    const sysFaces = faceConfig.sysface;
    const face2 = sysFaces.find((face3) => face3.QSid === String(faceId));
    if (!faceType) {
      if (faceId < 222) {
        faceType = 1;
      } else if (faceId < 1e5) {
        faceType = 2;
      } else {
        faceType = 4;
      }
      if (face2?.AniStickerType) {
        faceType = 3;
      }
    }
    return {
      elementType: ElementType.Face,
      elementId: "",
      faceElement: {
        faceIndex: faceId,
        faceType,
        faceText: face2?.QDes,
        stickerId: face2?.AniStickerId,
        stickerType: face2?.AniStickerType,
        packId: face2?.AniStickerPackId,
        sourceType: 1
      }
    };
  }
  SendElement2.face = face;
  function mface(emojiPackageId, emojiId, key2, summary) {
    return {
      elementType: ElementType.MarketFace,
      elementId: "",
      marketFaceElement: {
        imageWidth: 300,
        imageHeight: 300,
        emojiPackageId,
        emojiId,
        key: key2,
        faceName: summary || "[]"
      }
    };
  }
  SendElement2.mface = mface;
  function dice(resultId) {
    if (isNullable(resultId)) resultId = Math.floor(Math.random() * 6) + 1;
    return {
      elementType: ElementType.Face,
      elementId: "",
      faceElement: {
        faceIndex: FaceIndex.Dice,
        faceType: 3,
        faceText: "[]",
        packId: "1",
        stickerId: "33",
        sourceType: 1,
        stickerType: 2,
        resultId: resultId.toString(),
        surpriseId: ""
        // "randomType": 1,
      }
    };
  }
  SendElement2.dice = dice;
  function rps(resultId) {
    if (isNullable(resultId)) resultId = Math.floor(Math.random() * 3) + 1;
    return {
      elementType: ElementType.Face,
      elementId: "",
      faceElement: {
        faceIndex: FaceIndex.RPS,
        faceText: "[]",
        faceType: 3,
        packId: "1",
        stickerId: "34",
        sourceType: 1,
        stickerType: 2,
        resultId: resultId.toString(),
        surpriseId: ""
        // "randomType": 1,
      }
    };
  }
  SendElement2.rps = rps;
  function ark(data) {
    return {
      elementType: ElementType.Ark,
      elementId: "",
      arkElement: {
        bytesData: data,
        linkInfo: null,
        subElementType: null
      }
    };
  }
  SendElement2.ark = ark;
  function shake() {
    return {
      elementType: ElementType.Face,
      elementId: "",
      faceElement: {
        faceIndex: 1,
        faceType: 5,
        pokeType: 1
      }
    };
  }
  SendElement2.shake = shake;
})(SendElement || (SendElement = {}));
class MusicSign {
  constructor(ctx, url) {
    this.ctx = ctx;
    this.url = url;
  }
  url;
  async sign(postData) {
    const resp = await fetch(this.url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(postData)
    });
    if (!resp.ok) throw new Error(resp.statusText);
    const data = await resp.text();
    this.ctx.logger.info("", data);
    return data;
  }
}
async function createSendElements(ctx, messageData, peer, ignoreTypes = []) {
  const sendElements = [];
  const deleteAfterSentFiles = [];
  for (const segment of messageData) {
    if (ignoreTypes.includes(segment.type)) {
      continue;
    }
    switch (segment.type) {
      case OB11MessageDataType.Text:
        {
          const text = segment.data?.text;
          if (text) {
            sendElements.push(SendElement.text(segment.data.text));
          }
        }
        break;
      case OB11MessageDataType.At:
        {
          if (!peer) {
            continue;
          }
          if (segment.data?.qq) {
            const atQQ = String(segment.data.qq);
            if (atQQ === "all") {
              const groupCode = peer.peerUid;
              let remainAtAllCount = 1;
              let isAdmin = true;
              if (groupCode) {
                try {
                  remainAtAllCount = (await ctx.ntGroupApi.getGroupRemainAtTimes(groupCode)).atInfo.RemainAtAllCountForUin;
                  ctx.logger.info(`${groupCode}at`, remainAtAllCount);
                  const self2 = await ctx.ntGroupApi.getGroupMember(groupCode, selfInfo.uid);
                  isAdmin = self2?.role === GroupMemberRole.Admin || self2?.role === GroupMemberRole.Owner;
                } catch (e) {
                }
              }
              if (isAdmin && remainAtAllCount > 0) {
                sendElements.push(SendElement.at(atQQ, atQQ, AtType.All, "@"));
              }
            } else if (peer.chatType === ChatType.Group) {
              const uid = await ctx.ntUserApi.getUidByUin(atQQ, peer.peerUid) ?? "";
              let display = "";
              if (segment.data.name) {
                display = `@${segment.data.name}`;
              }
              sendElements.push(SendElement.at(atQQ, uid, AtType.One, display));
            }
          }
        }
        break;
      case OB11MessageDataType.Reply:
        {
          if (segment.data?.id) {
            const info = await ctx.store.getMsgInfoByShortId(+segment.data.id);
            if (!info) {
              ctx.logger.warn("", info);
              continue;
            }
            const source2 = (await ctx.ntMsgApi.getMsgsByMsgId(info.peer, [info.msgId])).msgList[0];
            if (source2) {
              sendElements.push(SendElement.reply(source2.msgSeq, source2.msgId, source2.senderUin));
            }
          }
        }
        break;
      case OB11MessageDataType.Face:
        {
          const faceId = segment.data?.id;
          if (faceId) {
            sendElements.push(SendElement.face(parseInt(faceId)));
          }
        }
        break;
      case OB11MessageDataType.Mface:
        {
          sendElements.push(
            SendElement.mface(
              +segment.data.emoji_package_id,
              segment.data.emoji_id,
              segment.data.key,
              segment.data.summary
            )
          );
        }
        break;
      case OB11MessageDataType.Image:
        {
          const res = await SendElement.pic(
            ctx,
            (await handleOb11RichMedia(ctx, segment, deleteAfterSentFiles)).path,
            segment.data.summary || "",
            segment.data.subType || 0,
            segment.data.type === "flash"
          );
          deleteAfterSentFiles.push(res.picElement.sourcePath);
          sendElements.push(res);
        }
        break;
      case OB11MessageDataType.File:
        {
          const { path: path2, fileName } = await handleOb11RichMedia(ctx, segment, deleteAfterSentFiles);
          sendElements.push(await SendElement.file(ctx, path2, fileName));
        }
        break;
      case OB11MessageDataType.Video:
        {
          const { path: path2 } = await handleOb11RichMedia(ctx, segment, deleteAfterSentFiles);
          let thumb = segment.data.thumb;
          if (thumb) {
            const uri2LocalRes = await uri2local(ctx, thumb);
            if (uri2LocalRes.success) thumb = uri2LocalRes.path;
          }
          const res = await SendElement.video(ctx, path2, thumb);
          deleteAfterSentFiles.push(res.videoElement.filePath);
          sendElements.push(res);
        }
        break;
      case OB11MessageDataType.Record:
        {
          const { path: path2 } = await handleOb11RichMedia(ctx, segment, deleteAfterSentFiles);
          sendElements.push(await SendElement.ptt(ctx, path2));
        }
        break;
      case OB11MessageDataType.Json:
        {
          sendElements.push(SendElement.ark(segment.data.data));
        }
        break;
      case OB11MessageDataType.Dice:
        {
          const resultId = segment.data?.result;
          sendElements.push(SendElement.dice(resultId));
        }
        break;
      case OB11MessageDataType.Rps:
        {
          const resultId = segment.data?.result;
          sendElements.push(SendElement.rps(resultId));
        }
        break;
      case OB11MessageDataType.Contact:
        {
          const { type: type2, id } = segment.data;
          const data = type2 === "qq" ? ctx.ntFriendApi.getBuddyRecommendContact(id) : ctx.ntGroupApi.getGroupRecommendContact(id);
          sendElements.push(SendElement.ark(await data));
        }
        break;
      case OB11MessageDataType.Shake:
        {
          sendElements.push(SendElement.shake());
        }
        break;
      case OB11MessageDataType.Music:
        {
          const { musicSignUrl } = ctx.config;
          if (!musicSignUrl) {
            throw new Error("");
          }
          const { type: type2 } = segment.data;
          if (!["qq", "163", "kugou", "kuwo", "migu", "custom"].includes(type2)) {
            throw new Error(` type ${type2}`);
          }
          if (type2 === "custom") {
            if (!segment.data.url) {
              throw new Error("url");
            }
            if (!segment.data.title) {
              throw new Error("title");
            }
          } else {
            if (!segment.data.id) {
              throw new Error("id");
            }
          }
          let postData;
          if (type2 === "custom" && segment.data.content) {
            const { content, ...others } = segment.data;
            postData = { singer: content, ...others };
          } else {
            postData = segment.data;
          }
          try {
            const content = await new MusicSign(ctx, musicSignUrl).sign(postData);
            if (!content) {
              throw new Error("");
            }
            sendElements.push(SendElement.ark(content));
          } catch (e) {
            throw new Error(`${e}`);
          }
        }
        break;
      case OB11MessageDataType.Forward:
        {
          let resid;
          let filename;
          let source2 = "";
          let news = [{
            text: ""
          }];
          let summary = "";
          if (isNumeric(segment.data.id)) {
            const shortId = await ctx.store.getShortIdByMsgId(segment.data.id);
            if (!shortId) {
              throw new Error("msg not found");
            }
            const rootMsg = await ctx.store.getMsgInfoByShortId(shortId);
            if (!rootMsg) {
              throw new Error("msg not found");
            }
            const msg = await ctx.ntMsgApi.getMsgsByMsgId(rootMsg.peer, [rootMsg.msgId]);
            const { multiForwardMsgElement } = msg.msgList[0].elements[0];
            resid = multiForwardMsgElement.resId;
            filename = multiForwardMsgElement.fileName;
            const { xmlContent } = multiForwardMsgElement;
            const titles = Array.from(xmlContent.matchAll(/<title[^>]*>([^<]*)<\/title>/g));
            source2 = titles[0][1];
            news = titles.slice(1).map((e) => {
              return { text: e[1] };
            });
            summary = xmlContent.match(/<summary[^>]*>([^<]*)<\/summary>/)[1];
          }
          resid ??= segment.data.id;
          filename ??= randomUUID();
          const content = JSON.stringify({
            app: "com.tencent.multimsg",
            config: {
              autosize: 1,
              forward: 1,
              round: 1,
              type: "normal",
              width: 300
            },
            desc: "[]",
            extra: JSON.stringify({
              filename,
              tsum: 0
            }),
            meta: {
              detail: {
                news,
                resid,
                source: source2,
                summary,
                uniseq: filename
              }
            },
            prompt: "[]",
            ver: "0.0.0.5",
            view: "contact"
          });
          sendElements.push(SendElement.ark(content));
        }
        break;
    }
  }
  return {
    sendElements,
    deleteAfterSentFiles
  };
}
function message2List(message, autoEscape = false) {
  if (typeof message === "string") {
    if (autoEscape === true) {
      return [
        {
          type: OB11MessageDataType.Text,
          data: {
            text: message
          }
        }
      ];
    } else {
      return decodeCQCode(message);
    }
  } else if (!Array.isArray(message)) {
    return [message];
  }
  return message;
}
var CreatePeerMode = /* @__PURE__ */ ((CreatePeerMode2) => {
  CreatePeerMode2[CreatePeerMode2["Normal"] = 0] = "Normal";
  CreatePeerMode2[CreatePeerMode2["Private"] = 1] = "Private";
  CreatePeerMode2[CreatePeerMode2["Group"] = 2] = "Group";
  return CreatePeerMode2;
})(CreatePeerMode || {});
async function createPeer(ctx, payload, mode2 = 0) {
  if ((mode2 === 2 || mode2 === 0) && payload.group_id) {
    return {
      chatType: ChatType.Group,
      peerUid: payload.group_id.toString(),
      guildId: ""
    };
  }
  if ((mode2 === 1 || mode2 === 0) && payload.user_id) {
    const uid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) throw new Error("");
    const isBuddy = await ctx.ntFriendApi.isBuddy(uid);
    return {
      chatType: isBuddy ? ChatType.C2C : ChatType.TempC2CFromGroup,
      peerUid: uid,
      guildId: ""
    };
  }
  throw new Error(" group_id  user_id");
}
async function handleOb11RichMedia(ctx, segment, deleteAfterSentFiles) {
  const res = await uri2local(ctx, segment.data.url || segment.data.file);
  if (!res.success) {
    ctx.logger.error(res.errMsg);
    throw Error(res.errMsg);
  }
  if (!res.isLocal) {
    deleteAfterSentFiles.push(res.path);
  }
  return { path: res.path, fileName: segment.data.name || res.fileName };
}
async function handleQuickOperation(ctx, event, quickAction) {
  if (event.post_type === "message") {
    handleMsg(ctx, event, quickAction).then().catch((e) => ctx.logger.error(e));
  }
  if (event.post_type === "request") {
    const friendRequest = event;
    const groupRequest = event;
    if (friendRequest.request_type === "friend") {
      handleFriendRequest$1(ctx, friendRequest, quickAction).then().catch((e) => ctx.logger.error(e));
    } else if (groupRequest.request_type === "group") {
      handleGroupRequest(ctx, groupRequest, quickAction).then().catch((e) => ctx.logger.error(e));
    }
  }
}
async function handleMsg(ctx, msg, quickAction) {
  const reply = quickAction.reply;
  let contextMode = CreatePeerMode.Normal;
  if (msg.message_type === "group") {
    contextMode = CreatePeerMode.Group;
  } else if (msg.message_type === "private") {
    contextMode = CreatePeerMode.Private;
  }
  const peer = await createPeer(ctx, msg, contextMode);
  if (reply) {
    let replyMessage = [];
    replyMessage.push({
      type: OB11MessageDataType.Reply,
      data: {
        id: msg.message_id.toString()
      }
    });
    if (msg.message_type == "group") {
      if (quickAction.at_sender) {
        replyMessage.push({
          type: OB11MessageDataType.At,
          data: {
            qq: msg.user_id.toString()
          }
        });
      }
    }
    replyMessage = replyMessage.concat(message2List(reply, quickAction.auto_escape));
    const { sendElements, deleteAfterSentFiles } = await createSendElements(ctx, replyMessage, peer);
    ctx.app.sendMessage(ctx, peer, sendElements, deleteAfterSentFiles).catch((e) => ctx.logger.error(e));
  }
  if (msg.message_type === "group") {
    const groupMsgQuickAction = quickAction;
    const rawMessage = await ctx.store.getMsgInfoByShortId(+(msg.message_id ?? 0));
    if (!rawMessage) return;
    if (groupMsgQuickAction.delete) {
      ctx.ntMsgApi.recallMsg(peer, [rawMessage.msgId]).catch((e) => ctx.logger.error(e));
    }
    if (groupMsgQuickAction.kick) {
      const { msgList } = await ctx.ntMsgApi.getMsgsByMsgId(peer, [rawMessage.msgId]);
      ctx.ntGroupApi.kickMember(peer.peerUid, [msgList[0].senderUid]).catch((e) => ctx.logger.error(e));
    }
    if (groupMsgQuickAction.ban) {
      const { msgList } = await ctx.ntMsgApi.getMsgsByMsgId(peer, [rawMessage.msgId]);
      ctx.ntGroupApi.banMember(peer.peerUid, [
        {
          uid: msgList[0].senderUid,
          timeStamp: groupMsgQuickAction.ban_duration || 60 * 30
        }
      ]).catch((e) => ctx.logger.error(e));
    }
  }
}
async function handleFriendRequest$1(ctx, request2, quickAction) {
  if (!isNullable(quickAction.approve)) {
    const data = request2.flag.split("|");
    if (data.length < 2) {
      return;
    }
    const uid = data[0];
    const reqTime = data[1];
    await ctx.ntFriendApi.handleFriendRequest(uid, reqTime, quickAction.approve).catch((e) => ctx.logger.error(e));
    if (!isNullable(quickAction.remark)) {
      ctx.ntFriendApi.setBuddyRemark(uid, quickAction.remark).catch((e) => ctx.logger.error(e));
    }
  }
}
async function handleGroupRequest(ctx, request2, quickAction) {
  if (!isNullable(quickAction.approve)) {
    ctx.ntGroupApi.handleGroupRequest(
      request2.flag,
      quickAction.approve ? GroupRequestOperateTypes.Approve : GroupRequestOperateTypes.Reject,
      quickAction.reason
    ).catch((e) => ctx.logger.error(e));
  }
}
class OB11Http {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    this.expressAPP = express();
    this.expressAPP.use(cors());
    this.expressAPP.use(express.urlencoded({ extended: true, limit: "5000mb" }));
    this.expressAPP.use((req, res, next) => {
      req.headers["content-type"] = "application/json";
      const originalJson = express.json({ limit: "5000mb" });
      originalJson(req, res, (err) => {
        if (err) {
          ctx.logger.error("Error parsing JSON:", err);
          return res.status(400).send("Invalid JSON");
        }
        next();
      });
    });
    this.expressAPP.use((req, res, next) => this.authorize(req, res, next));
    this.expressAPP.use((req, res, next) => this.handleRequest(req, res, next));
  }
  expressAPP;
  server;
  sseClients = [];
  sockets = /* @__PURE__ */ new Set();
  start() {
    if (this.server)
      return;
    try {
      this.expressAPP.get("/", (req, res) => {
        res.send(`LLOneBot server `);
      });
      const host = this.config.listenLocalhost ? "127.0.0.1" : "";
      llonebotError.httpServerError = "";
      this.expressAPP.get("/_events", (req, res) => {
        res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no");
        res.flushHeaders();
        this.sseClients.push(res);
        req.on("close", () => {
          const index = this.sseClients.indexOf(res);
          if (index > -1) {
            this.sseClients.splice(index, 1);
          }
        });
        req.on("error", () => {
          const index = this.sseClients.indexOf(res);
          if (index > -1) {
            this.sseClients.splice(index, 1);
          }
        });
      });
      this.ctx.logger.info(`OneBot V11 HTTP SSE started ${host}:${this.config.port}/_events`);
      try {
        this.server = this.expressAPP.listen(this.config.port, host, (err) => {
          if (err) {
            this.ctx.logger.error("OneBot V11 HTTP server start error:", err);
          }
          this.ctx.logger.info(`OneBot V11 HTTP server started ${host}:${this.config.port}`);
        });
        this.server.on("connection", (socket) => {
          this.sockets.add(socket);
          socket.on("close", () => this.sockets.delete(socket));
        });
      } catch (e) {
        this.ctx.logger.error(`OneBot V11 HTTP server error ${host}:${this.config.port}`, e);
      }
    } catch (e) {
      this.ctx.logger.error("OneBot V11 HTTP", e);
      llonebotError.httpServerError = "HTTP, " + e;
    }
  }
  stop() {
    return new Promise((resolve2) => {
      if (this.server) {
        this.ctx.logger.info("OneBot V11 HTTP Server closing...");
        for (const socket of this.sockets) {
          socket.destroy();
        }
        this.sockets.clear();
        this.server.close((err) => {
          if (err) {
            this.ctx.logger.error(`OneBot V11 HTTP Server closing ${err}`);
            return resolve2(false);
          }
          this.ctx.logger.info("OneBot V11 HTTP Server closed");
          this.server = void 0;
          resolve2(true);
        });
      } else {
        resolve2(true);
      }
    });
  }
  async emitEvent(event) {
    if (this.sseClients.length === 0) {
      return;
    }
    const data = `data: ${JSON.stringify(event)}

`;
    for (const client of this.sseClients) {
      if (!client.closed) {
        client.write(data);
        if ("post_type" in event) {
          const eventName = event.post_type + "." + event[event.post_type + "_type"];
          this.ctx.logger.info("OneBot V11 HTTP SSE ", eventName);
        }
      }
    }
  }
  updateConfig(config) {
    Object.assign(this.config, config);
  }
  authorize(req, res, next) {
    const serverToken = this.config.token;
    if (!serverToken) return next();
    let clientToken = "";
    const authHeader = req.get("authorization");
    if (authHeader) {
      clientToken = authHeader.split("Bearer ").pop();
      this.ctx.logger.info("receive http header token", clientToken);
    } else if (req.query.access_token) {
      if (Array.isArray(req.query.access_token)) {
        clientToken = req.query.access_token[0].toString();
      } else {
        clientToken = req.query.access_token.toString();
      }
      this.ctx.logger.info("receive http url token", clientToken);
    }
    if (clientToken !== serverToken) {
      res.status(403).json({ message: "token verify failed!" });
    } else {
      next();
    }
  }
  async handleRequest(req, res, next) {
    if (req.path === "/") {
      return next();
    }
    if (req.path === "/_events") {
      return next();
    }
    let payload = req.body;
    if (req.method === "GET") {
      payload = req.query;
    } else if (req.query) {
      payload = { ...req.query, ...req.body };
    }
    this.ctx.logger.info(" HTTP ", req.url, payload);
    const action = this.config.actionMap.get(req.path.replaceAll("/", ""));
    if (action) {
      res.json(await action.handle(payload));
    } else {
      res.status(404).json(OB11Response.error("API ", 404));
    }
  }
}
class OB11HttpPost {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
  }
  disposeInterval;
  activated = false;
  start() {
    this.activated = true;
    if (this.config.enableHttpHeart && !this.disposeInterval) {
      this.disposeInterval = this.ctx.setInterval(() => {
        this.emitEvent(new OB11HeartbeatEvent(selfInfo.online, true, this.config.heartInterval));
      }, this.config.heartInterval);
    }
  }
  stop() {
    this.activated = false;
    this.disposeInterval?.();
  }
  async emitEvent(event) {
    if (!this.activated || !this.config.hosts.length) {
      return;
    }
    const msgStr = JSON.stringify(event);
    const headers = {
      "Content-Type": "application/json",
      "x-self-id": selfInfo.uin
    };
    if (this.config.secret) {
      const hmac = crypto$1.createHmac("sha1", this.config.secret);
      hmac.update(msgStr);
      const sig = hmac.digest("hex");
      headers["x-signature"] = "sha1=" + sig;
    }
    for (const host of this.config.hosts) {
      fetch(host, {
        method: "POST",
        headers,
        body: msgStr
      }).then(
        async (res) => {
          if (event.post_type) {
            const eventName = event.post_type + "." + event[event.post_type + "_type"];
            this.ctx.logger.info(`HTTP : ${host}`, eventName, res.status);
          }
          try {
            const resJson = await res.json();
            this.ctx.logger.info(`HTTP :`, JSON.stringify(resJson));
            handleQuickOperation(this.ctx, event, resJson).catch((e) => this.ctx.logger.error(e));
          } catch (e) {
            this.ctx.logger.warn(`HTTP : ${host}`, e);
          }
        },
        (err) => {
          this.ctx.logger.error(`HTTP : ${host}`, err, event);
        }
      ).catch((e) => {
        this.ctx.logger.error(`HTTP : ${host}`, e);
      });
    }
  }
  updateConfig(config) {
    Object.assign(this.config, config);
  }
}
let curentSeq = 0;
const eventList = [];
const httpUser = {};
function postHttpEvent(event) {
  curentSeq += 1;
  eventList.push({
    seq: curentSeq,
    event
  });
  while (eventList.length > 100) {
    eventList.shift();
  }
}
async function getHttpEvent(userKey, timeout2 = 0) {
  if (typeof userKey !== "string" || userKey === "__proto__" || userKey === "constructor" || userKey === "prototype") {
    throw new Error("Invalid user key");
  }
  const toRetEvent = [];
  const now = Date.now();
  for (const key2 in httpUser) {
    const user2 = httpUser[key2];
    if (now - user2.lastAccessTime > 1e3 * 60 * 5) {
      delete httpUser[key2];
    }
  }
  const userKeys = Object.keys(httpUser);
  if (userKeys.length > 100) {
    const oldestKey = userKeys.reduce(
      (oldest, current) => httpUser[current].lastAccessTime < httpUser[oldest].lastAccessTime ? current : oldest
    );
    delete httpUser[oldestKey];
  }
  if (!httpUser[userKey]) {
    httpUser[userKey] = {
      lastAccessTime: now,
      userSeq: curentSeq
    };
  }
  const user = httpUser[userKey];
  while (curentSeq == user.userSeq && Date.now() - now < timeout2) {
    await new Promise((resolve2) => setTimeout(resolve2, 10));
  }
  for (let i = 0; i < eventList.length; i++) {
    const evt = eventList[i];
    if (evt.seq > user.userSeq) {
      toRetEvent.push(evt.event);
    }
  }
  user.lastAccessTime = Date.now();
  user.userSeq = curentSeq;
  return toRetEvent;
}
class BaseAction {
  constructor(adapter) {
    this.adapter = adapter;
    this.ctx = adapter.ctx;
  }
  ctx;
  payloadSchema;
  async handle(payload) {
    let params;
    try {
      params = this.payloadSchema ? new this.payloadSchema(payload) : payload;
    } catch (e) {
      return OB11Response.error(e.message, 400);
    }
    try {
      const resData = await this._handle(params);
      return OB11Response.ok(resData);
    } catch (e) {
      this.ctx.logger.error("", e);
      return OB11Response.error(e?.toString() ?? String(e), 200);
    }
  }
  async websocketHandle(payload, echo) {
    let params;
    try {
      params = this.payloadSchema ? new this.payloadSchema(payload) : payload;
    } catch (e) {
      return OB11Response.error(e.message, 1400);
    }
    try {
      const resData = await this._handle(params);
      return OB11Response.ok(resData, echo);
    } catch (e) {
      this.ctx.logger.error("", e);
      return OB11Response.error(e?.toString() ?? String(e), 1200, echo);
    }
  }
}
var ActionName = /* @__PURE__ */ ((ActionName2) => {
  ActionName2["GetFlashFileInfo"] = "get_flash_file_info";
  ActionName2["DownloadFlashFile"] = "download_flash_file";
  ActionName2["UploadFlashFile"] = "upload_flash_file";
  ActionName2["GetRKey"] = "get_rkey";
  ActionName2["SendPB"] = "send_pb";
  ActionName2["VoiceMsg2Text"] = "voice_msg_to_text";
  ActionName2["SendPoke"] = "send_poke";
  ActionName2["GetGroupIgnoreAddRequest"] = "get_group_ignore_add_request";
  ActionName2["SetQQAvatar"] = "set_qq_avatar";
  ActionName2["GetQQAvatar"] = "get_qq_avatar";
  ActionName2["GetConfig"] = "get_config";
  ActionName2["SetConfig"] = "set_config";
  ActionName2["Debug"] = "llonebot_debug";
  ActionName2["GetFile"] = "get_file";
  ActionName2["GetFriendsWithCategory"] = "get_friends_with_category";
  ActionName2["GetEvent"] = "get_event";
  ActionName2["SetOnlineStatus"] = "set_online_status";
  ActionName2["GetProfileLike"] = "get_profile_like";
  ActionName2["GetProfileLikeMe"] = "get_profile_like_me";
  ActionName2["FetchEmojiLike"] = "fetch_emoji_like";
  ActionName2["FetchCustomFace"] = "fetch_custom_face";
  ActionName2["GetFriendMsgHistory"] = "get_friend_msg_history";
  ActionName2["SendForwardMsg"] = "send_forward_msg";
  ActionName2["SetMsgEmojiLike"] = "set_msg_emoji_like";
  ActionName2["UnSetMsgEmojiLike"] = "unset_msg_emoji_like";
  ActionName2["GetRobotUinRange"] = "get_robot_uin_range";
  ActionName2["GroupPoke"] = "group_poke";
  ActionName2["FriendPoke"] = "friend_poke";
  ActionName2["SetFriendRemark"] = "set_friend_remark";
  ActionName2["SetFriendCategory"] = "set_friend_category";
  ActionName2["SetGroupMsgMask"] = "set_group_msg_mask";
  ActionName2["SetGroupRemark"] = "set_group_remark";
  ActionName2["MoveGroupFile"] = "move_group_file";
  ActionName2["GetGroupShutList"] = "get_group_shut_list";
  ActionName2["RenameGroupFileFolder"] = "rename_group_file_folder";
  ActionName2["SendLike"] = "send_like";
  ActionName2["GetLoginInfo"] = "get_login_info";
  ActionName2["GetFriendList"] = "get_friend_list";
  ActionName2["GetGroupInfo"] = "get_group_info";
  ActionName2["GetGroupList"] = "get_group_list";
  ActionName2["GetGroupMemberInfo"] = "get_group_member_info";
  ActionName2["GetGroupMemberList"] = "get_group_member_list";
  ActionName2["GetMsg"] = "get_msg";
  ActionName2["SendMsg"] = "send_msg";
  ActionName2["SendGroupMsg"] = "send_group_msg";
  ActionName2["SendPrivateMsg"] = "send_private_msg";
  ActionName2["DeleteMsg"] = "delete_msg";
  ActionName2["SetGroupAddRequest"] = "set_group_add_request";
  ActionName2["SetFriendAddRequest"] = "set_friend_add_request";
  ActionName2["SetGroupLeave"] = "set_group_leave";
  ActionName2["GetVersionInfo"] = "get_version_info";
  ActionName2["GetStatus"] = "get_status";
  ActionName2["SetRestart"] = "set_restart";
  ActionName2["CanSendRecord"] = "can_send_record";
  ActionName2["CanSendImage"] = "can_send_image";
  ActionName2["SetGroupKick"] = "set_group_kick";
  ActionName2["SetGroupBan"] = "set_group_ban";
  ActionName2["SetGroupWholeBan"] = "set_group_whole_ban";
  ActionName2["SetGroupAdmin"] = "set_group_admin";
  ActionName2["SetGroupCard"] = "set_group_card";
  ActionName2["SetGroupName"] = "set_group_name";
  ActionName2["GetImage"] = "get_image";
  ActionName2["GetRecord"] = "get_record";
  ActionName2["CleanCache"] = "clean_cache";
  ActionName2["GetCookies"] = "get_cookies";
  ActionName2["ForwardFriendSingleMsg"] = "forward_friend_single_msg";
  ActionName2["ForwardGroupSingleMsg"] = "forward_group_single_msg";
  ActionName2["GetCredentials"] = "get_credentials";
  ActionName2["GetCsrfToken"] = "get_csrf_token";
  ActionName2["GoCQHTTP_SendGroupForwardMsg"] = "send_group_forward_msg";
  ActionName2["GoCQHTTP_SendPrivateForwardMsg"] = "send_private_forward_msg";
  ActionName2["GoCQHTTP_GetStrangerInfo"] = "get_stranger_info";
  ActionName2["GetGuildList"] = "get_guild_list";
  ActionName2["GoCQHTTP_MarkMsgAsRead"] = "mark_msg_as_read";
  ActionName2["GoCQHTTP_UploadGroupFile"] = "upload_group_file";
  ActionName2["GoCQHTTP_UploadPrivateFile"] = "upload_private_file";
  ActionName2["GoCQHTTP_DownloadFile"] = "download_file";
  ActionName2["GoCQHTTP_GetGroupMsgHistory"] = "get_group_msg_history";
  ActionName2["GoCQHTTP_GetForwardMsg"] = "get_forward_msg";
  ActionName2["GoCQHTTP_GetEssenceMsgList"] = "get_essence_msg_list";
  ActionName2["GoCQHTTP_HandleQuickOperation"] = ".handle_quick_operation";
  ActionName2["GetGroupHonorInfo"] = "get_group_honor_info";
  ActionName2["GoCQHTTP_SetEssenceMsg"] = "set_essence_msg";
  ActionName2["GoCQHTTP_DelEssenceMsg"] = "delete_essence_msg";
  ActionName2["GoCQHTTP_DelGroupFile"] = "delete_group_file";
  ActionName2["GoCQHTTP_GetGroupSystemMsg"] = "get_group_system_msg";
  ActionName2["GoCQHTTP_CreateGroupFileFolder"] = "create_group_file_folder";
  ActionName2["GoCQHTTP_DelGroupFolder"] = "delete_group_folder";
  ActionName2["GoCQHTTP_GetGroupAtAllRemain"] = "get_group_at_all_remain";
  ActionName2["GoCQHTTP_GetGroupRootFiles"] = "get_group_root_files";
  ActionName2["GoCQHTTP_SendGroupNotice"] = "_send_group_notice";
  ActionName2["GoCQHTTP_GetGroupFilesByFolder"] = "get_group_files_by_folder";
  ActionName2["GoCQHTTP_GetGroupFileUrl"] = "get_group_file_url";
  ActionName2["GoCQHTTP_GetGroupNotice"] = "_get_group_notice";
  ActionName2["GoCQHTTP_DeleteFriend"] = "delete_friend";
  ActionName2["GoCQHTTP_OCRImage"] = "ocr_image";
  ActionName2["GoCQHTTP_GetGroupFileSystemInfo"] = "get_group_file_system_info";
  ActionName2["GoCQHTTP_SetGroupSpecialTitle"] = "set_group_special_title";
  ActionName2["GoCQHTTP_SendGroupSign"] = "send_group_sign";
  ActionName2["GoCQHTTP_SetQQProfile"] = "set_qq_profile";
  ActionName2["GoCQHTTP_SetGroupPortrait"] = "set_group_portrait";
  return ActionName2;
})(ActionName || {});
class GetMsg extends BaseAction {
  actionName = ActionName.GetMsg;
  async _handle(payload) {
    if (!payload.message_id) {
      throw new Error("message_id");
    }
    const msgInfo = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msgInfo) {
      throw new Error("");
    }
    let msg = this.ctx.store.getMsgCache(msgInfo.msgId);
    if (!msg) {
      const res = await this.ctx.ntMsgApi.getMsgsByMsgId(msgInfo.peer, [msgInfo.msgId]);
      if (res.msgList.length === 0) {
        throw new Error("");
      }
      msg = res.msgList[0];
    }
    const retMsg = await OB11Entities.message(this.ctx, msg);
    if (!retMsg) {
      throw new Error("");
    }
    retMsg.real_id = retMsg.message_seq;
    return retMsg;
  }
}
class GetLoginInfo extends BaseAction {
  actionName = ActionName.GetLoginInfo;
  async _handle() {
    let nickname = selfInfo.nick;
    try {
      nickname = await this.ctx.ntUserApi.getSelfNick(true);
    } catch {
    }
    return {
      user_id: parseInt(selfInfo.uin),
      nickname
    };
  }
}
class GetFriendList extends BaseAction {
  actionName = ActionName.GetFriendList;
  payloadSchema = z.object({
    no_cache: z.union([Boolean, z.transform(String, parseBool)]).default(false)
  });
  async _handle(payload) {
    payload.no_cache;
    return OB11Entities.friendsV2(await this.ctx.ntFriendApi.getBuddyList());
  }
}
class GetGroupList extends BaseAction {
  actionName = ActionName.GetGroupList;
  async _handle() {
    const groupList = await this.ctx.ntGroupApi.getGroups();
    return OB11Entities.groups(groupList);
  }
}
class GetGroupInfo extends BaseAction {
  actionName = ActionName.GetGroupInfo;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const groupAll = await this.ctx.ntGroupApi.getGroupAllInfo(groupCode);
    const data = {
      group_id: +groupAll.groupCode,
      group_name: groupAll.groupName,
      group_memo: groupAll.richFingerMemo,
      group_create_time: 0,
      member_count: groupAll.memberNum,
      max_member_count: groupAll.maxMemberNum,
      remark_name: groupAll.remarkName,
      groupAll
    };
    const group = (await this.ctx.ntGroupApi.getGroups()).find((e) => e.groupCode === groupCode);
    if (group) {
      data.group_create_time = +group.createTime;
    }
    return data;
  }
}
class GetGroupMemberList extends BaseAction {
  actionName = ActionName.GetGroupMemberList;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    let groupMembers = await this.ctx.ntGroupApi.getGroupMembers(groupCode);
    for (let i = 0; i < 5; i++) {
      if (groupMembers.size > 0) {
        break;
      }
      await this.ctx.sleep(60);
      groupMembers = await this.ctx.ntGroupApi.getGroupMembers(groupCode);
    }
    const date = Math.trunc(Date.now() / 1e3);
    const groupId = Number(payload.group_id);
    const ret = [];
    for (const item of groupMembers.values()) {
      const member = OB11Entities.groupMember(groupId, item);
      member.join_time ??= date;
      member.last_sent_time ??= date;
      ret.push(member);
    }
    return ret;
  }
}
class GetGroupMemberInfo extends BaseAction {
  actionName = ActionName.GetGroupMemberInfo;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    user_id: z.union([Number, String]).required(),
    no_cache: z.union([Boolean, z.transform(String, parseBool)]).default(false)
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(payload.user_id.toString(), groupCode);
    if (!uid) throw new Error("");
    const member = await this.ctx.ntGroupApi.getGroupMember(groupCode, uid, payload.no_cache);
    if (member) {
      const ret = OB11Entities.groupMember(+groupCode, member);
      const date = Math.trunc(Date.now() / 1e3);
      ret.last_sent_time ??= date;
      ret.join_time ??= date;
      let info = null;
      try {
        info = await this.ctx.ntUserApi.getUserDetailInfoWithBizInfo(member.uid);
      } catch (e) {
        try {
          const fetchInfo = await this.ctx.ntUserApi.fetchUserDetailInfo(member.uid);
          if (fetchInfo) {
            info = fetchInfo.simpleInfo;
          }
        } catch (e2) {
        }
      }
      if (info) {
        ret.sex = OB11Entities.sex(info.baseInfo.sex);
        ret.age = info.baseInfo.age ?? 0;
      }
      return ret;
    }
    throw new Error(`${payload.user_id}`);
  }
}
class SendMsg extends BaseAction {
  actionName = ActionName.SendMsg;
  async _handle(payload) {
    let contextMode = CreatePeerMode.Normal;
    if (payload.message_type === "group") {
      contextMode = CreatePeerMode.Group;
    } else if (payload.message_type === "private") {
      contextMode = CreatePeerMode.Private;
    }
    const peer = await createPeer(this.ctx, payload, contextMode);
    const messages = message2List(
      payload.message,
      payload.auto_escape === true || payload.auto_escape === "true"
    );
    if (messages.some((e) => e.type === OB11MessageDataType.Node)) {
      throw new Error(" /send_group_forward_msg  /send_private_forward_msg ");
    }
    const { sendElements, deleteAfterSentFiles } = await createSendElements(this.ctx, messages, peer);
    if (sendElements.length === 1) {
      if (sendElements[0] === null) {
        return { message_id: 0 };
      }
    }
    const returnMsg = await this.ctx.app.sendMessage(this.ctx, peer, sendElements, deleteAfterSentFiles);
    if (!returnMsg) {
      throw new Error("");
    }
    const msgShortId = this.ctx.store.createMsgShortId({
      chatType: returnMsg.chatType,
      peerUid: returnMsg.peerUid
    }, returnMsg.msgId);
    return { message_id: msgShortId };
  }
}
class SendGroupMsg extends SendMsg {
  actionName = ActionName.SendGroupMsg;
  _handle(payload) {
    payload.message_type = "group";
    return super._handle(payload);
  }
}
class SendPrivateMsg extends SendMsg {
  actionName = ActionName.SendPrivateMsg;
  _handle(payload) {
    payload.message_type = "private";
    return super._handle(payload);
  }
}
class DeleteMsg extends BaseAction {
  actionName = ActionName.DeleteMsg;
  async _handle(payload) {
    if (!payload.message_id) {
      throw new Error("message_id");
    }
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error(`${payload.message_id}`);
    }
    const data = await this.ctx.ntMsgApi.recallMsg(msg.peer, [msg.msgId]);
    if (data.result !== 0) {
      this.ctx.logger.error("delete_msg", payload.message_id, data);
      throw new Error(``);
    }
  }
}
class GetVersionInfo extends BaseAction {
  actionName = ActionName.GetVersionInfo;
  async _handle() {
    return {
      app_name: "LLOneBot",
      protocol_version: "v11",
      app_version: version
    };
  }
}
class CanSendRecord extends BaseAction {
  actionName = ActionName.CanSendRecord;
  async _handle() {
    return {
      yes: true
    };
  }
}
class CanSendImage extends CanSendRecord {
  actionName = ActionName.CanSendImage;
}
class GetStatus extends BaseAction {
  actionName = ActionName.GetStatus;
  async _handle() {
    return {
      online: selfInfo.online,
      good: true,
      stat: {
        message_received: this.ctx.app.messageReceivedCount,
        message_sent: this.ctx.app.messageSentCount,
        last_message_time: this.ctx.app.lastMessageTime,
        startup_time: this.ctx.app.startupTime
      }
    };
  }
}
let MessageEncoder$1 = class MessageEncoder2 {
  constructor(ctx, peer) {
    this.ctx = ctx;
    this.peer = peer;
    this.results = [];
    this.children = [];
    this.deleteAfterSentFiles = [];
    this.isGroup = peer.chatType === 2;
    this.seq = Math.trunc(Math.random() * 65430);
    this.tsum = 0;
    this.preview = "";
    this.news = [];
  }
  static support = ["text", "face", "image", "markdown", "forward"];
  results;
  children;
  deleteAfterSentFiles;
  isGroup;
  seq;
  tsum;
  preview;
  news;
  name;
  uin;
  async flush() {
    if (this.children.length === 0) return;
    const nick = this.name || selfInfo.nick || "QQ";
    if (this.news.length < 4) {
      this.news.push({
        text: `${nick}: ${this.preview}`
      });
    }
    this.results.push({
      routingHead: {
        fromUin: this.uin ?? +selfInfo.uin,
        //  1094950020
        c2c: this.isGroup ? void 0 : {
          friendName: nick
        },
        group: this.isGroup ? {
          groupCode: 284840486,
          groupCard: nick
        } : void 0
      },
      contentHead: {
        msgType: this.isGroup ? 82 : 9,
        random: Math.floor(Math.random() * 4294967290),
        msgSeq: this.seq,
        msgTime: Math.trunc(Date.now() / 1e3),
        pkgNum: 1,
        pkgIndex: 0,
        divSeq: 0,
        field15: {
          field1: 0,
          field2: 0,
          field3: 0,
          field4: "",
          field5: ""
        }
      },
      body: {
        richText: {
          elems: this.children
        }
      }
    });
    this.seq++;
    this.tsum++;
    this.children = [];
    this.preview = "";
  }
  async packImage(data, busiType) {
    const imageSize2 = await this.ctx.ntFileApi.getImageSize(data.filePath);
    return {
      commonElem: {
        serviceType: 48,
        pbElem: RichMedia.MsgInfo.encode({
          msgInfoBody: [{
            index: {
              info: {
                fileSize: +data.commonFileInfo.fileSize,
                md5HexStr: data.commonFileInfo.md5,
                sha1HexStr: data.commonFileInfo.sha,
                fileName: data.commonFileInfo.fileName,
                fileType: {
                  type: 1,
                  picFormat: imageSize2.type === "gif" ? 2e3 : 1e3
                },
                width: imageSize2.width,
                height: imageSize2.height,
                time: 0,
                original: 1
              },
              fileUuid: data.fileId,
              storeID: 1,
              expire: 2678400
            },
            pic: {
              urlPath: `/download?appid=${this.isGroup ? 1407 : 1406}&fileid=${data.fileId}`,
              ext: {
                originalParam: "&spec=0",
                bigParam: "&spec=720",
                thumbParam: "&spec=198"
              },
              domain: "multimedia.nt.qq.com.cn"
            },
            fileExist: true
          }],
          extBizInfo: {
            pic: {
              bizType: 0,
              summary: ""
            },
            busiType
          }
        }).finish(),
        businessType: this.isGroup ? 20 : 10
      }
    };
  }
  packForwardMessage(resid) {
    const uuid = crypto.randomUUID();
    const content = JSON.stringify({
      app: "com.tencent.multimsg",
      config: {
        autosize: 1,
        forward: 1,
        round: 1,
        type: "normal",
        width: 300
      },
      desc: "[]",
      extra: JSON.stringify({
        filename: uuid,
        tsum: 0
      }),
      meta: {
        detail: {
          news: [{
            text: ""
          }],
          resid,
          source: "",
          summary: "",
          uniseq: uuid
        }
      },
      prompt: "[]",
      ver: "0.0.0.5",
      view: "contact"
    });
    return {
      lightApp: {
        data: Buffer.concat([Buffer.from([1]), deflateSync(Buffer.from(content, "utf-8"))])
      }
    };
  }
  async visit(segment) {
    const { type: type2, data } = segment;
    if (type2 === OB11MessageDataType.Node) {
      await this.render(data.content);
      const id = data.uin ?? data.user_id;
      this.uin = id ? +id : void 0;
      this.name = data.name ?? data.nickname;
      await this.flush();
    } else if (type2 === OB11MessageDataType.Text) {
      this.children.push({
        text: {
          str: data.text
        }
      });
      this.preview += data.text;
    } else if (type2 === OB11MessageDataType.Face) {
      this.children.push({
        face: {
          index: +data.id
        }
      });
      const face = faceConfig.sysface.find((e) => e.QSid === String(data.id));
      if (face) {
        this.preview += face.QDes;
      }
    } else if (type2 === OB11MessageDataType.Image) {
      const { path: path2 } = await handleOb11RichMedia(this.ctx, segment, this.deleteAfterSentFiles);
      const data2 = await this.ctx.ntFileApi.uploadRMFileWithoutMsg(path2, this.isGroup ? 4 : 3, this.peer.peerUid);
      const busiType = Number(segment.data.subType) || 0;
      this.children.push(await this.packImage(data2, busiType));
      this.preview += busiType === 1 ? "[]" : "[]";
    } else if (type2 === OB11MessageDataType.Markdown) {
      this.children.push({
        commonElem: {
          serviceType: 45,
          pbElem: Msg.MarkdownElem.encode(data).finish(),
          businessType: 1
        }
      });
    } else if (type2 === OB11MessageDataType.Forward) {
      this.children.push(this.packForwardMessage(data.id));
      this.preview += "[]";
    }
  }
  async render(segments) {
    for (const segment of segments) {
      await this.visit(segment);
    }
  }
  async generate(content) {
    await this.render(content);
    return {
      multiMsgItems: [{
        fileName: "MultiMsg",
        buffer: {
          msg: this.results
        }
      }],
      tsum: this.tsum,
      source: this.isGroup ? "" : "",
      summary: `${this.tsum}`,
      news: this.news
    };
  }
};
class SendForwardMsg extends BaseAction {
  actionName = ActionName.SendForwardMsg;
  payloadSchema = z.object({
    user_id: z.union([Number, String]),
    group_id: z.union([Number, String]),
    messages: z.array(z.any()),
    message: z.array(z.any()),
    message_type: z.union(["group", "private"])
  });
  async _handle(payload) {
    const messages = payload.messages ?? payload.message;
    if (!messages) {
      throw new Error("");
    }
    let contextMode = CreatePeerMode.Normal;
    if (payload.message_type === "group") {
      contextMode = CreatePeerMode.Group;
    } else if (payload.message_type === "private") {
      contextMode = CreatePeerMode.Private;
    }
    const peer = await createPeer(this.ctx, payload, contextMode);
    const nodes = this.parseNodeContent(messages);
    let fake = true;
    for (const node of nodes) {
      if (node.data.id) {
        fake = false;
        break;
      }
      if (node.data.content?.some((e) => {
        return !MessageEncoder$1.support.includes(e.type);
      })) {
        fake = false;
        break;
      }
    }
    return fake ? await this.handleFakeForwardNode(peer, nodes) : await this.handleForwardNode(peer, nodes);
  }
  parseNodeContent(nodes) {
    return nodes.map((e) => {
      return {
        type: e.type,
        data: {
          ...e.data,
          content: e.data.content ? message2List(e.data.content) : void 0
        }
      };
    });
  }
  async handleFakeForwardNode(peer, nodes) {
    const encoder = new MessageEncoder$1(this.ctx, peer);
    const raw = await encoder.generate(nodes);
    const resid = await this.ctx.app.pmhq.uploadForward(peer, raw.multiMsgItems);
    const uuid = randomUUID();
    try {
      const msg = await this.ctx.ntMsgApi.sendMsg(peer, [{
        elementType: 10,
        elementId: "",
        arkElement: {
          bytesData: JSON.stringify({
            app: "com.tencent.multimsg",
            config: {
              autosize: 1,
              forward: 1,
              round: 1,
              type: "normal",
              width: 300
            },
            desc: "[]",
            extra: JSON.stringify({
              filename: uuid,
              tsum: raw.tsum
            }),
            meta: {
              detail: {
                news: raw.news,
                resid,
                source: raw.source,
                summary: raw.summary,
                uniseq: uuid
              }
            },
            prompt: "[]",
            ver: "0.0.0.5",
            view: "contact"
          })
        }
      }], 1800);
      const msgShortId = this.ctx.store.createMsgShortId({
        chatType: msg.chatType,
        peerUid: msg.peerUid
      }, msg.msgId);
      return { message_id: msgShortId, forward_id: resid };
    } catch (e) {
      this.ctx.logger.error("", e);
      throw new Error(` (res_id: ${resid} `);
    }
  }
  async cloneMsg(msg) {
    this.ctx.logger.info("", msg);
    const sendElements = [];
    for (const ele of msg.elements) {
      sendElements.push(ele);
    }
    if (sendElements.length === 0) {
      this.ctx.logger.warn("clone", msg);
    }
    this.ctx.logger.info("", sendElements);
    try {
      const peer = {
        chatType: ChatType.C2C,
        peerUid: selfInfo.uid
      };
      const nodeMsg = await this.ctx.ntMsgApi.sendMsg(peer, sendElements);
      await this.ctx.sleep(300);
      return nodeMsg;
    } catch (e) {
      this.ctx.logger.warn(e, ",", msg);
    }
  }
  // id
  async handleForwardNode(destPeer, messageNodes) {
    const selfPeer = {
      chatType: ChatType.C2C,
      peerUid: selfInfo.uid
    };
    const nodeMsgIds = [];
    for (const messageNode of messageNodes) {
      const nodeId = messageNode.data.id;
      if (nodeId) {
        const nodeMsg = await this.ctx.store.getMsgInfoByShortId(+nodeId);
        if (!nodeMsg) {
          this.ctx.logger.warn("", nodeId);
          continue;
        }
        nodeMsgIds.push(nodeMsg);
      } else {
        try {
          const { sendElements, deleteAfterSentFiles } = await createSendElements(
            this.ctx,
            messageNode.data.content,
            destPeer
          );
          this.ctx.logger.info("", sendElements);
          const sendElementsSplit = [];
          let splitIndex = 0;
          for (const ele of sendElements) {
            if (!sendElementsSplit[splitIndex]) {
              sendElementsSplit[splitIndex] = [];
            }
            if (ele.elementType === ElementType.File || ele.elementType === ElementType.Video) {
              if (sendElementsSplit[splitIndex].length > 0) {
                splitIndex++;
              }
              sendElementsSplit[splitIndex] = [ele];
              splitIndex++;
            } else {
              sendElementsSplit[splitIndex].push(ele);
            }
          }
          this.ctx.logger.info("", sendElementsSplit);
          for (const eles of sendElementsSplit) {
            const nodeMsg = await this.ctx.app.sendMessage(this.ctx, selfPeer, eles, []);
            if (!nodeMsg) {
              this.ctx.logger.warn("", eles);
              continue;
            }
            nodeMsgIds.push({ msgId: nodeMsg.msgId, peer: selfPeer });
            await this.ctx.sleep(300);
          }
          deleteAfterSentFiles.map((path2) => unlink(path2).then().catch((e) => {
          }));
        } catch (e) {
          this.ctx.logger.error("", e);
        }
      }
    }
    const nodeMsgArray = [];
    let srcPeer;
    let needSendSelf = false;
    for (const { msgId, peer } of nodeMsgIds) {
      const nodeMsg = (await this.ctx.ntMsgApi.getMsgsByMsgId(peer, [msgId])).msgList[0];
      srcPeer ??= { chatType: nodeMsg.chatType, peerUid: nodeMsg.peerUid };
      if (srcPeer.peerUid !== nodeMsg.peerUid) {
        needSendSelf = true;
      }
      nodeMsgArray.push(nodeMsg);
    }
    let retMsgIds = [];
    if (needSendSelf) {
      for (const msg2 of nodeMsgArray) {
        if (msg2.peerUid === selfPeer.peerUid) {
          retMsgIds.push(msg2.msgId);
          continue;
        }
        const clonedMsg = await this.cloneMsg(msg2);
        if (clonedMsg) retMsgIds.push(clonedMsg.msgId);
      }
    } else {
      retMsgIds = nodeMsgArray.map((msg2) => msg2.msgId);
    }
    if (retMsgIds.length === 0) {
      throw Error("");
    }
    const msg = await this.ctx.ntMsgApi.multiForwardMsg(srcPeer, destPeer, retMsgIds);
    const resid = JSON.parse(msg.elements[0].arkElement.bytesData).meta.detail.resid;
    const msgShortId = this.ctx.store.createMsgShortId({
      chatType: msg.chatType,
      peerUid: msg.peerUid
    }, msg.msgId);
    return { message_id: msgShortId, forward_id: resid };
  }
}
class SendPrivateForwardMsg extends SendForwardMsg {
  actionName = ActionName.GoCQHTTP_SendPrivateForwardMsg;
  _handle(payload) {
    payload.message_type = "private";
    return super._handle(payload);
  }
}
class SendGroupForwardMsg extends SendForwardMsg {
  actionName = ActionName.GoCQHTTP_SendGroupForwardMsg;
  _handle(payload) {
    payload.message_type = "group";
    return super._handle(payload);
  }
}
class GetStrangerInfo extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetStrangerInfo;
  payloadSchema = z.object({
    user_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const uin = payload.user_id.toString();
    const data = await this.ctx.ntUserApi.getUserDetailInfoByUin(uin);
    if (data.detail) {
      return {
        user_id: parseInt(data.detail.uin) || 0,
        nickname: data.detail.simpleInfo.coreInfo.nick,
        sex: OB11Entities.sex(data.detail.simpleInfo.baseInfo.sex),
        age: data.detail.simpleInfo.baseInfo.age,
        qid: data.detail.simpleInfo.baseInfo.qid,
        level: data.detail.commonExt.qqLevel && calcQQLevel(data.detail.commonExt.qqLevel) || 0,
        login_days: 0,
        reg_time: data.detail.commonExt.regTime,
        long_nick: data.detail.simpleInfo.baseInfo.longNick,
        city: data.detail.commonExt.city,
        country: data.detail.commonExt.country,
        birthday_year: data.detail.simpleInfo.baseInfo.birthday_year,
        birthday_month: data.detail.simpleInfo.baseInfo.birthday_month,
        birthday_day: data.detail.simpleInfo.baseInfo.birthday_day
      };
    } else {
      return {
        user_id: parseInt(data.info.uin) || 0,
        nickname: data.info.nick,
        sex: OB11Entities.sex(data.info.sex),
        age: data.info.birthday_year === 0 ? 0 : (/* @__PURE__ */ new Date()).getFullYear() - data.info.birthday_year,
        qid: data.info.qid,
        level: data.info.qqLevel && calcQQLevel(data.info.qqLevel) || 0,
        login_days: 0,
        reg_time: data.info.regTime,
        long_nick: data.info.longNick,
        city: data.info.city,
        country: data.info.country,
        birthday_year: data.info.birthday_year,
        birthday_month: data.info.birthday_month,
        birthday_day: data.info.birthday_day
      };
    }
  }
}
class SendLike extends BaseAction {
  actionName = ActionName.SendLike;
  async _handle(payload) {
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin);
    if (!uid) throw new Error("");
    const result = await this.ctx.ntUserApi.like(uid, +payload.times || 1);
    if (result.result !== 0) {
      throw new Error(result.errMsg);
    }
    return null;
  }
}
class SetGroupAddRequest extends BaseAction {
  actionName = ActionName.SetGroupAddRequest;
  payloadSchema = z.object({
    flag: z.string().required(),
    approve: z.union([Boolean, z.transform(String, parseBool)]).default(true),
    reason: z.string()
  });
  async _handle(payload) {
    let flag = payload.flag;
    if (isNumeric(flag)) {
      const res2 = await this.ctx.ntGroupApi.getGroupRequest();
      const normalEnd = res2.normalCount - 1;
      for (const [i, v] of res2.notifies.entries()) {
        if (flag === v.seq) {
          flag = `${v.group.groupCode}|${v.seq}|${v.type}|${i > normalEnd ? "1" : "0"}`;
          break;
        }
      }
      if (flag === payload.flag) {
        throw new Error("flag ");
      }
    }
    const res = await this.ctx.ntGroupApi.handleGroupRequest(
      flag,
      payload.approve ? GroupRequestOperateTypes.Approve : GroupRequestOperateTypes.Reject,
      payload.reason
    );
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class SetGroupLeave extends BaseAction {
  actionName = ActionName.SetGroupLeave;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    await this.ctx.ntGroupApi.quitGroup(payload.group_id.toString());
    return null;
  }
}
class GetGuildList extends BaseAction {
  actionName = ActionName.GetGuildList;
  async _handle() {
    return null;
  }
}
class Debug extends BaseAction {
  actionName = ActionName.Debug;
  async _handle(payload) {
    this.ctx.logger.info("debug call ntqq api", payload);
    const api = this.ctx.get(payload.apiClass);
    return await api[payload.method](...payload.args);
  }
}
class SetFriendAddRequest extends BaseAction {
  actionName = ActionName.SetFriendAddRequest;
  async _handle(payload) {
    const approve = payload.approve?.toString() !== "false";
    const data = payload.flag.split("|");
    if (data.length < 2) {
      throw new Error("flag");
    }
    const uid = data[0];
    const reqTime = data[1];
    await this.ctx.ntFriendApi.handleFriendRequest(uid, reqTime, approve);
    if (payload.remark) {
      await this.ctx.ntFriendApi.setBuddyRemark(uid, payload.remark);
    }
    return null;
  }
}
class SetGroupWholeBan extends BaseAction {
  actionName = ActionName.SetGroupWholeBan;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    enable: z.union([Boolean, z.transform(String, parseBool)]).default(true)
  });
  async _handle(payload) {
    await this.ctx.ntGroupApi.banGroup(payload.group_id.toString(), payload.enable);
    return null;
  }
}
class SetGroupName extends BaseAction {
  actionName = ActionName.SetGroupName;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    group_name: z.string().required()
  });
  async _handle(payload) {
    await this.ctx.ntGroupApi.setGroupName(payload.group_id.toString(), payload.group_name);
    return null;
  }
}
class SetGroupBan extends BaseAction {
  actionName = ActionName.SetGroupBan;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    user_id: z.union([Number, String]).required(),
    duration: z.union([Number, String]).default(30 * 60)
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin, groupCode);
    if (!uid) throw new Error("");
    const res = await this.ctx.ntGroupApi.banMember(groupCode, [
      { uid, timeStamp: +payload.duration }
    ]);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class SetGroupKick extends BaseAction {
  actionName = ActionName.SetGroupKick;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    user_id: z.union([Number, String]).required(),
    reject_add_request: z.union([Boolean, z.transform(String, parseBool)]).default(false)
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin, groupCode);
    if (!uid) throw new Error("");
    await this.ctx.ntGroupApi.kickMember(groupCode, [uid], payload.reject_add_request);
    return null;
  }
}
class SetGroupAdmin extends BaseAction {
  actionName = ActionName.SetGroupAdmin;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    user_id: z.union([Number, String]).required(),
    enable: z.union([Boolean, z.transform(String, parseBool)]).default(true)
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin, groupCode);
    if (!uid) throw new Error("");
    await this.ctx.ntGroupApi.setMemberRole(
      groupCode,
      uid,
      payload.enable ? GroupMemberRole.Admin : GroupMemberRole.Normal
    );
    return null;
  }
}
class SetGroupCard extends BaseAction {
  actionName = ActionName.SetGroupCard;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    user_id: z.union([Number, String]).required(),
    card: z.string().default("")
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin, groupCode);
    if (!uid) throw new Error("");
    await this.ctx.ntGroupApi.setMemberCard(groupCode, uid, payload.card);
    return null;
  }
}
class GetFileBase extends BaseAction {
  payloadSchema = z.object({
    file: z.string()
  });
  async _handle(payload) {
    if (!payload.file) {
      throw new Error("file is required");
    }
    const { enableLocalFile2Url } = this.adapter.config;
    let fileCache = await this.ctx.store.getFileCacheById(payload.file);
    if (!fileCache?.length) {
      fileCache = await this.ctx.store.getFileCacheByName(payload.file);
    }
    if (fileCache?.length) {
      const downloadPath = await this.ctx.ntFileApi.downloadMedia(
        fileCache[0].msgId,
        fileCache[0].chatType,
        fileCache[0].peerUid,
        fileCache[0].elementId,
        "",
        ""
      );
      const res = {
        file: downloadPath,
        url: downloadPath,
        file_size: fileCache[0].fileSize,
        file_name: fileCache[0].fileName
      };
      const peer = {
        chatType: fileCache[0].chatType,
        peerUid: fileCache[0].peerUid,
        guildId: ""
      };
      if (fileCache[0].elementType === ElementType.Pic) {
        const msgList = await this.ctx.ntMsgApi.getMsgsByMsgId(peer, [fileCache[0].msgId]);
        if (msgList.msgList.length === 0) {
          throw new Error("msg not found");
        }
        const msg = msgList.msgList[0];
        const findEle = msg.elements.find((e) => e.elementId === fileCache[0].elementId);
        if (!findEle) {
          throw new Error("element not found");
        }
        res.url = await this.ctx.ntFileApi.getImageUrl(findEle.picElement);
      } else if (fileCache[0].elementType === ElementType.Video) {
        res.url = await this.ctx.ntFileApi.getVideoUrl(peer, fileCache[0].msgId, fileCache[0].elementId);
      }
      if (enableLocalFile2Url && downloadPath && (res.file === res.url || res.url === void 0)) {
        try {
          res.base64 = await readFile(downloadPath, "base64");
        } catch (e) {
          throw new Error(". " + e);
        }
      }
      return res;
    }
    throw new Error("file not found");
  }
}
class GetFile extends GetFileBase {
  actionName = ActionName.GetFile;
  payloadSchema = z.object({
    file: z.string().required(false),
    file_id: z.string().required(false)
  });
  async _handle(payload) {
    payload.file = payload.file || payload.file_id;
    return super._handle(payload);
  }
}
class GetImage extends GetFileBase {
  actionName = ActionName.GetImage;
}
class GetRecord extends GetFileBase {
  actionName = ActionName.GetRecord;
  payloadSchema = z.object({
    file: z.string().required(),
    out_format: z.string().default("mp3")
  });
  async _handle(payload) {
    const res = await super._handle(payload);
    res.file = await decodeSilk(this.ctx, res.file, payload.out_format);
    res.file_name = path__default.basename(res.file);
    res.file_size = (await stat(res.file)).size.toString();
    if (this.adapter.config.enableLocalFile2Url) {
      res.base64 = await readFile(res.file, "base64");
    }
    return res;
  }
}
class MarkMsgAsRead extends BaseAction {
  actionName = ActionName.GoCQHTTP_MarkMsgAsRead;
  payloadSchema = z.object({
    message_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error("msg not found");
    }
    await this.ctx.ntMsgApi.setMsgRead(msg.peer);
    return null;
  }
}
class CleanCache extends BaseAction {
  actionName = ActionName.CleanCache;
  async _handle() {
    return;
  }
}
class GetConfigAction extends BaseAction {
  actionName = ActionName.GetConfig;
  async _handle() {
    return getConfigUtil().getConfig();
  }
}
class SetConfigAction extends BaseAction {
  actionName = ActionName.SetConfig;
  async _handle(payload) {
    getConfigUtil().setConfig(payload);
    await this.ctx.parallel("llob/config-updated", payload);
  }
}
class GetGroupAddRequest extends BaseAction {
  actionName = ActionName.GetGroupIgnoreAddRequest;
  async _handle() {
    throw new Error(" get_group_system_msg API, ");
  }
}
class SetQQAvatar extends BaseAction {
  actionName = ActionName.SetQQAvatar;
  async _handle(payload) {
    const { path: path2, isLocal, errMsg } = await uri2local(this.ctx, payload.file);
    if (errMsg) {
      throw new Error(errMsg);
    }
    if (path2) {
      await checkFileReceived(path2, 5e3);
      const ret = await this.ctx.ntUserApi.setSelfAvatar(path2);
      if (!isLocal) {
        unlink(path2).then().catch((err) => {
        });
      }
      if (!ret) {
        throw `${payload.file},api`;
      }
      if (ret.result === 1004022) {
        throw `${payload.file}`;
      } else if (ret.result !== 0) {
        throw `${payload.file},,${ret["result"]}:${ret["errMsg"]}`;
      }
    } else {
      if (!isLocal) {
        unlink(path2).then().catch((e) => {
          this.ctx.logger.error(`${payload.file},,`);
        });
      }
    }
    return null;
  }
}
class DownloadFile extends BaseAction {
  actionName = ActionName.GoCQHTTP_DownloadFile;
  payloadSchema = z.object({
    url: z.string(),
    base64: z.string(),
    headers: z.union([String, z.array(String)])
  });
  async _handle(payload) {
    const isRandomName = !payload.name;
    const name = payload.name ? path__default.basename(payload.name) : randomUUID();
    const filePath = path__default.join(TEMP_DIR, name);
    if (payload.base64) {
      await fsPromise$1.writeFile(filePath, payload.base64, "base64");
    } else if (payload.url) {
      const headers = this.getHeaders(payload.headers);
      const res = await fetchFile(payload.url, headers);
      await fsPromise$1.writeFile(filePath, res.data);
    } else {
      throw new Error(", ");
    }
    if (fs$1.existsSync(filePath)) {
      if (isRandomName) {
        const md5 = await calculateFileMD5(filePath);
        const newPath = path__default.join(TEMP_DIR, md5);
        await fsPromise$1.rename(filePath, newPath);
        return { file: newPath };
      }
      return { file: filePath };
    } else {
      throw new Error(", ");
    }
  }
  getHeaders(headersIn) {
    const headers = {};
    if (typeof headersIn == "string") {
      headersIn = headersIn.split("[\\r\\n]");
    }
    if (Array.isArray(headersIn)) {
      for (const headerItem of headersIn) {
        const spilt = headerItem.indexOf("=");
        if (spilt < 0) {
          headers[headerItem] = "";
        } else {
          const key2 = headerItem.substring(0, spilt);
          headers[key2] = headerItem.substring(0, spilt + 1);
        }
      }
    }
    if (!headers["Content-Type"]) {
      headers["Content-Type"] = "application/octet-stream";
    }
    return headers;
  }
}
class GetGroupMsgHistory extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupMsgHistory;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    message_seq: z.union([Number, String]),
    count: z.union([Number, String]).default(20),
    reverseOrder: z.union([Boolean, z.transform(String, parseBool)]).default(false)
  });
  async getMessage(peer, count, seq) {
    let msgList;
    if (!seq || +seq === 0) {
      msgList = (await this.ctx.ntMsgApi.getAioFirstViewLatestMsgs(peer, count)).msgList;
    } else {
      msgList = (await this.ctx.ntMsgApi.getMsgsBySeqAndCount(peer, String(seq), count, true, true)).msgList;
    }
    if (!msgList?.length) return;
    const ob11MsgList = await Promise.all(msgList.map((msg) => OB11Entities.message(this.ctx, msg)));
    return filterNullable(ob11MsgList);
  }
  async _handle(payload) {
    const peer = {
      chatType: ChatType.Group,
      peerUid: payload.group_id.toString()
    };
    const messages = [];
    let seq = payload.message_seq;
    let count = +payload.count;
    while (count > 0) {
      const res = await this.getMessage(peer, count, seq);
      if (!res || res.length == 0) break;
      seq = res[0].message_seq - 1;
      count -= res.length;
      messages.unshift(...res);
    }
    if (payload.reverseOrder) messages.reverse();
    return { messages };
  }
}
class GetForwardMsg extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetForwardMsg;
  payloadSchema = z.object({
    message_id: z.string(),
    id: z.string()
  });
  async _handle(payload) {
    const msgId = payload.id || payload.message_id;
    if (!msgId) {
      throw Error("message_id");
    }
    const shortId = await this.ctx.store.getShortIdByMsgId(msgId);
    const msgInfo = await this.ctx.store.getMsgInfoByShortId(shortId || +msgId);
    if (!msgInfo) {
      throw Error("msg not found");
    }
    const multiMsgInfo = await this.ctx.store.getMultiMsgInfo(msgInfo.msgId);
    const rootMsgId = multiMsgInfo[0]?.rootMsgId ?? msgInfo.msgId;
    const peer = multiMsgInfo[0]?.peerUid ? {
      ...msgInfo.peer,
      peerUid: multiMsgInfo[0].peerUid
    } : msgInfo.peer;
    const data = await this.ctx.ntMsgApi.getMultiMsg(peer, rootMsgId, msgInfo.msgId);
    if (data?.result !== 0) {
      throw Error("" + data?.errMsg);
    }
    const messages = await Promise.all(
      data.msgList.map(async (msg) => {
        const res = await OB11Entities.message(this.ctx, msg, rootMsgId, peer);
        if (res) {
          const segments = message2List(res.message);
          for (const item of segments) {
            if (item.type === OB11MessageDataType.Forward) {
              this.ctx.store.addMultiMsgInfo(rootMsgId, item.data.id, peer.peerUid);
            }
          }
          return {
            content: res.message,
            sender: {
              nickname: res.sender.nickname,
              user_id: res.sender.user_id
            },
            time: res.time,
            message_format: res.message_format,
            message_type: res.message_type
          };
        }
      })
    );
    return { messages: filterNullable(messages) };
  }
}
class GetCookies extends BaseAction {
  actionName = ActionName.GetCookies;
  payloadSchema = z.object({
    domain: z.string().required()
  });
  async _handle(payload) {
    const cookiesObject = await this.ctx.ntUserApi.getCookies(payload.domain);
    const cookies = Object.entries(cookiesObject).map(([key2, value]) => `${key2}=${value}`).join("; ");
    const bkn = cookiesObject.skey ? this.ctx.ntWebApi.genBkn(cookiesObject.skey) : "";
    return { cookies, bkn };
  }
}
class SetMsgEmojiLike extends BaseAction {
  actionName = ActionName.SetMsgEmojiLike;
  set = true;
  async _handle(payload) {
    if (!payload.message_id) {
      throw Error("message_id");
    }
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error("msg not found");
    }
    if (!payload.emoji_id) {
      throw new Error("emojiId not found");
    }
    const msgData = (await this.ctx.ntMsgApi.getMsgsByMsgId(msg.peer, [msg.msgId])).msgList;
    if (!msgData || msgData.length == 0 || !msgData[0].msgSeq) {
      throw new Error("find msg by msgid error");
    }
    return await this.ctx.ntMsgApi.setEmojiLike(
      msg.peer,
      msgData[0].msgSeq,
      payload.emoji_id.toString(),
      this.set
    );
  }
}
class UnSetMsgEmojiLike extends SetMsgEmojiLike {
  actionName = ActionName.UnSetMsgEmojiLike;
  set = false;
}
class ForwardSingleMsg extends BaseAction {
  async _handle(payload) {
    if (!payload.message_id) {
      throw Error("message_id");
    }
    if (!(+payload.message_id >= -2147483648 && +payload.message_id <= 2147483647)) {
      const short_msg_id = await this.ctx.store.getShortIdByMsgId(String(payload.message_id));
      if (!short_msg_id) {
        throw new Error(`id${payload.message_id}`);
      }
      payload.message_id = short_msg_id;
    }
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error(`${payload.message_id}`);
    }
    const peer = await createPeer(this.ctx, payload);
    const ret = await this.ctx.ntMsgApi.forwardMsg(msg.peer, peer, [msg.msgId]);
    if (ret.length === 0) {
      throw new Error(``);
    }
    const msgShortId = this.ctx.store.createMsgShortId({
      chatType: ret[0].chatType,
      peerUid: ret[0].peerUid
    }, ret[0].msgId);
    return { message_id: msgShortId };
  }
}
class ForwardFriendSingleMsg extends ForwardSingleMsg {
  actionName = ActionName.ForwardFriendSingleMsg;
}
class ForwardGroupSingleMsg extends ForwardSingleMsg {
  actionName = ActionName.ForwardGroupSingleMsg;
}
class GetEssenceMsgList extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetEssenceMsgList;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const peer = {
      guildId: "",
      chatType: ChatType.Group,
      peerUid: groupCode
    };
    const essence = await this.ctx.ntGroupApi.queryCachedEssenceMsg(groupCode);
    const data = [];
    for (const item of essence.items) {
      const { msgList } = await this.ctx.ntMsgApi.queryMsgsWithFilterExBySeq(peer, String(item.msgSeq), String(0), [await this.ctx.ntUserApi.getUidByUin(item.msgSenderUin)]);
      const sourceMsg = msgList.find((e) => e.msgRandom === String(item.msgRandom));
      if (!sourceMsg) continue;
      data.push({
        sender_id: +item.msgSenderUin,
        sender_nick: item.msgSenderNick,
        sender_time: +sourceMsg.msgTime,
        operator_id: +item.opUin,
        operator_nick: item.opNick,
        operator_time: item.opTime,
        message_id: this.ctx.store.createMsgShortId(peer, sourceMsg.msgId)
      });
    }
    return data;
  }
}
class GetGroupHonorInfo extends BaseAction {
  actionName = ActionName.GetGroupHonorInfo;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    type: z.union(["talkative", "performer", "legend", "strong_newbie", "emotion", "all"]).default("all")
  });
  async _handle(payload) {
    return await this.ctx.ntWebApi.getGroupHonorInfo(payload.group_id.toString(), payload.type);
  }
}
class HandleQuickOperation extends BaseAction {
  actionName = ActionName.GoCQHTTP_HandleQuickOperation;
  async _handle(payload) {
    handleQuickOperation(this.ctx, payload.context, payload.operation).catch((e) => this.ctx.logger.error(e));
    return null;
  }
}
class SetEssenceMsg extends BaseAction {
  actionName = ActionName.GoCQHTTP_SetEssenceMsg;
  payloadSchema = z.object({
    message_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error("msg not found");
    }
    await this.ctx.ntGroupApi.addGroupEssence(msg.peer.peerUid, msg.msgId);
    return null;
  }
}
class DeleteEssenceMsg extends BaseAction {
  actionName = ActionName.GoCQHTTP_DelEssenceMsg;
  payloadSchema = z.object({
    message_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error("msg not found");
    }
    return await this.ctx.ntGroupApi.removeGroupEssence(
      msg.peer.peerUid,
      msg.msgId
    );
  }
}
class GetEvent extends BaseAction {
  actionName = ActionName.GetEvent;
  async _handle(payload) {
    let key2 = "";
    if (payload.key) {
      key2 = payload.key;
    }
    const timeout2 = parseInt(payload.timeout?.toString()) || 0;
    const evts = await getHttpEvent(key2, timeout2);
    return evts;
  }
}
class DelGroupFile extends BaseAction {
  actionName = ActionName.GoCQHTTP_DelGroupFile;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    file_id: z.string().required(),
    busid: z.union([Number, String]).default(102)
  });
  async _handle(payload) {
    await this.ctx.ntGroupApi.deleteGroupFile(payload.group_id.toString(), [payload.file_id], [+payload.busid]);
    return null;
  }
}
class GetGroupSystemMsg extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupSystemMsg;
  async parse(notifies) {
    const data = { invited_requests: [], join_requests: [] };
    for (const notify of notifies) {
      if (notify.type === GroupNotifyType.InvitedByMember) {
        data.invited_requests.push({
          request_id: +notify.seq,
          invitor_uin: Number(await this.ctx.ntUserApi.getUinByUid(notify.user1.uid)),
          invitor_nick: notify.user1.nickName,
          group_id: +notify.group.groupCode,
          group_name: notify.group.groupName,
          checked: notify.status !== GroupNotifyStatus.Unhandle,
          actor: notify.user2?.uid ? Number(await this.ctx.ntUserApi.getUinByUid(notify.user2.uid)) : 0
        });
      } else if (notify.type === GroupNotifyType.RequestJoinNeedAdminiStratorPass) {
        data.join_requests.push({
          request_id: +notify.seq,
          requester_uin: Number(await this.ctx.ntUserApi.getUinByUid(notify.user1.uid)),
          requester_nick: notify.user1.nickName,
          message: notify.postscript,
          group_id: +notify.group.groupCode,
          group_name: notify.group.groupName,
          checked: notify.status !== GroupNotifyStatus.Unhandle,
          actor: notify.user2?.uid ? Number(await this.ctx.ntUserApi.getUinByUid(notify.user2.uid)) : 0
        });
      }
    }
    return data;
  }
  async _handle() {
    const res = await this.ctx.ntGroupApi.getGroupRequest();
    return await this.parse(res.notifies);
  }
}
class CreateGroupFileFolder extends BaseAction {
  actionName = ActionName.GoCQHTTP_CreateGroupFileFolder;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    name: z.string().required()
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.createGroupFileFolder(payload.group_id.toString(), payload.name);
    if (res.resultWithGroupItem.result.retCode !== 0) {
      throw new Error(res.resultWithGroupItem.result.clientWording);
    }
    return {
      folder_id: res.resultWithGroupItem.groupItem.folderInfo.folderId
    };
  }
}
class DelGroupFolder extends BaseAction {
  actionName = ActionName.GoCQHTTP_DelGroupFolder;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    folder_id: z.string().required()
  });
  async _handle(payload) {
    await this.ctx.ntGroupApi.deleteGroupFileFolder(payload.group_id.toString(), payload.folder_id);
    return null;
  }
}
class GetGroupAtAllRemain extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupAtAllRemain;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const data = await this.ctx.ntGroupApi.getGroupRemainAtTimes(payload.group_id.toString());
    return {
      can_at_all: data.atInfo.canAtAll,
      remain_at_all_count_for_group: data.atInfo.RemainAtAllCountForGroup,
      remain_at_all_count_for_uin: data.atInfo.RemainAtAllCountForUin
    };
  }
}
class GetGroupRootFiles extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupRootFiles;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const groupId = payload.group_id.toString();
    const data = [];
    let nextIndex;
    while (nextIndex !== 0) {
      const res = await this.ctx.ntGroupApi.getGroupFileList(groupId, {
        sortType: 1,
        fileCount: 100,
        startIndex: nextIndex ?? 0,
        sortOrder: 2,
        showOnlinedocFolder: 0
      });
      data.push(...res.item);
      nextIndex = res.nextIndex;
    }
    return {
      files: data.filter((item) => item.fileInfo).map((item) => {
        const file = item.fileInfo;
        return {
          group_id: +item.peerId,
          file_id: file.fileId,
          file_name: file.fileName,
          busid: file.busId,
          file_size: +file.fileSize,
          upload_time: file.uploadTime,
          dead_time: file.deadTime,
          modify_time: file.modifyTime,
          download_times: file.downloadTimes,
          uploader: +file.uploaderUin,
          uploader_name: file.uploaderName
        };
      }),
      folders: data.filter((item) => item.folderInfo).map((item) => {
        const folder = item.folderInfo;
        return {
          group_id: +item.peerId,
          folder_id: folder.folderId,
          folder_name: folder.folderName,
          create_time: folder.createTime,
          creator: +folder.createUin,
          creator_name: folder.creatorName,
          total_file_count: folder.totalFileCount
        };
      })
    };
  }
}
class SetOnlineStatus extends BaseAction {
  actionName = ActionName.SetOnlineStatus;
  async _handle(payload) {
    const ret = await this.ctx.ntUserApi.setSelfStatus(
      Number(payload.status),
      Number(payload.ext_status),
      Number(payload.battery_status)
    );
    if (ret.result !== 0) {
      this.ctx.logger.error(ret);
      throw new Error("");
    }
    return null;
  }
}
class SendGroupNotice extends BaseAction {
  actionName = ActionName.GoCQHTTP_SendGroupNotice;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    content: z.string().required(),
    image: z.string(),
    pinned: z.union([Number, String]).default(0),
    confirm_required: z.union([Number, String]).default(1)
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const pinned = +payload.pinned;
    const confirmRequired = +payload.confirm_required;
    let picInfo;
    if (payload.image) {
      const { path: path2, isLocal, success, errMsg } = await uri2local(this.ctx, payload.image, true);
      if (!success) {
        throw new Error(`, : uri2local: ${errMsg}`);
      }
      await checkFileReceived(path2, 5e3);
      const result = await this.ctx.ntGroupApi.uploadGroupBulletinPic(groupCode, path2);
      if (result.errCode !== 0) {
        throw new Error(`, : uploadGroupBulletinPic: ${result.errMsg}`);
      }
      if (!isLocal) {
        unlink$1(path2).then().catch((e) => {
        });
      }
      picInfo = result.picInfo;
    }
    const res = await this.ctx.ntGroupApi.publishGroupBulletin(groupCode, {
      text: encodeURIComponent(payload.content),
      oldFeedsId: "",
      pinned,
      confirmRequired,
      picInfo
    });
    if (res.result !== 0) {
      throw new Error(`, : ${res.errMsg}`);
    }
    return null;
  }
}
class GetProfileLikeMe extends BaseAction {
  actionName = ActionName.GetProfileLikeMe;
  payloadSchema = z.object({
    start: z.union([Number, String]).default(0),
    // 0-1
    count: z.union([Number, String]).default(20)
    // 30
  });
  async _handle(payload) {
    const ret = await this.ctx.ntUserApi.getProfileLikeMe(selfInfo.uid, +payload.start, +payload.count);
    const users = ret.info.userLikeInfos[0].voteInfo.userInfos;
    for (const item of users) {
      try {
        item.uin = Number(await this.ctx.ntUserApi.getUinByUid(item.uid)) || 0;
      } catch (e) {
        item.uin = 0;
      }
    }
    return { users, nextStart: ret.info.start };
  }
}
class FetchEmojiLike extends BaseAction {
  actionName = ActionName.FetchEmojiLike;
  payloadSchema = z.object({
    emojiId: z.string().required(),
    emojiType: z.string().required(),
    message_id: z.union([Number, String]).required(),
    count: z.union([Number, String]).default(20)
  });
  async _handle(payload) {
    const msgInfo = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msgInfo) throw new Error("");
    const { msgSeq } = (await this.ctx.ntMsgApi.getMsgsByMsgId(msgInfo.peer, [msgInfo.msgId])).msgList[0];
    return await this.ctx.ntMsgApi.getMsgEmojiLikesList(msgInfo.peer, msgSeq, payload.emojiId, payload.emojiType, +payload.count);
  }
}
class FetchCustomFace extends BaseAction {
  actionName = ActionName.FetchCustomFace;
  payloadSchema = z.object({
    count: z.union([Number, String]).default(48)
  });
  async _handle(payload) {
    const ret = await this.ctx.ntMsgApi.fetchFavEmojiList(+payload.count);
    return ret.emojiInfoList.map((e) => e.url);
  }
}
class GetFriendMsgHistory extends BaseAction {
  actionName = ActionName.GetFriendMsgHistory;
  payloadSchema = z.object({
    user_id: z.union([Number, String]).required(),
    message_seq: z.union([Number, String]),
    count: z.union([Number, String]).default(20),
    reverseOrder: z.union([Boolean, z.transform(String, parseBool)]).default(false)
  });
  async _handle(payload) {
    const { count, reverseOrder } = payload;
    const uid = await this.ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) throw new Error(``);
    const isBuddy = await this.ctx.ntFriendApi.isBuddy(uid);
    const peer = { chatType: isBuddy ? ChatType.C2C : ChatType.TempC2CFromGroup, peerUid: uid };
    let msgList;
    if (!payload.message_seq || +payload.message_seq === 0) {
      msgList = (await this.ctx.ntMsgApi.getAioFirstViewLatestMsgs(peer, +count)).msgList;
    } else {
      msgList = (await this.ctx.ntMsgApi.getMsgsBySeqAndCount(peer, String(payload.message_seq), +count, true, true)).msgList;
    }
    if (!msgList?.length) throw new Error("");
    if (reverseOrder) msgList.reverse();
    const ob11MsgList = await Promise.all(msgList.map((msg) => OB11Entities.message(this.ctx, msg)));
    return { messages: filterNullable(ob11MsgList) };
  }
}
class GetGroupFilesByFolder extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupFilesByFolder;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    folder_id: z.string().required()
  });
  async _handle(payload) {
    const groupId = payload.group_id.toString();
    const data = [];
    let nextIndex;
    while (nextIndex !== 0) {
      const res = await this.ctx.ntGroupApi.getGroupFileList(groupId, {
        sortType: 1,
        fileCount: 100,
        startIndex: nextIndex ?? 0,
        sortOrder: 2,
        showOnlinedocFolder: 0,
        folderId: payload.folder_id
      });
      data.push(...res.item);
      nextIndex = res.nextIndex;
    }
    return {
      files: data.filter((item) => item.fileInfo).map((item) => {
        const file = item.fileInfo;
        return {
          group_id: +item.peerId,
          file_id: file.fileId,
          file_name: file.fileName,
          busid: file.busId,
          file_size: +file.fileSize,
          upload_time: file.uploadTime,
          dead_time: file.deadTime,
          modify_time: file.modifyTime,
          download_times: file.downloadTimes,
          uploader: +file.uploaderUin,
          uploader_name: file.uploaderName
        };
      }),
      folders: []
    };
  }
}
class GetFriendWithCategory extends BaseAction {
  actionName = ActionName.GetFriendsWithCategory;
  async _handle() {
    const data = await this.ctx.ntFriendApi.getBuddyV2WithCate(true);
    return data.map((item) => {
      return {
        categoryId: item.categoryId,
        categorySortId: item.categorySortId,
        categoryName: item.categroyName,
        categoryMbCount: item.categroyMbCount,
        onlineCount: item.onlineCount,
        buddyList: item.buddyList.map((buddy) => {
          return OB11Entities.friendV2(buddy);
        })
      };
    });
  }
}
class UploadGroupFile extends BaseAction {
  actionName = ActionName.GoCQHTTP_UploadGroupFile;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    file: z.string().required(),
    name: z.string(),
    folder: z.string(),
    folder_id: z.string()
  });
  async _handle(payload) {
    const { success, errMsg, path: path2, fileName } = await uri2local(this.ctx, payload.file);
    if (!success) {
      throw new Error(errMsg);
    }
    const name = payload.name || fileName;
    if (name.includes("/") || name.includes("\\")) {
      throw new Error(` ${name} `);
    }
    const file = await SendElement.file(this.ctx, path2, name, payload.folder ?? payload.folder_id);
    const peer = await createPeer(this.ctx, payload, CreatePeerMode.Group);
    const msg = await this.ctx.app.sendMessage(this.ctx, peer, [file], []);
    return {
      file_id: msg.elements[0].fileElement.fileUuid
    };
  }
}
class UploadPrivateFile extends BaseAction {
  actionName = ActionName.GoCQHTTP_UploadPrivateFile;
  payloadSchema = z.object({
    user_id: z.union([Number, String]).required(),
    file: z.string().required(),
    name: z.string()
  });
  async _handle(payload) {
    const { success, errMsg, path: path2, fileName } = await uri2local(this.ctx, payload.file);
    if (!success) {
      throw new Error(errMsg);
    }
    const name = payload.name || fileName;
    if (name.includes("/") || name.includes("\\")) {
      throw new Error(` ${name} `);
    }
    const sendFileEle = await SendElement.file(this.ctx, path2, name);
    const peer = await createPeer(this.ctx, payload, CreatePeerMode.Private);
    await this.ctx.app.sendMessage(this.ctx, peer, [sendFileEle], []);
    return null;
  }
}
class GetGroupFileUrl extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupFileUrl;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    file_id: z.string().required()
  });
  async _handle(payload) {
    const file = await this.ctx.store.getFileCacheById(payload.file_id);
    if (file.length > 0) {
      const { msgId, chatType, peerUid, elementId } = file[0];
      const path2 = await this.ctx.ntFileApi.downloadMedia(msgId, chatType, peerUid, elementId);
      return {
        url: pathToFileURL(path2).href
      };
    } else {
      const groupId = payload.group_id.toString();
      const modelId = await this.search(groupId, payload.file_id);
      if (modelId) {
        const peer = {
          chatType: ChatType.Group,
          peerUid: groupId,
          guildId: ""
        };
        const path2 = await this.ctx.ntFileApi.downloadFileForModelId(peer, modelId);
        return {
          url: pathToFileURL(path2).href
        };
      }
      throw new Error("file not found");
    }
  }
  async search(groupId, fileId, folderId) {
    let modelId;
    let nextIndex;
    const folders = [];
    while (nextIndex !== 0) {
      const res = await this.ctx.ntGroupApi.getGroupFileList(groupId, {
        sortType: 1,
        fileCount: 100,
        startIndex: nextIndex ?? 0,
        sortOrder: 2,
        showOnlinedocFolder: 0,
        folderId
      });
      const file = res.item.find((item) => item.fileInfo?.fileId === fileId);
      if (file) {
        modelId = file.fileInfo?.fileModelId;
        break;
      }
      folders.push(...res.item.filter((item) => item.folderInfo?.totalFileCount));
      nextIndex = res.nextIndex;
    }
    if (!modelId) {
      for (const item of folders) {
        const res = await this.search(groupId, fileId, item.folderInfo?.folderId);
        if (res) {
          modelId = res;
          break;
        }
      }
    }
    return modelId;
  }
}
class GetGroupNotice extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupNotice;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const data = await this.ctx.ntGroupApi.getGroupBulletinList(payload.group_id.toString());
    const result = [];
    for (const feed of data.feeds) {
      result.push({
        sender_id: +feed.uin,
        publish_time: +feed.publishTime,
        message: {
          text: feed.msg.text,
          images: feed.msg.pics.map((image) => {
            return {
              height: String(image.height),
              width: String(image.width),
              id: image.id
            };
          })
        }
      });
    }
    return result;
  }
}
class GetRobotUinRange extends BaseAction {
  actionName = ActionName.GetRobotUinRange;
  async _handle() {
    return await this.ctx.ntUserApi.getRobotUinRange();
  }
}
class DeleteFriend extends BaseAction {
  actionName = ActionName.GoCQHTTP_DeleteFriend;
  payloadSchema = z.object({
    user_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin);
    if (!uid) throw new Error("");
    await this.ctx.ntFriendApi.delBuddy(uid);
    return null;
  }
}
class OCRImage extends BaseAction {
  actionName = ActionName.GoCQHTTP_OCRImage;
  payloadSchema = z.object({
    image: z.string().required()
  });
  async _handle(payload) {
    const { errMsg, isLocal, path: path2, success } = await uri2local(this.ctx, payload.image, true);
    if (!success) {
      throw new Error(errMsg);
    }
    await access(path2);
    const data = await this.ctx.ntFileApi.ocrImage(path2);
    if (!isLocal) {
      unlink(path2).then().catch((e) => {
      });
    }
    const texts = data.result.map((item) => {
      const ret = {
        text: item.text,
        confidence: 1,
        coordinates: []
      };
      for (let i = 0; i < 4; i++) {
        const pt = item[`pt${i + 1}`];
        ret.coordinates.push({
          x: parseInt(pt.x),
          y: parseInt(pt.y)
        });
      }
      return ret;
    });
    return {
      texts,
      language: ""
    };
  }
}
class GroupPoke extends BaseAction {
  actionName = ActionName.GroupPoke;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    user_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    try {
      await this.ctx.app.pmhq.sendGroupPoke(+payload.group_id, +payload.user_id);
      return null;
    } catch (e) {
      this.ctx.logger.error("pmhq ", e);
    }
    return null;
  }
}
class FriendPoke extends BaseAction {
  actionName = ActionName.FriendPoke;
  payloadSchema = z.object({
    user_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    try {
      await this.ctx.app.pmhq.sendFriendPoke(+payload.user_id);
      return null;
    } catch (e) {
      this.ctx.logger.error("pmhq ", e);
    }
    return null;
  }
}
class GetGroupFileSystemInfo extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupFileSystemInfo;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const groupId = payload.group_id.toString();
    const { groupFileCounts } = await this.ctx.ntGroupApi.getGroupFileCount(groupId);
    const { groupSpaceResult } = await this.ctx.ntGroupApi.getGroupFileSpace(groupId);
    return {
      file_count: groupFileCounts[0],
      limit_count: 1e4,
      used_space: +groupSpaceResult.usedSpace,
      total_space: +groupSpaceResult.totalSpace
    };
  }
}
class GetCredentials extends BaseAction {
  actionName = ActionName.GetCredentials;
  payloadSchema = z.object({
    domain: z.string().required()
  });
  async _handle(payload) {
    const cookiesObject = await this.ctx.ntUserApi.getCookies(payload.domain);
    const cookies = Object.entries(cookiesObject).map(([key2, value]) => `${key2}=${value}`).join("; ");
    const bkn = cookiesObject.skey ? this.ctx.ntWebApi.genBkn(cookiesObject.skey) : "";
    return { cookies, csrf_token: +bkn };
  }
}
class SetGroupSpecialTitle extends BaseAction {
  actionName = ActionName.GoCQHTTP_SetGroupSpecialTitle;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    user_id: z.union([Number, String]).required(),
    special_title: z.string().default("")
  });
  async _handle(payload) {
    const uid = await this.ctx.ntUserApi.getUidByUin(payload.user_id.toString(), payload.group_id.toString());
    if (!uid) throw new Error(`${payload.user_id}uid`);
    const self2 = await this.ctx.ntGroupApi.getGroupMember(payload.group_id.toString(), selfInfo.uid, false);
    if (self2.role !== GroupMemberRole.Owner) {
      throw new Error(`${payload.group_id}`);
    }
    await this.ctx.app.pmhq.setSpecialTitle(+payload.group_id, uid, payload.special_title);
    return null;
  }
}
class SendGroupSign extends BaseAction {
  actionName = ActionName.GoCQHTTP_SendGroupSign;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required()
  });
  async _handle() {
    throw new Error("");
  }
}
class SetRestart extends BaseAction {
  actionName = ActionName.SetRestart;
  async _handle() {
    await this.ctx.ntSystemApi.restart();
  }
}
class SetFriendCategory extends BaseAction {
  actionName = ActionName.SetFriendCategory;
  payloadSchema = z.object({
    user_id: z.union([Number, String]).required(),
    category_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    const uid = await this.ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) throw new Error("");
    return this.ctx.ntFriendApi.setBuddyCategory(uid, +payload.category_id);
  }
}
class SetFriendRemark extends BaseAction {
  actionName = ActionName.SetFriendRemark;
  payloadSchema = z.object({
    user_id: z.union([Number, String]).required(),
    remark: z.string()
  });
  async _handle(payload) {
    const uid = await this.ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) throw new Error("");
    return this.ctx.ntFriendApi.setBuddyRemark(uid, payload.remark || "");
  }
}
class SetGroupMsgMask extends BaseAction {
  actionName = ActionName.SetGroupMsgMask;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    mask: z.union([Number, String]).required()
  });
  async _handle(payload) {
    return this.ctx.ntGroupApi.setGroupMsgMask(payload.group_id.toString(), +payload.mask);
  }
}
class SetGroupRemark extends BaseAction {
  actionName = ActionName.SetGroupRemark;
  async _handle(payload) {
    return this.ctx.ntGroupApi.setGroupRemark(payload.group_id.toString(), payload.remark);
  }
}
class SetQQProfile extends BaseAction {
  actionName = ActionName.GoCQHTTP_SetQQProfile;
  payloadSchema = z.object({
    nickname: z.string(),
    personal_note: z.string()
  });
  async _handle(payload) {
    const old = await this.ctx.ntUserApi.getUserDetailInfoWithBizInfo(selfInfo.uid);
    await this.ctx.ntUserApi.modifySelfProfile({
      nick: payload.nickname ?? old.coreInfo.nick,
      longNick: payload.personal_note ?? old.baseInfo.longNick,
      sex: old.baseInfo.sex,
      birthday: {
        birthday_year: old.baseInfo.birthday_year,
        birthday_month: old.baseInfo.birthday_month,
        birthday_day: old.baseInfo.birthday_day
      },
      location: {
        country: "",
        province: "",
        city: "",
        zone: ""
      }
    });
    return null;
  }
}
class GetProfileLike extends BaseAction {
  actionName = ActionName.GetProfileLike;
  payloadSchema = z.object({
    start: z.union([Number, String]).default(0),
    // 0-1
    count: z.union([Number, String]).default(20)
    // 30
  });
  async _handle(payload) {
    const ret = await this.ctx.ntUserApi.getProfileLike(selfInfo.uid, +payload.start, +payload.count);
    const users = ret.info.userLikeInfos[0].favoriteInfo.userInfos;
    for (const item of users) {
      try {
        item.uin = Number(await this.ctx.ntUserApi.getUinByUid(item.uid)) || 0;
      } catch (e) {
        item.uin = 0;
      }
    }
    return { users, nextStart: ret.info.start };
  }
}
class GetCsrfToken extends BaseAction {
  actionName = ActionName.GetCsrfToken;
  async _handle() {
    const cookiesObject = await this.ctx.ntUserApi.getCookies("h5.qzone.qq.com");
    const bkn = this.ctx.ntWebApi.genBkn(cookiesObject.skey);
    return { token: +bkn };
  }
}
class SetGroupPortrait extends BaseAction {
  actionName = ActionName.GoCQHTTP_SetGroupPortrait;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    file: z.string().required()
  });
  async _handle(payload) {
    const { path: path2, isLocal, errMsg } = await uri2local(this.ctx, payload.file);
    if (errMsg) {
      throw new Error(errMsg);
    }
    const groupCode = payload.group_id.toString();
    const res = await this.ctx.ntGroupApi.setGroupAvatar(groupCode, path2);
    if (!isLocal) {
      unlink(path2).then().catch((e) => {
      });
    }
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class MoveGroupFile extends BaseAction {
  actionName = ActionName.MoveGroupFile;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    file_id: z.string().required(),
    parent_directory: z.string().required(),
    target_directory: z.string().required()
  });
  async _handle(payload) {
    const groupId = payload.group_id.toString();
    const res = await this.ctx.ntGroupApi.moveGroupFile(groupId, [payload.file_id], payload.parent_directory, payload.target_directory);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class GetGroupShutList extends BaseAction {
  actionName = ActionName.GetGroupShutList;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required()
  });
  async _handle(payload) {
    try {
      const groupCode = payload.group_id.toString();
      return await this.ctx.ntGroupApi.getGroupShutUpMemberList(groupCode);
    } catch (e) {
      if (e instanceof DetailedError) {
        if (e.data.result === 120271006) {
          return [];
        } else {
          throw new Error(e.data.errMsg);
        }
      }
      throw e;
    }
  }
}
class RenameGroupFileFolder extends BaseAction {
  actionName = ActionName.RenameGroupFileFolder;
  payloadSchema = z.object({
    group_id: z.union([Number, String]).required(),
    folder_id: z.string().required(),
    new_folder_name: z.string().required()
  });
  async _handle(payload) {
    const groupId = payload.group_id.toString();
    const res = await this.ctx.ntGroupApi.renameGroupFolder(groupId, payload.folder_id, payload.new_folder_name);
    if (res.resultWithGroupItem.result.retCode !== 0) {
      throw new Error(res.resultWithGroupItem.result.clientWording);
    }
    return null;
  }
}
var __defProp$4 = Object.defineProperty;
var __name$4 = (target, value) => __defProp$4(target, "name", { value, configurable: true });
var Type;
((Type2) => {
  Type2.kType = Symbol.for("minato.type");
  Type2.Any = fromField("expr");
  Type2.Boolean = fromField("boolean");
  Type2.Number = fromField("double");
  Type2.String = fromField("string");
  Type2.Object = /* @__PURE__ */ __name$4((obj) => defineProperty({
    type: "json",
    inner: globalThis.Object.keys(obj ?? {}).length ? mapValues(obj, (value) => isType(value) ? value : fromField(value)) : void 0
  }, Type2.kType, true), "Object");
  Type2.Array = /* @__PURE__ */ __name$4((type2) => defineProperty({
    type: "json",
    inner: type2,
    array: true
  }, Type2.kType, true), "Array");
  function fromPrimitive(value) {
    if (isNullable(value)) return fromField("expr");
    else if (typeof value === "number") return Type2.Number;
    else if (typeof value === "string") return Type2.String;
    else if (typeof value === "boolean") return Type2.Boolean;
    else if (typeof value === "bigint") return fromField("bigint");
    else if (value instanceof Date) return fromField("timestamp");
    else if (Binary.is(value)) return fromField("binary");
    else if (globalThis.Array.isArray(value)) return (0, Type2.Array)(value.length ? fromPrimitive(value[0]) : void 0);
    else if (typeof value === "object") return fromField("json");
    throw new TypeError(`invalid primitive: ${value}`);
  }
  Type2.fromPrimitive = fromPrimitive;
  __name$4(fromPrimitive, "fromPrimitive");
  function fromField(field) {
    if (isType(field)) return field;
    else if (field === "array") return (0, Type2.Array)();
    else if (field === "object") return (0, Type2.Object)();
    else if (typeof field === "string") return defineProperty({ type: field }, Type2.kType, true);
    else if (field.type) return field.type;
    else if (field.expr?.[Type2.kType]) return field.expr[Type2.kType];
    throw new TypeError(`invalid field: ${field}`);
  }
  Type2.fromField = fromField;
  __name$4(fromField, "fromField");
  function fromTerm(value, initial) {
    if (isEvalExpr(value)) return value[Type2.kType] ?? initial ?? fromField("expr");
    else return fromPrimitive(value);
  }
  Type2.fromTerm = fromTerm;
  __name$4(fromTerm, "fromTerm");
  function fromTerms(values, initial) {
    return values.map((x) => fromTerm(x)).find((type2) => type2.type !== "expr") ?? initial ?? fromField("expr");
  }
  Type2.fromTerms = fromTerms;
  __name$4(fromTerms, "fromTerms");
  function isType(value) {
    return value?.[Type2.kType] === true;
  }
  Type2.isType = isType;
  __name$4(isType, "isType");
  function isArray(type2) {
    return type2?.type === "json" && type2?.array;
  }
  Type2.isArray = isArray;
  __name$4(isArray, "isArray");
  function getInner(type2, key2) {
    if (!type2?.inner) return;
    if (isArray(type2)) return type2.inner;
    if (isNullable(key2)) return;
    if (type2.inner[key2]) return type2.inner[key2];
    if (key2.includes(".")) return key2.split(".").reduce((t, k) => getInner(t, k), type2);
    const fields = globalThis.Object.entries(type2.inner).filter(([k]) => k.startsWith(`${key2}.`)).map(([k, v]) => [k.slice(key2.length + 1), v]);
    return fields.length ? (0, Type2.Object)(globalThis.Object.fromEntries(fields)) : void 0;
  }
  Type2.getInner = getInner;
  __name$4(getInner, "getInner");
  function transform(value, type2, callback) {
    if (!isNullable(value) && type2?.inner) {
      if (Type2.isArray(type2)) {
        return value.map((x) => callback(x, Type2.getInner(type2))).filter((x) => !type2.ignoreNull || !isEmpty(x));
      } else {
        if (type2.ignoreNull && isEmpty(value)) return null;
        return mapValues(value, (x, k) => callback(x, Type2.getInner(type2, k)));
      }
    }
    return value;
  }
  Type2.transform = transform;
  __name$4(transform, "transform");
})(Type || (Type = {}));
var Relation;
((Relation4) => {
  Relation4.Type = ["oneToOne", "oneToMany", "manyToOne", "manyToMany"];
  function buildAssociationTable(...tables) {
    return "_" + tables.sort().join("_");
  }
  Relation4.buildAssociationTable = buildAssociationTable;
  __name$4(buildAssociationTable, "buildAssociationTable");
  function buildAssociationKey(key2, table) {
    return `${table}.${key2}`;
  }
  Relation4.buildAssociationKey = buildAssociationKey;
  __name$4(buildAssociationKey, "buildAssociationKey");
  function buildSharedKey(field, reference) {
    return [field, reference].sort().join("_");
  }
  Relation4.buildSharedKey = buildSharedKey;
  __name$4(buildSharedKey, "buildSharedKey");
  function parse3(def, key2, model, relmodel, subprimary) {
    const shared = !def.shared ? {} : typeof def.shared === "string" ? { [def.shared]: def.shared } : Array.isArray(def.shared) ? Object.fromEntries(def.shared.map((x) => [x, x])) : def.shared;
    const fields = def.fields ?? (subprimary || def.type === "manyToOne" || def.type === "oneToOne" && (model.name === relmodel.name || !makeArray(relmodel.primary).every((key22) => !relmodel.fields[key22]?.nullable)) ? makeArray(relmodel.primary).map((x) => `${key2}.${x}`) : model.primary);
    const relation = {
      type: def.type,
      table: def.table ?? relmodel.name,
      fields: makeArray(fields),
      shared,
      references: makeArray(def.references ?? relmodel.primary),
      required: def.type !== "manyToOne" && model.name !== relmodel.name && makeArray(fields).every((key22) => !model.fields[key22]?.nullable || makeArray(model.primary).includes(key22))
    };
    Object.entries(shared).forEach(([k, v]) => {
      relation.fields = relation.fields.filter((x) => x !== k);
      relation.references = relation.references.filter((x) => x !== v);
    });
    const inverse = {
      type: relation.type === "oneToMany" ? "manyToOne" : relation.type === "manyToOne" ? "oneToMany" : relation.type,
      table: model.name,
      fields: relation.references,
      references: relation.fields,
      shared: Object.fromEntries(Object.entries(shared).map(([k, v]) => [v, k])),
      required: relation.type !== "oneToMany" && relation.references.every((key22) => !relmodel.fields[key22]?.nullable || makeArray(relmodel.primary).includes(key22))
    };
    if (inverse.required) relation.required = false;
    return [relation, inverse];
  }
  Relation4.parse = parse3;
  __name$4(parse3, "parse");
})(Relation || (Relation = {}));
var Field$1;
((Field2) => {
  Field2.number = ["integer", "unsigned", "float", "double", "decimal"];
  Field2.string = ["char", "string", "text"];
  Field2.boolean = ["boolean"];
  Field2.date = ["timestamp", "date", "time"];
  Field2.object = ["list", "json"];
  const regexp = /^(\w+)(?:\((.+)\))?$/;
  function parse3(source2) {
    if (typeof source2 === "function") throw new TypeError("view field is not supported");
    if (typeof source2 !== "string") {
      return {
        initial: null,
        deftype: source2.type,
        ...source2,
        type: Type.fromField(source2.type)
      };
    }
    const capture = regexp.exec(source2);
    if (!capture) throw new TypeError("invalid field definition");
    const type2 = capture[1];
    const args = (capture[2] || "").split(",");
    const field = { deftype: type2, type: Type.fromField(type2) };
    if (field.initial === void 0) field.initial = getInitial(type2);
    if (type2 === "decimal") {
      field.precision = +args[0];
      field.scale = +args[1];
    } else if (args[0]) {
      field.length = +args[0];
    }
    return field;
  }
  Field2.parse = parse3;
  __name$4(parse3, "parse");
  function getInitial(type2, initial) {
    if (initial === void 0) {
      if (Field2.number.includes(type2)) return 0;
      if (Field2.string.includes(type2)) return "";
      if (type2 === "list") return [];
      if (type2 === "json") return {};
    }
    return initial;
  }
  Field2.getInitial = getInitial;
  __name$4(getInitial, "getInitial");
  function available(field) {
    return !!field && !field.deprecated && !field.relation && field.deftype !== "expr";
  }
  Field2.available = available;
  __name$4(available, "available");
})(Field$1 || (Field$1 = {}));
var Model = class {
  constructor(name) {
    this.name = name;
    this.autoInc = false;
    this.primary = "id";
    this.unique = [];
    this.indexes = [];
    this.foreign = {};
  }
  static {
    __name$4(this, "Model");
  }
  fields = {};
  migrations = /* @__PURE__ */ new Map();
  extend(fields = {}, config = {}) {
    const { primary, autoInc, unique = [], indexes = [], foreign, callback } = config;
    this.primary = primary || this.primary;
    this.autoInc = autoInc || this.autoInc;
    unique.forEach((key2) => this.unique.includes(key2) || this.unique.push(key2));
    indexes.map((x) => this.parseIndex(x)).forEach((index) => this.indexes.some((ind) => deepEqual(ind, index)) || this.indexes.push(index));
    Object.assign(this.foreign, foreign);
    if (callback) this.migrations.set(callback, Object.keys(fields));
    for (const key2 in fields) {
      this.fields[key2] = Field$1.parse(fields[key2]);
      this.fields[key2].deprecated = !!callback;
    }
    if (typeof this.primary === "string" && this.fields[this.primary]?.deftype === "primary") {
      this.autoInc = true;
    }
    this.checkIndex(this.primary);
    this.unique.forEach((index) => this.checkIndex(index));
    this.indexes.forEach((index) => this.checkIndex(index));
  }
  parseIndex(index) {
    if (typeof index === "string" || Array.isArray(index)) {
      return {
        name: `index:${this.name}:` + makeArray(index).join("+"),
        unique: false,
        keys: Object.fromEntries(makeArray(index).map((key2) => [key2, "asc"]))
      };
    } else {
      return {
        name: index.name ?? `index:${this.name}:` + Object.keys(index.keys).join("+"),
        unique: index.unique ?? false,
        keys: index.keys
      };
    }
  }
  checkIndex(index) {
    for (const key2 of typeof index === "string" || Array.isArray(index) ? makeArray(index) : Object.keys(index.keys)) {
      if (!this.fields[key2]) {
        throw new TypeError(`missing field definition for index key "${key2}"`);
      }
    }
  }
  resolveValue(field, value) {
    if (isNullable(value)) return value;
    if (typeof field === "string") field = this.fields[field];
    if (field) field = Type.fromField(field);
    if (field?.type === "time") {
      const date = /* @__PURE__ */ new Date(0);
      date.setHours(value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
      return date;
    } else if (field?.type === "date") {
      const date = new Date(value);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    return value;
  }
  resolveModel(obj, model) {
    if (!model) model = this.getType();
    if (isNullable(obj) || !model.inner) return obj;
    if (Type.isArray(model) && Array.isArray(obj)) {
      return obj.map((x) => this.resolveModel(x, Type.getInner(model)));
    }
    const result = {};
    for (const key2 in obj) {
      const type2 = Type.getInner(model, key2);
      if (!type2 || isNullable(obj[key2])) {
        result[key2] = obj[key2];
      } else if (type2.type !== "json") {
        result[key2] = this.resolveValue(type2, obj[key2]);
      } else if (isEvalExpr(obj[key2])) {
        result[key2] = obj[key2];
      } else if (type2.inner && Type.isArray(type2) && Array.isArray(obj[key2])) {
        result[key2] = obj[key2].map((x) => this.resolveModel(x, Type.getInner(type2)));
      } else if (type2.inner) {
        result[key2] = this.resolveModel(obj[key2], type2);
      } else {
        result[key2] = obj[key2];
      }
    }
    return result;
  }
  format(source2, strict = true, prefix = "", result = {}) {
    const fields = Object.keys(this.fields).filter((key2) => !this.fields[key2].relation);
    Object.entries(source2).map(([key2, value]) => {
      key2 = prefix + key2;
      if (value === void 0) return;
      if (fields.includes(key2)) {
        result[key2] = value;
        return;
      }
      const field = fields.find((field2) => key2.startsWith(field2 + "."));
      if (field) {
        result[key2] = value;
      } else if (isFlat(value)) {
        if (strict && (typeof value !== "object" || Object.keys(value).length)) {
          throw new TypeError(`unknown field "${key2}" in model ${this.name}`);
        }
      } else {
        this.format(value, strict, key2 + ".", result);
      }
    });
    return strict && prefix === "" ? this.resolveModel(result) : result;
  }
  parse(source2, strict = true, prefix = "", result = {}) {
    const fields = Object.keys(this.fields).filter((key2) => !this.fields[key2].relation);
    if (strict && prefix === "") {
      Object.assign(result, unravel(
        Object.fromEntries(fields.filter((key2) => key2.includes(".")).map((key2) => [key2.slice(0, key2.lastIndexOf(".")), {}]))
      ));
    }
    for (const key2 in source2) {
      let node = result;
      const segments = key2.split(".").reverse();
      for (let index = segments.length - 1; index > 0; index--) {
        const segment = segments[index];
        node = node[segment] ??= {};
      }
      if (key2 in source2) {
        const fullKey = prefix + key2, value = source2[key2];
        const field = fields.find((field2) => fullKey === field2 || fullKey.startsWith(field2 + "."));
        if (field) {
          node[segments[0]] = value;
        } else if (isFlat(value)) {
          if (strict) {
            throw new TypeError(`unknown field "${fullKey}" in model ${this.name}`);
          } else {
            node[segments[0]] = value;
          }
        } else {
          this.parse(value, strict, fullKey + ".", node[segments[0]] ??= {});
        }
      }
    }
    return strict && prefix === "" ? this.resolveModel(result) : result;
  }
  create(data) {
    const result = {};
    const keys = makeArray(this.primary);
    for (const key2 in this.fields) {
      if (!Field$1.available(this.fields[key2])) continue;
      const { initial } = this.fields[key2];
      if (!keys.includes(key2) && !isNullable(initial)) {
        result[key2] = clone(initial);
      }
    }
    return this.parse({ ...result, ...data });
  }
  avaiableFields() {
    return filterKeys(this.fields, (_, field) => Field$1.available(field));
  }
  getType(key2) {
    if (!this.type) defineProperty(this, "type", Type.Object(mapValues(this.fields, (field) => Type.fromField(field))));
    return key2 ? Type.getInner(this.type, key2) : this.type;
  }
};
function isEvalExpr(value) {
  return value && Object.keys(value).some((key2) => key2.startsWith("$"));
}
__name$4(isEvalExpr, "isEvalExpr");
var isUpdateExpr = isEvalExpr;
function isAggrExpr(expr) {
  return expr["$"] || expr["$select"];
}
__name$4(isAggrExpr, "isAggrExpr");
function hasSubquery(value) {
  if (!isEvalExpr(value)) return false;
  return Object.entries(value).filter(([k]) => k.startsWith("$")).some(([k, v]) => {
    if (isNullable(v) || isComparable(v)) return false;
    if (k === "$exec") return true;
    if (isEvalExpr(v)) return hasSubquery(v);
    if (Array.isArray(v)) return v.some((x) => hasSubquery(x));
    if (typeof v === "object") return Object.values(v).some((x) => hasSubquery(x));
    return false;
  });
}
__name$4(hasSubquery, "hasSubquery");
var kExpr = Symbol("expr");
var Eval3 = /* @__PURE__ */ __name$4((key2, value, type2) => defineProperty(defineProperty({ ["$" + key2]: value }, kExpr, true), Type.kType, type2), "Eval");
var operators = /* @__PURE__ */ Object.create(null);
operators["$"] = getRecursive;
function unary(key2, callback, type2) {
  operators[`$${key2}`] = callback;
  return (value) => Eval3(key2, value, typeof type2 === "function" ? type2(value) : type2);
}
__name$4(unary, "unary");
function multary(key2, callback, type2) {
  operators[`$${key2}`] = callback;
  return (...args) => Eval3(key2, args, typeof type2 === "function" ? type2(...args) : type2);
}
__name$4(multary, "multary");
function comparator(key2, callback) {
  operators[`$${key2}`] = (args, data) => {
    const left = executeEval(data, args[0]);
    const right = executeEval(data, args[1]);
    if (isNullable(left) || isNullable(right)) return true;
    return callback(left.valueOf(), right.valueOf());
  };
  return (...args) => Eval3(key2, args, Type.Boolean);
}
__name$4(comparator, "comparator");
Eval3.switch = (branches, vDefault) => Eval3("switch", { branches, default: vDefault }, Type.fromTerm(branches[0]));
operators.$switch = (args, data) => {
  for (const branch of args.branches) {
    if (executeEval(data, branch.case)) return executeEval(data, branch.then);
  }
  return executeEval(data, args.default);
};
Eval3.ignoreNull = (expr) => (expr["$ignoreNull"] = true, expr[Type.kType].ignoreNull = true, expr);
Eval3.select = multary("select", (args, table) => args.map((arg) => executeEval(table, arg)), Type.Array());
Eval3.query = (row, query, expr = true) => ({ $expr: expr, ...query });
Eval3.exec = unary("exec", (expr, data) => expr.driver.executeSelection(expr, data), (expr) => Type.fromTerm(expr.args[0]));
Eval3.if = multary("if", ([cond, vThen, vElse], data) => executeEval(data, cond) ? executeEval(data, vThen) : executeEval(data, vElse), (cond, vThen, vElse) => Type.fromTerm(vThen));
Eval3.ifNull = multary("ifNull", ([value, fallback], data) => executeEval(data, value) ?? executeEval(data, fallback), (value) => Type.fromTerm(value));
Eval3.add = multary("add", (args, data) => args.reduce((prev, curr) => prev + executeEval(data, curr), 0), Type.Number);
Eval3.mul = Eval3.multiply = multary("multiply", (args, data) => args.reduce((prev, curr) => prev * executeEval(data, curr), 1), Type.Number);
Eval3.sub = Eval3.subtract = multary("subtract", ([left, right], data) => executeEval(data, left) - executeEval(data, right), Type.Number);
Eval3.div = Eval3.divide = multary("divide", ([left, right], data) => executeEval(data, left) / executeEval(data, right), Type.Number);
Eval3.mod = Eval3.modulo = multary("modulo", ([left, right], data) => executeEval(data, left) % executeEval(data, right), Type.Number);
Eval3.abs = unary("abs", (arg, data) => Math.abs(executeEval(data, arg)), Type.Number);
Eval3.floor = unary("floor", (arg, data) => Math.floor(executeEval(data, arg)), Type.Number);
Eval3.ceil = unary("ceil", (arg, data) => Math.ceil(executeEval(data, arg)), Type.Number);
Eval3.round = unary("round", (arg, data) => Math.round(executeEval(data, arg)), Type.Number);
Eval3.exp = unary("exp", (arg, data) => Math.exp(executeEval(data, arg)), Type.Number);
Eval3.log = multary("log", ([left, right], data) => Math.log(executeEval(data, left)) / Math.log(executeEval(data, right ?? Math.E)), Type.Number);
Eval3.pow = Eval3.power = multary("power", ([left, right], data) => Math.pow(executeEval(data, left), executeEval(data, right)), Type.Number);
Eval3.random = () => Eval3("random", {}, Type.Number);
operators.$random = () => Math.random();
Eval3.eq = comparator("eq", (left, right) => left === right);
Eval3.ne = comparator("ne", (left, right) => left !== right);
Eval3.gt = comparator("gt", (left, right) => left > right);
Eval3.ge = Eval3.gte = comparator("gte", (left, right) => left >= right);
Eval3.lt = comparator("lt", (left, right) => left < right);
Eval3.le = Eval3.lte = comparator("lte", (left, right) => left <= right);
Eval3.in = (value, array) => Eval3("in", [Array.isArray(value) ? Eval3.select(...value) : value, array], Type.Boolean);
operators.$in = ([value, array], data) => {
  const val = executeEval(data, value), arr = executeEval(data, array);
  if (typeof val === "object") return arr.includes(val) || arr.map(JSON.stringify).includes(JSON.stringify(val));
  return arr.includes(val);
};
Eval3.nin = (value, array) => Eval3("nin", [Array.isArray(value) ? Eval3.select(...value) : value, array], Type.Boolean);
operators.$nin = ([value, array], data) => {
  const val = executeEval(data, value), arr = executeEval(data, array);
  if (typeof val === "object") return !arr.includes(val) && !arr.map(JSON.stringify).includes(JSON.stringify(val));
  return !arr.includes(val);
};
Eval3.concat = multary("concat", (args, data) => args.map((arg) => executeEval(data, arg)).join(""), Type.String);
Eval3.regex = multary("regex", ([value, regex, flags], data) => makeRegExp(executeEval(data, regex), flags).test(executeEval(data, value)), Type.Boolean);
Eval3.and = multary("and", (args, data) => {
  const type2 = Type.fromTerms(args, Type.Boolean);
  if (Field$1.boolean.includes(type2.type)) return args.every((arg) => executeEval(data, arg));
  else if (Field$1.number.includes(type2.type)) return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev & curr);
  else if (type2.type === "bigint") return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev & curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval3.or = multary("or", (args, data) => {
  const type2 = Type.fromTerms(args, Type.Boolean);
  if (Field$1.boolean.includes(type2.type)) return args.some((arg) => executeEval(data, arg));
  else if (Field$1.number.includes(type2.type)) return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev | curr);
  else if (type2.type === "bigint") return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev | curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval3.not = unary("not", (value, data) => {
  const type2 = Type.fromTerms([value], Type.Boolean);
  if (Field$1.boolean.includes(type2.type)) return !executeEval(data, value);
  else if (Field$1.number.includes(type2.type)) return ~executeEval(data, value);
  else if (type2.type === "bigint") return ~BigInt(executeEval(data, value) ?? 0);
}, (value) => Type.fromTerms([value], Type.Boolean));
Eval3.xor = multary("xor", (args, data) => {
  const type2 = Type.fromTerms(args, Type.Boolean);
  if (Field$1.boolean.includes(type2.type)) return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev !== curr);
  else if (Field$1.number.includes(type2.type)) return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev ^ curr);
  else if (type2.type === "bigint") return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev ^ curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval3.literal = multary("literal", ([value, type2]) => value, (value, type2) => type2 ? Type.fromField(type2) : Type.fromTerm(value));
Eval3.number = unary("number", (arg, data) => {
  const value = executeEval(data, arg);
  return value instanceof Date ? Math.floor(value.valueOf() / 1e3) : Number(value);
}, Type.Number);
var unwrapAggr = /* @__PURE__ */ __name$4((expr, def) => {
  let type2 = Type.fromTerm(expr);
  type2 = Type.getInner(type2) ?? type2;
  return def && type2.type === "expr" ? def : type2;
}, "unwrapAggr");
Eval3.sum = unary("sum", (expr, table) => Array.isArray(table) ? table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) : Array.from(executeEval(table, expr)).reduce((prev, curr) => prev + curr, 0), Type.Number);
Eval3.avg = unary("avg", (expr, table) => {
  if (Array.isArray(table)) return table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) / table.length;
  else {
    const array = Array.from(executeEval(table, expr));
    return array.reduce((prev, curr) => prev + curr, 0) / array.length;
  }
}, Type.Number);
Eval3.max = unary("max", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).reduce((x, y) => x > y ? x : y, -Infinity) : Array.from(executeEval(table, expr)).reduce((x, y) => x > y ? x : y, -Infinity), (expr) => unwrapAggr(expr, Type.Number));
Eval3.min = unary("min", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).reduce((x, y) => x < y ? x : y, Infinity) : Array.from(executeEval(table, expr)).reduce((x, y) => x < y ? x : y, Infinity), (expr) => unwrapAggr(expr, Type.Number));
Eval3.count = unary("count", (expr, table) => new Set(table.map((data) => executeAggr(expr, data))).size, Type.Number);
defineProperty(Eval3, "length", unary("length", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).length : Array.from(executeEval(table, expr)).length, Type.Number));
operators.$object = (field, table) => mapValues(field, (value) => executeAggr(value, table));
Eval3.object = (fields) => {
  if (fields.$model) {
    const modelFields = Object.entries(fields.$model.fields);
    const prefix = fields.$prefix;
    fields = Object.fromEntries(modelFields.filter(([, field]) => Field$1.available(field)).filter(([path2]) => path2.startsWith(prefix)).map(([k]) => [k.slice(prefix.length), fields[k.slice(prefix.length)]]));
    return Eval3("object", fields, Type.Object(mapValues(fields, (value) => Type.fromTerm(value))));
  }
  return Eval3("object", fields, Type.Object(mapValues(fields, (value) => Type.fromTerm(value))));
};
Eval3.array = unary("array", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).filter((x) => !expr[Type.kType]?.ignoreNull || !isEmpty(x)) : Array.from(executeEval(table, expr)).filter((x) => !expr[Type.kType]?.ignoreNull || !isEmpty(x)), (expr) => Type.Array(Type.fromTerm(expr)));
Eval3.get = multary("get", ([x, key2], data) => executeEval(data, x)?.[executeEval(data, key2)], (x, key2) => Type.getInner(Type.fromTerm(x), key2) ?? Type.Any);
function getRecursive(args, data) {
  if (typeof args === "string") {
    return getRecursive(["_", args], data);
  }
  const [ref2, path2] = args;
  let value = data[ref2];
  if (!value) return value;
  if (path2 in value) return value[path2];
  const prefix = Object.keys(value).find((s) => path2.startsWith(s + ".")) || path2.split(".", 1)[0];
  const rest = path2.slice(prefix.length + 1).split(".").filter(Boolean);
  rest.unshift(prefix);
  for (const key2 of rest) {
    value = value[key2];
    if (!value) return value;
  }
  return value;
}
__name$4(getRecursive, "getRecursive");
function executeEvalExpr(expr, data) {
  for (const key2 in expr) {
    if (key2 in operators) {
      return operators[key2](expr[key2], data);
    }
  }
  return expr;
}
__name$4(executeEvalExpr, "executeEvalExpr");
function executeAggr(expr, data) {
  if (typeof expr === "string") {
    return getRecursive(expr, data);
  }
  return executeEvalExpr(expr, data);
}
__name$4(executeAggr, "executeAggr");
function executeEval(data, expr) {
  if (isComparable(expr) || isNullable(expr)) {
    return expr;
  }
  if (Array.isArray(expr)) {
    return expr.map((item) => executeEval(data, item));
  }
  return executeEvalExpr(expr, data);
}
__name$4(executeEval, "executeEval");
function executeUpdate(data, update, ref2) {
  for (const key2 in update) {
    let root2 = data;
    const path2 = key2.split(".");
    const last = path2.pop();
    for (const key22 of path2) {
      root2 = root2[key22] ||= {};
    }
    root2[last] = executeEval({ [ref2]: data, _: data }, update[key2]);
  }
  return data;
}
__name$4(executeUpdate, "executeUpdate");
function isComparable(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "bigint" || value instanceof Date;
}
__name$4(isComparable, "isComparable");
function isFlat(value) {
  return !value || typeof value !== "object" || isEvalExpr(value) || Object.keys(value).length === 0 || Array.isArray(value) || value instanceof Date || value instanceof RegExp || Binary.isSource(value);
}
__name$4(isFlat, "isFlat");
var letters = "abcdefghijklmnopqrstuvwxyz";
function randomId() {
  return Array(8).fill(0).map(() => letters[Math.floor(Math.random() * letters.length)]).join("");
}
__name$4(randomId, "randomId");
function makeRegExp(source2, flags) {
  return source2 instanceof RegExp && !flags ? source2 : new RegExp(source2.source ?? source2, flags ?? source2.flags);
}
__name$4(makeRegExp, "makeRegExp");
function unravel(source2, init2) {
  const result = {};
  for (const key2 in source2) {
    let node = result;
    const segments = key2.split(".").reverse();
    for (let index = segments.length - 1; index > 0; index--) {
      const segment = segments[index];
      node = node[segment] ??= {};
      if (init2) node = init2(node);
    }
    node[segments[0]] = source2[key2];
  }
  return result;
}
__name$4(unravel, "unravel");
function flatten(source2, prefix = "", ignore = isFlat) {
  const result = {};
  for (const key2 in source2) {
    const value = source2[key2];
    if (ignore(value)) {
      result[`${prefix}${key2}`] = value;
    } else {
      Object.assign(result, flatten(value, `${prefix}${key2}.`, ignore));
    }
  }
  return result;
}
__name$4(flatten, "flatten");
function getCell(row, path2) {
  if (path2 in row) return row[path2];
  if (path2.includes(".")) {
    const index = path2.indexOf(".");
    return getCell(row[path2.slice(0, index)] ?? {}, path2.slice(index + 1));
  } else {
    return row[path2];
  }
}
__name$4(getCell, "getCell");
function isEmpty(value) {
  if (isNullable(value)) return true;
  if (typeof value !== "object") return false;
  for (const key2 in value) {
    if (!isEmpty(value[key2])) return false;
  }
  return true;
}
__name$4(isEmpty, "isEmpty");
var createRow = /* @__PURE__ */ __name$4((ref2, expr = {}, prefix = "", model, intermediate) => new Proxy(expr, {
  get(target, key2) {
    if (key2 === "$prefix") return prefix;
    if (key2 === "$model") return model;
    if (typeof key2 === "symbol" || key2 in target || key2.startsWith("$")) return Reflect.get(target, key2);
    if (intermediate) {
      if (Type.isArray(expr?.[Type.kType]) && Number.isInteger(+key2)) {
        return createRow(ref2, Eval3.get(expr, +key2), "", model, Eval3.get(expr, +key2));
      } else {
        return createRow(ref2, Eval3.get(intermediate, `${prefix}${key2}`), `${prefix}${key2}.`, model, intermediate);
      }
    }
    let type2;
    const field = model?.fields[prefix + key2];
    if (Type.isArray(expr?.[Type.kType]) && Number.isInteger(+key2)) {
      type2 = Type.getInner(expr?.[Type.kType]) ?? Type.fromField("expr");
      return createRow(ref2, Eval3.get(expr, +key2), "", model, Eval3.get(expr, +key2));
    } else if (Type.getInner(expr?.[Type.kType], key2)) {
      type2 = Type.getInner(expr?.[Type.kType], key2);
    } else if (field) {
      type2 = Type.fromField(field);
    } else if (Object.keys(model?.fields).some((k) => k.startsWith(`${prefix}${key2}.`))) {
      type2 = Type.Object(Object.fromEntries(Object.entries(model?.fields).filter(([k]) => k.startsWith(`${prefix}${key2}`)).map(([k, field2]) => [k.slice(prefix.length + key2.length + 1), Type.fromField(field2)])));
    } else {
      type2 = model?.getType(`${prefix}${key2}`) ?? Type.fromField("expr");
    }
    const row = createRow(ref2, Eval3("", [ref2, `${prefix}${key2}`], type2), `${prefix}${key2}.`, model);
    if (!field && Object.keys(model?.fields).some((k) => k.startsWith(`${prefix}${key2}.`))) {
      return createRow(ref2, Eval3.object(row), `${prefix}${key2}.`, model);
    } else {
      return row;
    }
  }
}), "createRow");
var Executable = class {
  static {
    __name$4(this, "Executable");
  }
  row;
  model;
  driver;
  constructor(driver, payload) {
    Object.assign(this, payload);
    defineProperty(this, "driver", driver);
    defineProperty(this, "model", driver.model(this.table));
    defineProperty(this, "row", createRow(this.ref, {}, "", this.model));
  }
  resolveQuery(query = {}) {
    if (typeof query === "function") {
      const expr = query(this.row);
      return expr["$expr"] ? expr : isEvalExpr(expr) ? { $expr: expr } : expr;
    }
    if (Array.isArray(query) || query instanceof RegExp || ["string", "number", "bigint"].includes(typeof query)) {
      const { primary } = this.model;
      if (Array.isArray(primary)) {
        throw new TypeError("invalid shorthand for composite primary key");
      }
      return { [primary]: query };
    }
    return query;
  }
  resolveField(field) {
    if (typeof field === "string") {
      return this.row[field];
    } else if (typeof field === "function") {
      return field(this.row);
    } else {
      throw new TypeError("invalid field definition");
    }
  }
  resolveFields(fields) {
    if (typeof fields === "string") fields = [fields];
    if (Array.isArray(fields)) {
      const modelFields = Object.keys(this.model.fields);
      const entries = fields.flatMap((key2) => {
        if (this.model.fields[key2]) return [[key2, this.row[key2]]];
        else if (modelFields.some((path2) => path2.startsWith(key2 + "."))) {
          return modelFields.filter((path2) => path2.startsWith(key2 + ".")).map((path2) => [path2, this.row[path2]]);
        }
        return [[key2, key2.split(".").reduce((row, k) => row[k], this.row)]];
      });
      return Object.fromEntries(entries);
    } else {
      const entries = Object.entries(fields).flatMap(([key2, field]) => {
        const expr = this.resolveField(field);
        if (expr["$object"] && !Type.fromTerm(expr).ignoreNull) {
          return Object.entries(expr["$object"]).map(([key22, expr2]) => [`${key2}.${key22}`, expr2]);
        }
        return [[key2, expr]];
      });
      return Object.fromEntries(entries);
    }
  }
  async execute() {
    await this.driver.database.prepared();
    await this.driver._ensureSession();
    return this.driver[this.type](this, ...this.args);
  }
};
var Selection = class _Selection extends Executable {
  static {
    __name$4(this, "Selection");
  }
  tables = {};
  constructor(driver, table, query) {
    super(driver, {
      type: "get",
      ref: randomId(),
      table,
      query: null,
      args: [{ sort: [], limit: Infinity, offset: 0, group: void 0, having: Eval3.and(), optional: {} }]
    });
    this.tables[this.ref] = this.model;
    this.query = this.resolveQuery(query);
    if (typeof table !== "string") {
      Object.assign(this.tables, table.tables);
    }
  }
  where(query) {
    this.query.$and ||= [];
    this.query.$and.push(this.resolveQuery(query));
    return this;
  }
  limit(...args) {
    if (args.length > 1) this.offset(args.shift());
    this.args[0].limit = args[0];
    return this;
  }
  offset(offset) {
    this.args[0].offset = offset;
    return this;
  }
  orderBy(field, direction = "asc") {
    this.args[0].sort.push([this.resolveField(field), direction]);
    return this;
  }
  groupBy(fields, ...args) {
    this.args[0].fields = this.resolveFields(fields);
    this.args[0].group = Object.keys(this.args[0].fields);
    const extra = typeof args[0] === "function" ? void 0 : args.shift();
    Object.assign(this.args[0].fields, this.resolveFields(extra || {}));
    if (args[0]) this.having(args[0]);
    return new _Selection(this.driver, this);
  }
  having(query) {
    this.args[0].having["$and"].push(this.resolveField(query));
    return this;
  }
  project(fields) {
    this.args[0].fields = this.resolveFields(fields);
    return new _Selection(this.driver, this);
  }
  join(name, selection, callback = () => Eval3.and(), optional = false) {
    const fields = Object.fromEntries(Object.entries(this.model.fields).filter(([key2, field]) => Field$1.available(field) && !key2.startsWith(name + ".")).map(([key2]) => [key2, (row) => getCell(row[this.ref], key2)]));
    const joinFields = Object.fromEntries(Object.entries(selection.model.fields).filter(([key2, field]) => Field$1.available(field) || Field$1.available(this.model.fields[`${name}.${key2}`])).map(([key2]) => [
      key2,
      (row) => Field$1.available(this.model.fields[`${name}.${key2}`]) ? getCell(row[this.ref], `${name}.${key2}`) : getCell(row[name], key2)
    ]));
    if (optional) {
      return this.driver.database.join({ [this.ref]: this, [name]: selection }, (t) => callback(t[this.ref], t[name]), { [this.ref]: false, [name]: true }).project({ ...fields, [name]: (row) => Eval3.ignoreNull(Eval3.object(mapValues(joinFields, (x) => x(row)))) });
    } else {
      return this.driver.database.join({ [this.ref]: this, [name]: selection }, (t) => callback(t[this.ref], t[name])).project({ ...fields, [name]: (row) => Eval3.ignoreNull(Eval3.object(mapValues(joinFields, (x) => x(row)))) });
    }
  }
  _action(type2, ...args) {
    return new Executable(this.driver, { ...this, type: type2, args });
  }
  evaluate(callback) {
    const selection = new _Selection(this.driver, this);
    if (!callback) callback = /* @__PURE__ */ __name$4((row) => Eval3.array(Eval3.object(row)), "callback");
    const expr = Array.isArray(callback) ? Eval3.select(...callback.map((x) => this.resolveField(x))) : this.resolveField(callback);
    if (isAggrExpr(expr)) defineProperty(expr, Type.kType, Type.Array(Type.fromTerm(expr)));
    return Eval3.exec(selection._action("eval", expr));
  }
  async execute(cursor) {
    if (typeof cursor === "function") {
      const selection = new _Selection(this.driver, this);
      return selection._action("eval", this.resolveField(cursor)).execute();
    }
    if (Array.isArray(cursor)) {
      cursor = { fields: cursor };
    } else if (!cursor) {
      cursor = {};
    }
    if (cursor.fields) this.project(cursor.fields);
    if (cursor.limit !== void 0) this.limit(cursor.limit);
    if (cursor.offset !== void 0) this.offset(cursor.offset);
    if (cursor.sort) {
      for (const field in cursor.sort) {
        this.orderBy(field, cursor.sort[field]);
      }
    }
    const rows = await super.execute();
    if (!cursor.fields) return rows;
    return rows.map((row) => {
      return filterKeys(row, (key2) => {
        return cursor.fields.some((k) => k === key2 || k.startsWith(`${key2}.`));
      });
    });
  }
};
((Selection2) => {
  function is2(sel) {
    return sel && !!sel.tables;
  }
  Selection2.is = is2;
  __name$4(is2, "is");
})(Selection || (Selection = {}));
function executeSort(data, modifier, name) {
  const { limit, offset, sort } = modifier;
  data.sort((a, b) => {
    for (const [field, direction] of sort) {
      const sign2 = direction === "asc" ? 1 : -1;
      const x = executeEval({ [name]: a, _: a }, field);
      const y = executeEval({ [name]: b, _: b }, field);
      if (x < y) return -sign2;
      if (x > y) return sign2;
    }
    return 0;
  });
  return data.slice(offset, offset + limit);
}
__name$4(executeSort, "executeSort");
function mergeQuery(base, query) {
  if (typeof query === "function") {
    return (row) => {
      const q = query(row);
      return { $expr: true, ...base, ...q.$expr ? q : { $expr: q } };
    };
  } else {
    return (_) => ({ $expr: true, ...base, ...query });
  }
}
__name$4(mergeQuery, "mergeQuery");
var Database = class _Database extends Service2 {
  static {
    __name$4(this, "Database");
  }
  static transact = Symbol("minato.transact");
  static migrate = Symbol("minato.migrate");
  tables = /* @__PURE__ */ Object.create(null);
  drivers = [];
  types = /* @__PURE__ */ Object.create(null);
  _driver;
  stashed = /* @__PURE__ */ new Set();
  prepareTasks = /* @__PURE__ */ Object.create(null);
  migrateTasks = /* @__PURE__ */ Object.create(null);
  constructor(ctx) {
    ctx ||= new Context2();
    super(ctx, "model", true);
  }
  async connect(driver, ...args) {
    this.ctx.plugin(driver, args[0]);
    await this.ctx.start();
  }
  refresh() {
    for (const name in this.tables) {
      this.prepareTasks[name] = this.prepare(name);
    }
  }
  async prepared() {
    if (this[_Database.migrate]) return;
    await Promise.all(Object.values(this.prepareTasks));
  }
  getDriver(table) {
    if (Selection.is(table)) return table.driver;
    const model = this.tables[table];
    if (!model) throw new Error(`cannot resolve table "${table}"`);
    return model.ctx?.get("database")?._driver;
  }
  async prepare(name) {
    this.stashed.add(name);
    await this.prepareTasks[name];
    await Promise.resolve();
    if (!this.stashed.delete(name)) return;
    const driver = this.getDriver(name);
    if (!driver) return;
    const { fields } = driver.model(name);
    Object.values(fields).forEach((field) => field?.transformers?.forEach((x) => driver.define(x)));
    await driver.prepare(name);
    await driver.prepareIndexes(name);
  }
  extend(name, fields, config = {}) {
    let model = this.tables[name];
    if (!model) {
      model = this.tables[name] = new Model(name);
    }
    Object.entries(fields).forEach(([key2, field]) => {
      const transformer = [];
      this.parseField(field, transformer, void 0, (value) => field = fields[key2] = value);
      if (typeof field === "object") field.transformers = transformer;
    });
    model.extend(fields, config);
    if (makeArray(model.primary).every((key2) => key2 in fields)) {
      defineProperty(model, "ctx", this.ctx);
    }
    Object.entries(fields).forEach(([key2, def]) => {
      if (!Relation.Type.includes(def.type)) return;
      const subprimary = !def.fields && makeArray(model.primary).includes(key2);
      const [relation, inverse] = Relation.parse(def, key2, model, this.tables[def.table ?? key2], subprimary);
      const relmodel = this.tables[relation.table];
      if (!relmodel) throw new Error(`relation table ${relation.table} does not exist`);
      (model.fields[key2] = Field$1.parse("expr")).relation = relation;
      if (def.target) {
        (relmodel.fields[def.target] ??= Field$1.parse("expr")).relation = inverse;
      }
      if (relation.type === "oneToOne" || relation.type === "manyToOne") {
        relation.fields.forEach((x, i) => {
          model.fields[x] ??= { ...relmodel.fields[relation.references[i]] };
          if (!relation.required) {
            model.fields[x].nullable = true;
            model.fields[x].initial = null;
          }
        });
      } else if (relation.type === "manyToMany") {
        const assocTable = Relation.buildAssociationTable(relation.table, name);
        if (this.tables[assocTable]) return;
        const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), model.fields[x].deftype]);
        const fields2 = relation.fields.map((x) => [Relation.buildAssociationKey(x, name), model.fields[x].deftype]);
        const references = relation.references.map((x) => [Relation.buildAssociationKey(x, relation.table), relmodel.fields[x]?.deftype]);
        this.extend(assocTable, {
          ...Object.fromEntries([...shared, ...fields2, ...references]),
          [name]: {
            type: "manyToOne",
            table: name,
            fields: [...shared, ...fields2].map((x) => x[0]),
            references: [...Object.keys(relation.shared), ...relation.fields]
          },
          [relation.table]: {
            type: "manyToOne",
            table: relation.table,
            fields: [...shared, ...references].map((x) => x[0]),
            references: [...Object.values(relation.shared), ...relation.references]
          }
        }, {
          primary: [...shared, ...fields2, ...references].map((x) => x[0])
        });
      }
    });
    if (Array.isArray(model.primary) || model.fields[model.primary].relation) {
      model.primary = deduplicate(makeArray(model.primary).map((key2) => model.fields[key2].relation?.fields || key2).flat());
    }
    model.unique = model.unique.map((keys) => typeof keys === "string" ? model.fields[keys].relation?.fields || keys : keys.map((key2) => model.fields[key2].relation?.fields || key2).flat());
    this.prepareTasks[name] = this.prepare(name);
    this.ctx.emit("model", name);
  }
  _parseField(field, transformers = [], setInitial, setField) {
    if (field === "object") {
      setInitial?.({});
      setField?.({ initial: {}, deftype: "json", type: Type.Object() });
      return Type.Object();
    } else if (field === "array") {
      setInitial?.([]);
      setField?.({ initial: [], deftype: "json", type: Type.Array() });
      return Type.Array();
    } else if (typeof field === "string" && this.types[field]) {
      transformers.push({
        types: [field],
        load: this.types[field].load,
        dump: this.types[field].dump
      }, ...this.types[field].transformers ?? []);
      setInitial?.(this.types[field].initial);
      setField?.({ ...this.types[field], type: field });
      return Type.fromField(field);
    } else if (typeof field === "string") {
      setInitial?.(Field$1.getInitial(field.split("(")[0]));
      setField?.(field);
      return Type.fromField(field.split("(")[0]);
    } else if (typeof field === "object" && field.type === "object") {
      const inner = field.inner ? unravel(field.inner, (value) => (value.type = "object", value.inner ??= {})) : /* @__PURE__ */ Object.create(null);
      const initial = /* @__PURE__ */ Object.create(null);
      const res = Type.Object(mapValues(inner, (x, k) => this.parseField(x, transformers, (value) => initial[k] = value)));
      setInitial?.(Field$1.getInitial("json", initial));
      setField?.({ initial: Field$1.getInitial("json", initial), ...field, deftype: "json", type: res });
      return res;
    } else if (typeof field === "object" && field.type === "array") {
      const res = field.inner ? Type.Array(this.parseField(field.inner, transformers)) : Type.Array();
      setInitial?.([]);
      setField?.({ initial: [], ...field, deftype: "json", type: res });
      return res;
    } else if (typeof field === "object" && this.types[field.type]) {
      transformers.push({
        types: [field.type],
        load: this.types[field.type].load,
        dump: this.types[field.type].dump
      }, ...this.types[field.type].transformers ?? []);
      setInitial?.(field.initial === void 0 ? this.types[field.type].initial : field.initial);
      setField?.({ initial: this.types[field.type].initial, ...field });
      return Type.fromField(field.type);
    } else {
      setInitial?.(Field$1.getInitial(field.type, field.initial));
      setField?.(field);
      return Type.fromField(field.type);
    }
  }
  parseField(field, transformers = [], setInitial, setField) {
    let midfield;
    let type2 = this._parseField(field, transformers, setInitial, (value) => (midfield = value, setField?.(value)));
    if (typeof field === "object" && field.load && field.dump) {
      if (type2.inner) type2 = Type.fromField(this.define({ ...omit(midfield, ["load", "dump"]), type: type2 }));
      const name = this.define({ ...field, deftype: midfield.deftype, type: type2.type });
      transformers.push({
        types: [name],
        load: field.load,
        dump: field.dump
      });
      setInitial?.(field.initial);
      setField?.({ ...field, deftype: midfield.deftype ?? this.types[type2.type]?.deftype ?? type2.type, initial: midfield.initial, type: name });
      return Type.fromField(name);
    }
    if (typeof midfield === "object") setField?.({ ...midfield, deftype: midfield.deftype ?? this.types[type2.type]?.deftype ?? type2?.type });
    return type2;
  }
  define(name, field) {
    if (typeof name === "object") {
      field = name;
      name = void 0;
    }
    if (name && this.types[name]) throw new Error(`type "${name}" already defined`);
    if (!name) while (this.types[name = "_define_" + randomId()]) ;
    const transformers = [];
    const type2 = this._parseField(field, transformers, void 0, (value) => field = value);
    field.transformers = transformers;
    this.ctx.effect(() => {
      this.types[name] = { ...field };
      this.types[name].deftype ??= this.types[field.type]?.deftype ?? type2.type;
      return () => delete this.types[name];
    });
    return name;
  }
  migrate(name, fields, callback) {
    this.extend(name, fields, { callback });
  }
  select(table, query, include) {
    let sel = new Selection(this.getDriver(table), table, query);
    if (typeof table !== "string") return sel;
    const whereOnly = include === null, isAssoc = !!include?.$assoc;
    const rawquery = typeof query === "function" ? query : () => query;
    const modelFields = this.tables[table].fields;
    if (include) include = filterKeys(include, (key2) => !!modelFields[key2]?.relation);
    for (const key2 in { ...sel.query, ...sel.query.$not }) {
      if (modelFields[key2]?.relation) {
        if (sel.query[key2] === null && !modelFields[key2].relation.required) {
          sel.query[key2] = Object.fromEntries(modelFields[key2].relation.references.map((k) => [k, null]));
        }
        if (sel.query[key2] && typeof sel.query[key2] !== "function" && typeof sel.query[key2] === "object" && Object.keys(sel.query[key2]).every((x) => modelFields[key2].relation.fields.includes(`${key2}.${x}`))) {
          Object.entries(sel.query[key2]).forEach(([k, v]) => sel.query[`${key2}.${k}`] = v);
          delete sel.query[key2];
        }
        if (sel.query.$not?.[key2] === null && !modelFields[key2].relation.required) {
          sel.query.$not[key2] = Object.fromEntries(modelFields[key2].relation.references.map((k) => [k, null]));
        }
        if (sel.query.$not?.[key2] && typeof sel.query.$not[key2] !== "function" && typeof sel.query.$not[key2] === "object" && Object.keys(sel.query.$not[key2]).every((x) => modelFields[key2].relation.fields.includes(`${key2}.${x}`))) {
          Object.entries(sel.query.$not[key2]).forEach(([k, v]) => sel.query.$not[`${key2}.${k}`] = v);
          delete sel.query.$not[key2];
        }
        if (!include || !Object.getOwnPropertyNames(include).includes(key2)) {
          (include ??= {})[key2] = true;
        }
      }
    }
    sel.query = omit(sel.query, Object.keys(include ?? {}));
    if (Object.keys(sel.query.$not ?? {}).length) {
      sel.query.$not = omit(sel.query.$not, Object.keys(include ?? {}));
      if (Object.keys(sel.query.$not).length === 0) Reflect.deleteProperty(sel.query, "$not");
    }
    if (include && typeof include === "object") {
      if (typeof table !== "string") throw new Error("cannot include relations on derived selection");
      const extraFields = [];
      const applyQuery = /* @__PURE__ */ __name$4((sel2, key2) => {
        const query2 = rawquery(sel2.row);
        const relquery = query2[key2] !== void 0 ? query2[key2] : query2.$not?.[key2] !== void 0 ? { $not: query2.$not?.[key2] } : void 0;
        return relquery === void 0 ? sel2 : sel2.where(this.transformRelationQuery(table, sel2.row, key2, relquery));
      }, "applyQuery");
      for (const key2 in include) {
        if (!include[key2] || !modelFields[key2]?.relation) continue;
        const relation = modelFields[key2].relation;
        const relmodel = this.tables[relation.table];
        if (relation.type === "oneToOne" || relation.type === "manyToOne") {
          sel = whereOnly ? sel : sel.join(key2, this.select(
            relation.table,
            typeof include[key2] === "object" ? filterKeys(include[key2], (k) => !relmodel.fields[k]?.relation) : {},
            typeof include[key2] === "object" ? filterKeys(include[key2], (k) => !!relmodel.fields[k]?.relation) : include[key2]
          ), (self2, other) => Eval3.and(
            ...relation.fields.map((k, i) => Eval3.eq(self2[k], other[relation.references[i]]))
          ), !isAssoc);
          sel = applyQuery(sel, key2);
        } else if (relation.type === "oneToMany") {
          sel = whereOnly ? sel : sel.join(key2, this.select(
            relation.table,
            typeof include[key2] === "object" ? filterKeys(include[key2], (k) => !relmodel.fields[k]?.relation) : {},
            typeof include[key2] === "object" ? filterKeys(include[key2], (k) => !!relmodel.fields[k]?.relation) : include[key2]
          ), (self2, other) => Eval3.and(
            ...relation.fields.map((k, i) => Eval3.eq(self2[k], other[relation.references[i]]))
          ), true);
          sel = applyQuery(sel, key2);
          sel = whereOnly ? sel : sel.groupBy([
            ...Object.entries(modelFields).filter(([k, field]) => !extraFields.some((x) => k.startsWith(`${x}.`)) && Field$1.available(field)).map(([k]) => k),
            ...extraFields
          ], {
            [key2]: (row) => Eval3.ignoreNull(Eval3.array(row[key2]))
          });
        } else if (relation.type === "manyToMany") {
          const assocTable = Relation.buildAssociationTable(relation.table, table);
          const references = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
          const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), {
            field: x,
            reference: y
          }]);
          sel = whereOnly ? sel : sel.join(
            key2,
            this.select(assocTable, {}, { $assoc: true, [relation.table]: include[key2] }),
            (self2, other) => Eval3.and(
              ...shared.map(([k, v]) => Eval3.eq(self2[v.field], other[k])),
              ...relation.fields.map((k, i) => Eval3.eq(self2[k], other[references[i]]))
            ),
            true
          );
          sel = applyQuery(sel, key2);
          sel = whereOnly ? sel : sel.groupBy([
            ...Object.entries(modelFields).filter(([k, field]) => !extraFields.some((x) => k.startsWith(`${x}.`)) && Field$1.available(field)).map(([k]) => k),
            ...extraFields
          ], {
            [key2]: (row) => Eval3.ignoreNull(Eval3.array(row[key2][relation.table]))
          });
        }
        extraFields.push(key2);
      }
    }
    return sel;
  }
  join(tables, query = (...args) => Eval3.and(), optional) {
    const oldTables = tables;
    if (Array.isArray(oldTables)) {
      tables = Object.fromEntries(oldTables.map((name) => [name, this.select(name)]));
    }
    let sels = mapValues(tables, (t) => {
      return typeof t === "string" ? this.select(t) : t;
    });
    if (Object.keys(sels).length === 0) throw new Error("no tables to join");
    const drivers = new Set(Object.values(sels).map((sel2) => sel2.driver[_Database.transact] ?? sel2.driver));
    if (drivers.size !== 1) throw new Error("cannot join tables from different drivers");
    if (Object.keys(sels).length === 2 && (optional?.[0] || optional?.[Object.keys(sels)[0]])) {
      if (optional[1] || optional[Object.keys(sels)[1]]) throw new Error("full join is not supported");
      sels = Object.fromEntries(Object.entries(sels).reverse());
    }
    const sel = new Selection([...drivers][0], sels);
    if (Array.isArray(oldTables)) {
      sel.args[0].having = Eval3.and(query(...oldTables.map((name) => sel.row[name])));
      sel.args[0].optional = Object.fromEntries(oldTables.map((name, index) => [name, optional?.[index]]));
    } else {
      sel.args[0].having = Eval3.and(query(sel.row));
      sel.args[0].optional = optional;
    }
    return this.select(sel);
  }
  async get(table, query, cursor) {
    let fields = Array.isArray(cursor) ? cursor : cursor?.fields;
    fields = fields ? Object.fromEntries(fields.map((x) => [x, true])) : cursor?.include;
    return this.select(table, query, fields).execute(cursor);
  }
  async eval(table, expr, query) {
    return this.select(table, query).execute(typeof expr === "function" ? expr : () => expr);
  }
  async set(table, query, update) {
    const rawupdate = typeof update === "function" ? update : () => update;
    let sel = this.select(table, query, null);
    if (typeof update === "function") update = update(sel.row);
    const primary = makeArray(sel.model.primary);
    if (primary.some((key2) => key2 in update)) {
      throw new TypeError(`cannot modify primary key`);
    }
    const relations = Object.entries(sel.model.fields).filter(([key2, field]) => key2 in update && field.relation).map(([key2, field]) => [key2, field.relation]);
    if (relations.length) {
      return await this.ensureTransaction(async (database) => {
        const rows = await database.get(table, query);
        sel = database.select(table, query, null);
        let baseUpdate = omit(rawupdate(sel.row), relations.map(([key2]) => key2));
        baseUpdate = sel.model.format(baseUpdate);
        for (const [key2] of relations) {
          await Promise.all(rows.map((row) => database.processRelationUpdate(table, row, key2, rawupdate(row)[key2])));
        }
        return Object.keys(baseUpdate).length === 0 ? {} : await sel._action("set", baseUpdate).execute();
      });
    }
    update = sel.model.format(update);
    if (Object.keys(update).length === 0) return {};
    return sel._action("set", update).execute();
  }
  async remove(table, query) {
    const sel = this.select(table, query, null);
    return sel._action("remove").execute();
  }
  async create(table, data) {
    const sel = this.select(table);
    if (!this.hasRelation(table, data)) {
      const { primary, autoInc } = sel.model;
      if (!autoInc) {
        const keys = makeArray(primary);
        if (keys.some((key2) => getCell(data, key2) === void 0)) {
          throw new Error("missing primary key");
        }
      }
      return sel._action("create", sel.model.create(data)).execute();
    } else {
      return this.ensureTransaction((database) => database.createOrUpdate(table, data, false));
    }
  }
  async upsert(table, upsert, keys) {
    const sel = this.select(table);
    if (typeof upsert === "function") upsert = upsert(sel.row);
    upsert = upsert.map((item) => sel.model.format(item));
    keys = makeArray(keys || sel.model.primary);
    return sel._action("upsert", upsert, keys).execute();
  }
  makeProxy(marker, getDriver) {
    const drivers = /* @__PURE__ */ new Map();
    const database = new Proxy(this, {
      get: /* @__PURE__ */ __name$4((target, p, receiver) => {
        if (p === marker) return true;
        if (p !== "getDriver") return Reflect.get(target, p, receiver);
        return (name) => {
          const original = this.getDriver(name);
          let driver = drivers.get(original);
          if (!driver) {
            driver = getDriver?.(original, database) ?? new Proxy(original, {
              get: /* @__PURE__ */ __name$4((target2, p2, receiver2) => {
                if (p2 === "database") return database;
                return Reflect.get(target2, p2, receiver2);
              }, "get")
            });
            drivers.set(original, driver);
          }
          return driver;
        };
      }, "get")
    });
    return database;
  }
  withTransaction(callback) {
    return this.transact(callback);
  }
  async transact(callback) {
    if (this[_Database.transact]) throw new Error("nested transactions are not supported");
    const finalTasks = [];
    const database = this.makeProxy(_Database.transact, (driver) => {
      let initialized = false, session;
      let _resolve;
      const sessionTask = new Promise((resolve2) => _resolve = resolve2);
      driver = new Proxy(driver, {
        get: /* @__PURE__ */ __name$4((target, p, receiver) => {
          if (p === _Database.transact) return target;
          if (p === "database") return database;
          if (p === "session") return session;
          if (p === "_ensureSession") return () => sessionTask;
          return Reflect.get(target, p, receiver);
        }, "get")
      });
      finalTasks.push(driver.withTransaction((_session) => {
        if (initialized) initialTask = initialTaskFactory();
        initialized = true;
        _resolve(session = _session);
        return initialTask;
      }));
      return driver;
    });
    const initialTaskFactory = /* @__PURE__ */ __name$4(() => Promise.resolve().then(() => callback(database)), "initialTaskFactory");
    let initialTask = initialTaskFactory();
    return initialTask.catch(noop).finally(() => Promise.all(finalTasks));
  }
  async stopAll() {
    await Promise.all(this.drivers.splice(0, Infinity).map((driver) => driver.stop()));
  }
  async drop(table) {
    if (this[_Database.transact]) throw new Error("cannot drop table in transaction");
    await this.getDriver(table).drop(table);
  }
  async dropAll() {
    if (this[_Database.transact]) throw new Error("cannot drop table in transaction");
    await Promise.all(Object.values(this.drivers).map((driver) => driver.dropAll()));
  }
  async stats() {
    await this.prepared();
    const stats = { size: 0, tables: {} };
    await Promise.all(Object.values(this.drivers).map(async (driver) => {
      const { size = 0, tables } = await driver.stats();
      stats.size += size;
      Object.assign(stats.tables, tables);
    }));
    return stats;
  }
  ensureTransaction(callback) {
    if (this[_Database.transact]) {
      return callback(this);
    } else {
      return this.transact(callback);
    }
  }
  transformRelationQuery(table, row, key2, query) {
    const relation = this.tables[table].fields[key2].relation;
    const results = [];
    if (relation.type === "oneToOne" || relation.type === "manyToOne") {
      if (query === null) {
        results.push(Eval3.nin(
          relation.fields.map((x) => row[x]),
          this.select(relation.table).evaluate(relation.references)
        ));
      } else {
        results.push(Eval3.in(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, query).evaluate(relation.references)
        ));
      }
    } else if (relation.type === "oneToMany") {
      if (query.$or) results.push(Eval3.or(...query.$or.map((q) => this.transformRelationQuery(table, row, key2, q).$expr)));
      if (query.$and) results.push(...query.$and.map((q) => this.transformRelationQuery(table, row, key2, q).$expr));
      if (query.$not) results.push(Eval3.not(this.transformRelationQuery(table, row, key2, query.$not).$expr));
      if (query.$some) {
        results.push(Eval3.in(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, query.$some).evaluate(relation.references)
        ));
      }
      if (query.$none) {
        results.push(Eval3.nin(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, query.$none).evaluate(relation.references)
        ));
      }
      if (query.$every) {
        results.push(Eval3.nin(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, Eval3.not(query.$every)).evaluate(relation.references)
        ));
      }
    } else if (relation.type === "manyToMany") {
      const assocTable = Relation.buildAssociationTable(table, relation.table);
      const fields = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
      const references = relation.references.map((x) => Relation.buildAssociationKey(x, relation.table));
      if (query.$or) results.push(Eval3.or(...query.$or.map((q) => this.transformRelationQuery(table, row, key2, q).$expr)));
      if (query.$and) results.push(...query.$and.map((q) => this.transformRelationQuery(table, row, key2, q).$expr));
      if (query.$not) results.push(Eval3.not(this.transformRelationQuery(table, row, key2, query.$not).$expr));
      if (query.$some) {
        const innerTable = this.select(relation.table, query.$some).evaluate(relation.references);
        const relTable = this.select(assocTable, (r) => Eval3.in(references.map((x) => r[x]), innerTable)).evaluate(fields);
        results.push(Eval3.in(relation.fields.map((x) => row[x]), relTable));
      }
      if (query.$none) {
        const innerTable = this.select(relation.table, query.$none).evaluate(relation.references);
        const relTable = this.select(assocTable, (r) => Eval3.in(references.map((x) => r[x]), innerTable)).evaluate(fields);
        results.push(Eval3.nin(relation.fields.map((x) => row[x]), relTable));
      }
      if (query.$every) {
        const innerTable = this.select(relation.table, Eval3.not(query.$every)).evaluate(relation.references);
        const relTable = this.select(assocTable, (r) => Eval3.in(references.map((x) => r[x]), innerTable)).evaluate(fields);
        results.push(Eval3.nin(relation.fields.map((x) => row[x]), relTable));
      }
    }
    return { $expr: Eval3.and(...results) };
  }
  async createOrUpdate(table, data, upsert = true) {
    const sel = this.select(table);
    data = { ...data };
    const tasks = [""];
    for (const key2 in data) {
      if (data[key2] !== void 0 && this.tables[table].fields[key2]?.relation) {
        const relation = this.tables[table].fields[key2].relation;
        if (relation.type === "oneToOne" && relation.required) tasks.push(key2);
        else if (relation.type === "oneToOne") tasks.unshift(key2);
        else if (relation.type === "oneToMany") tasks.push(key2);
        else if (relation.type === "manyToOne") tasks.unshift(key2);
        else if (relation.type === "manyToMany") tasks.push(key2);
      }
    }
    for (const key2 of [...tasks]) {
      if (!key2) {
        const { primary, autoInc } = sel.model;
        const keys = makeArray(primary);
        if (keys.some((key22) => isNullable(getCell(data, key22)))) {
          if (!autoInc) {
            throw new Error("missing primary key");
          } else {
            delete data[primary];
            upsert = false;
          }
        }
        if (upsert) {
          await sel._action("upsert", [sel.model.format(omit(data, tasks))], keys).execute();
        } else {
          Object.assign(data, await sel._action("create", sel.model.create(omit(data, tasks))).execute());
        }
        continue;
      }
      const value = data[key2];
      const relation = this.tables[table].fields[key2].relation;
      if (relation.type === "oneToOne") {
        if (value.$literal) {
          data[key2] = value.$literal;
          remove(tasks, key2);
        } else if (value.$create || !isUpdateExpr(value)) {
          const result = await this.createOrUpdate(relation.table, {
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
            ...value.$create ?? value
          });
          if (!relation.required) {
            relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result, k));
          }
        } else if (value.$upsert) {
          await this.upsert(relation.table, [{
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
            ...value.$upsert
          }]);
          if (!relation.required) {
            relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(value.$upsert, k));
          }
        } else if (value.$connect) {
          if (relation.required) {
            await this.set(
              relation.table,
              value.$connect,
              Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])]))
            );
          } else {
            const result = relation.references.every((k) => value.$connect[k] !== void 0) ? [value.$connect] : await this.get(relation.table, value.$connect);
            if (result.length !== 1) throw new Error("related row not found or not unique");
            relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result[0], k));
          }
        }
      } else if (relation.type === "manyToOne") {
        if (value.$literal) {
          data[key2] = value.$literal;
          remove(tasks, key2);
        } else if (value.$create || !isUpdateExpr(value)) {
          const result = await this.createOrUpdate(relation.table, value.$create ?? value);
          relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result, k));
        } else if (value.$upsert) {
          await this.upsert(relation.table, [value.$upsert]);
          relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(value.$upsert, k));
        } else if (value.$connect) {
          const result = relation.references.every((k) => value.$connect[k] !== void 0) ? [value.$connect] : await this.get(relation.table, value.$connect);
          if (result.length !== 1) throw new Error("related row not found or not unique");
          relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result[0], k));
        }
      } else if (relation.type === "oneToMany") {
        if (value.$create || Array.isArray(value)) {
          for (const item of makeArray(value.$create ?? value)) {
            await this.createOrUpdate(relation.table, {
              ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
              ...item
            });
          }
        }
        if (value.$upsert) {
          await this.upsert(relation.table, makeArray(value.$upsert).map((r) => ({
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
            ...r
          })));
        }
        if (value.$connect) {
          await this.set(
            relation.table,
            value.$connect,
            Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])]))
          );
        }
      } else if (relation.type === "manyToMany") {
        const assocTable = Relation.buildAssociationTable(relation.table, table);
        const fields = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
        const references = relation.references.map((x) => Relation.buildAssociationKey(x, relation.table));
        const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), {
          field: x,
          reference: y
        }]);
        const result = [];
        if (value.$create || Array.isArray(value)) {
          for (const item of makeArray(value.$create ?? value)) {
            result.push(await this.createOrUpdate(relation.table, {
              ...Object.fromEntries(shared.map(([, v]) => [v.reference, getCell(item, v.reference) ?? getCell(data, v.field)])),
              ...item
            }));
          }
        }
        if (value.$upsert) {
          const upsert2 = makeArray(value.$upsert).map((r) => ({
            ...Object.fromEntries(shared.map(([, v]) => [v.reference, getCell(r, v.reference) ?? getCell(data, v.field)])),
            ...r
          }));
          await this.upsert(relation.table, upsert2);
          result.push(...upsert2);
        }
        if (value.$connect) {
          for (const item of makeArray(value.$connect)) {
            if (references.every((k) => item[k] !== void 0)) result.push(item);
            else result.push(...await this.get(relation.table, item));
          }
        }
        await this.upsert(assocTable, result.map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(r, v.reference) ?? getCell(data, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, getCell(data, relation.fields[i])])),
          ...Object.fromEntries(references.map((k, i) => [k, getCell(r, relation.references[i])]))
        })));
      }
    }
    return data;
  }
  async processRelationUpdate(table, row, key2, value) {
    const model = this.tables[table], update = /* @__PURE__ */ Object.create(null);
    const relation = this.tables[table].fields[key2].relation;
    if (relation.type === "oneToOne") {
      if (value === null) {
        value = relation.required ? { $remove: {} } : { $disconnect: {} };
      }
      if (typeof value === "object" && !isUpdateExpr(value)) {
        value = { $create: value };
      }
      if (value.$remove) {
        await this.remove(relation.table, Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])));
      }
      if (value.$disconnect) {
        if (relation.required) {
          await this.set(
            relation.table,
            mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])), value.$disconnect),
            Object.fromEntries(relation.references.map((k, i) => [k, null]))
          );
        } else {
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, null])));
        }
      }
      if (value.$set || typeof value === "function") {
        await this.set(
          relation.table,
          Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          value.$set ?? value
        );
      }
      if (value.$create) {
        const result = await this.createOrUpdate(relation.table, {
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...value.$create
        });
        if (!relation.required) {
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result, relation.references[i])])));
        }
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
        if (!relation.required) {
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(value.$upsert, relation.references[i])])));
        }
      }
      if (value.$connect) {
        if (relation.required) {
          await this.set(
            relation.table,
            value.$connect,
            Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])]))
          );
        } else {
          const result = await this.get(relation.table, value.$connect);
          if (result.length !== 1) throw new Error("related row not found or not unique");
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result[0], relation.references[i])])));
        }
      }
    } else if (relation.type === "manyToOne") {
      if (value === null) {
        value = { $disconnect: {} };
      }
      if (typeof value === "object" && !isUpdateExpr(value)) {
        value = { $create: value };
      }
      if (value.$remove) {
        await this.remove(relation.table, Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])));
      }
      if (value.$disconnect) {
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, null])));
      }
      if (value.$set || typeof value === "function") {
        await this.set(
          relation.table,
          Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          value.$set ?? value
        );
      }
      if (value.$create) {
        const result = await this.createOrUpdate(relation.table, {
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...value.$create
        });
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result, relation.references[i])])));
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(value.$upsert, relation.references[i])])));
      }
      if (value.$connect) {
        const result = await this.get(relation.table, value.$connect);
        if (result.length !== 1) throw new Error("related row not found or not unique");
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result[0], relation.references[i])])));
      }
    } else if (relation.type === "oneToMany") {
      if (Array.isArray(value)) {
        const $create = [], $upsert = [];
        value.forEach((item) => this.hasRelation(relation.table, item) ? $create.push(item) : $upsert.push(item));
        value = { $remove: {}, $create, $upsert };
      }
      if (value.$remove) {
        await this.remove(relation.table, mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, row[relation.fields[i]]])), value.$remove));
      }
      if (value.$disconnect) {
        await this.set(
          relation.table,
          mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])), value.$disconnect),
          Object.fromEntries(relation.references.map((k, i) => [k, null]))
        );
      }
      if (value.$set || typeof value === "function") {
        for (const setexpr of makeArray(value.$set ?? value)) {
          const [query, update2] = setexpr.update ? [setexpr.where, setexpr.update] : [{}, setexpr];
          await this.set(
            relation.table,
            mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, row[relation.fields[i]]])), query),
            update2
          );
        }
      }
      if (value.$create) {
        for (const item of makeArray(value.$create)) {
          await this.createOrUpdate(relation.table, {
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
            ...item
          });
        }
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
      }
      if (value.$connect) {
        await this.set(
          relation.table,
          value.$connect,
          Object.fromEntries(relation.references.map((k, i) => [k, row[relation.fields[i]]]))
        );
      }
    } else if (relation.type === "manyToMany") {
      const assocTable = Relation.buildAssociationTable(table, relation.table);
      const fields = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
      const references = relation.references.map((x) => Relation.buildAssociationKey(x, relation.table));
      const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), {
        field: x,
        reference: y
      }]);
      if (Array.isArray(value)) {
        const $create = [], $upsert = [];
        value.forEach((item) => this.hasRelation(relation.table, item) ? $create.push(item) : $upsert.push(item));
        value = { $disconnect: {}, $create, $upsert };
      }
      if (value.$remove) {
        const rows = await this.select(assocTable, {
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, getCell(row, relation.fields[i])])),
          [relation.table]: value.$remove
        }, null).execute();
        await this.remove(assocTable, (r) => Eval3.in(
          [...shared.map(([k, v]) => r[k]), ...fields.map((x) => r[x]), ...references.map((x) => r[x])],
          rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...fields.map((x) => getCell(r2, x)), ...references.map((x) => getCell(r2, x))])
        ));
        await this.remove(relation.table, (r) => Eval3.in(
          [...shared.map(([k, v]) => r[v.reference]), ...relation.references.map((x) => r[x])],
          rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...references.map((x) => getCell(r2, x))])
        ));
      }
      if (value.$disconnect) {
        const rows = await this.select(assocTable, {
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, getCell(row, relation.fields[i])])),
          [relation.table]: value.$disconnect
        }, null).execute();
        await this.remove(assocTable, (r) => Eval3.in(
          [...shared.map(([k, v]) => r[k]), ...fields.map((x) => r[x]), ...references.map((x) => r[x])],
          rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...fields.map((x) => getCell(r2, x)), ...references.map((x) => getCell(r2, x))])
        ));
      }
      if (value.$set) {
        for (const setexpr of makeArray(value.$set)) {
          const [query, update2] = setexpr.update ? [setexpr.where, setexpr.update] : [{}, setexpr];
          const rows = await this.select(assocTable, (r) => ({
            ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
            ...Object.fromEntries(fields.map((k, i) => [k, getCell(row, relation.fields[i])])),
            [relation.table]: query
          }), null).execute();
          await this.set(
            relation.table,
            (r) => Eval3.in(
              [...shared.map(([k, v]) => r[v.reference]), ...relation.references.map((x) => r[x])],
              rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...references.map((x) => getCell(r2, x))])
            ),
            update2
          );
        }
      }
      if (value.$create) {
        const result = [];
        for (const item of makeArray(value.$create)) {
          result.push(await this.createOrUpdate(relation.table, {
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
            ...item
          }));
        }
        await this.upsert(assocTable, result.map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, row[relation.fields[i]]])),
          ...Object.fromEntries(references.map((k, i) => [k, r[relation.references[i]]]))
        })));
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
        await this.upsert(assocTable, makeArray(value.$upsert).map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, row[relation.fields[i]]])),
          ...Object.fromEntries(references.map((k, i) => [k, r[relation.references[i]]]))
        })));
      }
      if (value.$connect) {
        const rows = await this.get(
          relation.table,
          mergeQuery(Object.fromEntries(shared.map(([k, v]) => [v.reference, getCell(row, v.field)])), value.$connect)
        );
        await this.upsert(assocTable, rows.map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, row[relation.fields[i]]])),
          ...Object.fromEntries(references.map((k, i) => [k, r[relation.references[i]]]))
        })));
      }
    }
    if (Object.keys(update).length) {
      await this.set(table, pick(model.format(row), makeArray(model.primary)), update);
    }
  }
  hasRelation(table, data) {
    for (const key2 in data) {
      if (data[key2] !== void 0 && this.tables[table].fields[key2]?.relation) return true;
    }
    return false;
  }
};
var Driver = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    this.database = ctx.model;
    this.logger = ctx.logger(this.constructor.name);
    ctx.on("ready", async () => {
      await Promise.resolve();
      await this.start();
      ctx.model.drivers.push(this);
      ctx.model.refresh();
      const database = Object.create(ctx.model);
      defineProperty(database, "ctx", ctx);
      database._driver = this;
      database[Service2.tracker] = {
        associate: "database",
        property: "ctx"
      };
      ctx.set("database", Context2.associate(database, "database"));
    });
    ctx.on("dispose", async () => {
      remove(ctx.model.drivers, this);
      await this.stop();
    });
  }
  static {
    __name$4(this, "Driver");
  }
  static inject = ["model"];
  database;
  logger;
  types = /* @__PURE__ */ Object.create(null);
  model(table) {
    if (typeof table === "string") {
      const model2 = this.database.tables[table];
      if (model2) return model2;
      throw new TypeError(`unknown table name "${table}"`);
    }
    if (Selection.is(table)) {
      if (!table.args[0].fields && (typeof table.table === "string" || Selection.is(table.table))) {
        return table.model;
      }
      const model2 = new Model("temp");
      if (table.args[0].fields) {
        model2.fields = mapValues(table.args[0].fields, (expr) => ({
          type: Type.fromTerm(expr)
        }));
      } else {
        model2.fields = mapValues(table.model.fields, (field) => ({
          type: Type.fromField(field)
        }));
      }
      return model2;
    }
    const model = new Model("temp");
    for (const key2 in table) {
      const submodel = this.model(table[key2]);
      for (const field in submodel.fields) {
        if (!Field$1.available(submodel.fields[field])) continue;
        model.fields[`${key2}.${field}`] = {
          expr: Eval3("", [table[key2].ref, field], Type.fromField(submodel.fields[field])),
          type: Type.fromField(submodel.fields[field])
        };
      }
    }
    return model;
  }
  async migrate(name, hooks) {
    const database = this.database.makeProxy(Database.migrate);
    const model = this.model(name);
    await (database.migrateTasks[name] = Promise.resolve(database.migrateTasks[name]).then(() => {
      return Promise.all([...model.migrations].map(async ([migrate, keys]) => {
        try {
          if (!hooks.before(keys)) return;
          await migrate(database);
          hooks.after(keys);
        } catch (reason) {
          hooks.error(reason);
        }
      }));
    }).then(hooks.finalize).catch(hooks.error));
  }
  define(converter) {
    converter.types.forEach((type2) => this.types[type2] = converter);
  }
  async _ensureSession() {
  }
  async prepareIndexes(table) {
    const oldIndexes = await this.getIndexes(table);
    const { indexes } = this.model(table);
    for (const index of indexes) {
      const oldIndex = oldIndexes.find((info) => info.name === index.name);
      if (!oldIndex) {
        await this.createIndex(table, index);
      } else if (!deepEqual(oldIndex, index)) {
        await this.dropIndex(table, index.name);
        await this.createIndex(table, index);
      }
    }
  }
};
(class _RuntimeError extends Error {
  constructor(code, message) {
    super(message || code.replace("-", " "));
    this.code = code;
  }
  static {
    __name$4(this, "RuntimeError");
  }
  name = "RuntimeError";
  static check(error, code) {
    if (!(error instanceof _RuntimeError)) return false;
    return !code || error.message === code;
  }
});
var queryOperators = {
  // logical
  $or: /* @__PURE__ */ __name$4((query, data) => query.reduce((prev, query2) => prev || executeFieldQuery(query2, data), false), "$or"),
  $and: /* @__PURE__ */ __name$4((query, data) => query.reduce((prev, query2) => prev && executeFieldQuery(query2, data), true), "$and"),
  $not: /* @__PURE__ */ __name$4((query, data) => !executeFieldQuery(query, data), "$not"),
  // existence
  $exists: /* @__PURE__ */ __name$4((query, data) => query !== isNullable(data), "$exists"),
  // comparison
  $eq: /* @__PURE__ */ __name$4((query, data) => data.valueOf() === query.valueOf(), "$eq"),
  $ne: /* @__PURE__ */ __name$4((query, data) => data.valueOf() !== query.valueOf(), "$ne"),
  $gt: /* @__PURE__ */ __name$4((query, data) => data.valueOf() > query.valueOf(), "$gt"),
  $gte: /* @__PURE__ */ __name$4((query, data) => data.valueOf() >= query.valueOf(), "$gte"),
  $lt: /* @__PURE__ */ __name$4((query, data) => data.valueOf() < query.valueOf(), "$lt"),
  $lte: /* @__PURE__ */ __name$4((query, data) => data.valueOf() <= query.valueOf(), "$lte"),
  // membership
  $in: /* @__PURE__ */ __name$4((query, data) => query.includes(data), "$in"),
  $nin: /* @__PURE__ */ __name$4((query, data) => !query.includes(data), "$nin"),
  // regexp
  $regex: /* @__PURE__ */ __name$4((query, data) => makeRegExp(query).test(data), "$regex"),
  $regexFor: /* @__PURE__ */ __name$4((query, data) => typeof query === "string" ? makeRegExp(data).test(query) : makeRegExp(data, query.flags).test(query.input), "$regexFor"),
  // bitwise
  $bitsAllSet: /* @__PURE__ */ __name$4((query, data) => (query & data) === query, "$bitsAllSet"),
  $bitsAllClear: /* @__PURE__ */ __name$4((query, data) => (query & data) === 0, "$bitsAllClear"),
  $bitsAnySet: /* @__PURE__ */ __name$4((query, data) => (query & data) !== 0, "$bitsAnySet"),
  $bitsAnyClear: /* @__PURE__ */ __name$4((query, data) => (query & data) !== query, "$bitsAnyClear"),
  // list
  $el: /* @__PURE__ */ __name$4((query, data) => data.some((item) => executeFieldQuery(query, item)), "$el"),
  $size: /* @__PURE__ */ __name$4((query, data) => data.length === query, "$size")
};
function executeFieldQuery(query, data) {
  if (Array.isArray(query)) {
    return query.includes(data);
  } else if (query instanceof RegExp) {
    return query.test(data);
  } else if (isComparable(query)) {
    return data.valueOf() === query.valueOf();
  } else if (isNullable(query)) {
    return isNullable(data);
  }
  for (const key2 in query) {
    if (key2 in queryOperators) {
      if (!queryOperators[key2](query[key2], data)) return false;
    }
  }
  return true;
}
__name$4(executeFieldQuery, "executeFieldQuery");
function executeQuery(data, query, ref2, env = {}) {
  const entries = Object.entries(query);
  return entries.every(([key2, value]) => {
    if (key2 === "$and") {
      return value.reduce((prev, query2) => prev && executeQuery(data, query2, ref2, env), true);
    } else if (key2 === "$or") {
      return value.reduce((prev, query2) => prev || executeQuery(data, query2, ref2, env), false);
    } else if (key2 === "$not") {
      return !executeQuery(data, value, ref2, env);
    } else if (key2 === "$expr") {
      return executeEval({ ...env, [ref2]: data, _: data }, value);
    }
    try {
      const flattenQuery = isFlat(query[key2]) ? { [key2]: query[key2] } : flatten(query[key2], `${key2}.`);
      return Object.entries(flattenQuery).every(([key22, value2]) => executeFieldQuery(value2, getCell(data, key22)));
    } catch {
      return false;
    }
  });
}
__name$4(executeQuery, "executeQuery");
var src_default$1 = Database;
class VoiceMsg2Text extends BaseAction {
  actionName = ActionName.VoiceMsg2Text;
  async _handle(payload) {
    const msgInfo = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msgInfo) {
      throw new Error("");
    }
    let msg = this.ctx.store.getMsgCache(msgInfo.msgId);
    if (!msg) {
      const res = await this.ctx.ntMsgApi.getMsgsByMsgId(msgInfo.peer, [msgInfo.msgId]);
      if (res.msgList.length === 0) {
        throw new Error("");
      }
      msg = res.msgList[0];
    }
    const voiceElement = msg.elements.find((e) => e.elementType === ElementType.Ptt);
    if (!voiceElement) {
      throw new Error("");
    }
    const text = await this.ctx.ntMsgApi.translatePtt2Text(msgInfo.msgId, msgInfo.peer, voiceElement);
    if (!text) {
      throw new Error("");
    }
    return { text };
  }
}
class SendPB extends BaseAction {
  actionName = ActionName.SendPB;
  payloadSchema = z.object({
    cmd: String,
    hex: String
  });
  async _handle(payload) {
    try {
      const result = await this.ctx.app.pmhq.sendPB(payload.cmd, payload.hex);
      return {
        cmd: result.cmd,
        hex: result.pb,
        ...result.echo !== void 0 ? { echo: result.echo } : {}
      };
    } catch (e) {
      this.ctx.logger.error("pmhq ", e);
      throw new Error(`pmhq : ${e}`, { cause: e });
    }
  }
}
class GetRKey extends BaseAction {
  actionName = ActionName.GetRKey;
  async _handle() {
    const rkey = await this.ctx.app.pmhq.getRKey();
    const now = /* @__PURE__ */ new Date();
    const updatedTime = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}-${String(now.getDate()).padStart(2, "0")} ${String(now.getHours()).padStart(2, "0")}:${String(now.getMinutes()).padStart(2, "0")}:${String(now.getSeconds()).padStart(2, "0")}`;
    const expiredTime = Math.floor(now.getTime() / 1e3) + 50 * 60;
    return {
      private_key: rkey.privateRKey,
      group_key: rkey.groupRKey,
      expired_time: expiredTime,
      updated_time: updatedTime
    };
  }
}
class UploadFlashFile extends BaseAction {
  actionName = ActionName.UploadFlashFile;
  async _handle(payload) {
    const { title, paths } = payload;
    const localPaths = await Promise.all(
      paths.map(async (path2) => {
        const { fileName, path: localPath, isLocal, errMsg } = await uri2local(this.ctx, path2);
        if (errMsg) {
          throw new Error(errMsg);
        }
        if (localPath) {
          return localPath;
        } else {
          throw new Error(`${path2}`);
        }
      })
    );
    const res = await this.ctx.ntFileApi.uploadFlashFile(title, localPaths);
    return {
      file_set_id: res.fileSetId,
      share_link: res.shareLink,
      expire_time: parseInt(res.expireTime)
    };
  }
}
class GetQQAvatar extends BaseAction {
  actionName = ActionName.GetQQAvatar;
  async _handle(payload) {
    return { url: `https://thirdqq.qlogo.cn/g?b=qq&nk=${payload.user_id}&s=640` };
  }
}
class GetFlashFileInfoBase extends BaseAction {
  actionName = ActionName.GetFlashFileInfo;
  async get_file_set_id(payload) {
    let { share_link, file_set_id } = payload;
    if (share_link) {
      const match = share_link.match(/qfile.qq.com\/q\/([\w\d]+)/);
      if (!match) {
        throw new Error("");
      }
      const code = match[1];
      file_set_id = await this.ctx.ntFileApi.getFlashFileSetIdByCode(code);
    }
    if (!file_set_id) {
      throw new Error(" share_link  file_set_id");
    }
    return file_set_id;
  }
  async _handle(payload) {
    throw new Error("Method not implemented.");
  }
}
class GetFlashFileInfo extends GetFlashFileInfoBase {
  actionName = ActionName.GetFlashFileInfo;
  async _handle(payload) {
    const file_set_id = await this.get_file_set_id(payload);
    const fileInfo = await this.ctx.ntFileApi.getFlashFileInfo(file_set_id);
    const fileList = await this.ctx.ntFileApi.getFlashFileList(file_set_id);
    const files = [];
    for (const file of fileList) {
      for (const file2 of file.fileList) {
        files.push({
          name: file2.name,
          size: parseInt(file2.fileSize)
        });
      }
    }
    return {
      file_set_id,
      title: fileInfo.name,
      share_link: fileInfo.shareInfo.shareLink,
      total_file_size: parseInt(fileInfo.totalFileSize),
      files
    };
  }
}
class DownloadFlashFile extends GetFlashFileInfoBase {
  actionName = ActionName.DownloadFlashFile;
  async _handle(payload) {
    const file_set_id = await this.get_file_set_id(payload);
    await this.ctx.ntFileApi.downloadFlashFile(file_set_id);
    return null;
  }
}
function initActionMap(adapter) {
  const actionHandlers = [
    // llonebot
    new GetFlashFileInfo(adapter),
    new DownloadFlashFile(adapter),
    new UploadFlashFile(adapter),
    new GetRKey(adapter),
    new SendPB(adapter),
    new VoiceMsg2Text(adapter),
    new GetFile(adapter),
    new Debug(adapter),
    new GetConfigAction(adapter),
    new SetConfigAction(adapter),
    new GetGroupAddRequest(adapter),
    new SetQQAvatar(adapter),
    new GetQQAvatar(adapter),
    new GetFriendWithCategory(adapter),
    new GetEvent(adapter),
    new SetOnlineStatus(adapter),
    new GetProfileLike(adapter),
    new GetProfileLikeMe(adapter),
    new GetFriendMsgHistory(adapter),
    new FetchEmojiLike(adapter),
    new FetchCustomFace(adapter),
    new SetMsgEmojiLike(adapter),
    new UnSetMsgEmojiLike(adapter),
    new GetRobotUinRange(adapter),
    new GroupPoke(adapter),
    new FriendPoke(adapter),
    new SetFriendCategory(adapter),
    new SetFriendRemark(adapter),
    new SetGroupMsgMask(adapter),
    new SetGroupRemark(adapter),
    new MoveGroupFile(adapter),
    new GetGroupShutList(adapter),
    new RenameGroupFileFolder(adapter),
    // onebot11
    new SendLike(adapter),
    new GetMsg(adapter),
    new GetLoginInfo(adapter),
    new GetFriendList(adapter),
    new GetGroupList(adapter),
    new GetGroupInfo(adapter),
    new GetGroupMemberList(adapter),
    new GetGroupMemberInfo(adapter),
    new SendGroupMsg(adapter),
    new SendPrivateMsg(adapter),
    new SendMsg(adapter),
    new DeleteMsg(adapter),
    new SetGroupAddRequest(adapter),
    new SetFriendAddRequest(adapter),
    new SetGroupLeave(adapter),
    new GetVersionInfo(adapter),
    new CanSendRecord(adapter),
    new CanSendImage(adapter),
    new GetStatus(adapter),
    new SetGroupWholeBan(adapter),
    new SetGroupBan(adapter),
    new SetGroupKick(adapter),
    new SetGroupAdmin(adapter),
    new SetGroupName(adapter),
    new SetGroupCard(adapter),
    new GetImage(adapter),
    new GetRecord(adapter),
    new CleanCache(adapter),
    new GetCookies(adapter),
    new ForwardFriendSingleMsg(adapter),
    new ForwardGroupSingleMsg(adapter),
    new GetCredentials(adapter),
    new SetRestart(adapter),
    new GetCsrfToken(adapter),
    // go-cqhttp
    new GetEssenceMsgList(adapter),
    new GetGroupHonorInfo(adapter),
    new SendForwardMsg(adapter),
    new SendGroupForwardMsg(adapter),
    new SendPrivateForwardMsg(adapter),
    new GetStrangerInfo(adapter),
    new DownloadFile(adapter),
    new GetGuildList(adapter),
    new MarkMsgAsRead(adapter),
    new UploadGroupFile(adapter),
    new UploadPrivateFile(adapter),
    new GetGroupMsgHistory(adapter),
    new GetForwardMsg(adapter),
    new HandleQuickOperation(adapter),
    new SetEssenceMsg(adapter),
    new DeleteEssenceMsg(adapter),
    new DelGroupFile(adapter),
    new GetGroupSystemMsg(adapter),
    new CreateGroupFileFolder(adapter),
    new DelGroupFolder(adapter),
    new GetGroupAtAllRemain(adapter),
    new GetGroupRootFiles(adapter),
    new SendGroupNotice(adapter),
    new GetGroupFilesByFolder(adapter),
    new GetGroupFileUrl(adapter),
    new GetGroupNotice(adapter),
    new DeleteFriend(adapter),
    new OCRImage(adapter),
    new GetGroupFileSystemInfo(adapter),
    new SetGroupSpecialTitle(adapter),
    new SendGroupSign(adapter),
    new SetQQProfile(adapter),
    new SetGroupPortrait(adapter)
  ];
  const actionMap = /* @__PURE__ */ new Map();
  for (const action of actionHandlers) {
    actionMap.set(action.actionName, action);
    actionMap.set(action.actionName + "_async", action);
    actionMap.set(action.actionName + "_rate_limited", action);
  }
  return actionMap;
}
class OB11GroupAdminNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_admin";
  sub_type;
  group_id;
  user_id;
  constructor(subType, groupId, userId) {
    super();
    this.sub_type = subType;
    this.group_id = groupId;
    this.user_id = userId;
  }
}
class OB11ProfileLikeEvent extends OB11BaseNoticeEvent {
  notice_type = "notify";
  sub_type = "profile_like";
  operator_id;
  operator_nick;
  times;
  constructor(operatorId, operatorNick, times) {
    super();
    this.operator_id = operatorId;
    this.operator_nick = operatorNick;
    this.times = times;
  }
}
var FlashFileDownloadStatus = /* @__PURE__ */ ((FlashFileDownloadStatus2) => {
  FlashFileDownloadStatus2[FlashFileDownloadStatus2["DOWNLOADING"] = 1] = "DOWNLOADING";
  FlashFileDownloadStatus2[FlashFileDownloadStatus2["DOWNLOADED"] = 2] = "DOWNLOADED";
  return FlashFileDownloadStatus2;
})(FlashFileDownloadStatus || {});
var FlashFileUploadStatus = /* @__PURE__ */ ((FlashFileUploadStatus2) => {
  FlashFileUploadStatus2[FlashFileUploadStatus2["UPLOADED"] = 4] = "UPLOADED";
  return FlashFileUploadStatus2;
})(FlashFileUploadStatus || {});
class OB11FlashFileEvent extends OB11BaseNoticeEvent {
  notice_type = "flash_file";
  sub_type;
  title = "";
  share_link = "";
  file_set_id = "";
  files = [];
  constructor(title, share_link, file_set_id, files) {
    super();
    this.title = title;
    this.share_link = share_link;
    this.file_set_id = file_set_id;
    this.files = [];
  }
}
class OB11FlashFileDownloadingEvent extends OB11FlashFileEvent {
  downloaded_size;
  total_size;
  speed;
  remain_seconds;
  constructor(title, share_link, file_set_id, downloaded_size, total_size, speed, remain_seconds, files) {
    super(title, share_link, file_set_id, files);
    this.sub_type = "downloading";
    this.downloaded_size = downloaded_size;
    this.total_size = total_size;
    this.speed = speed;
    this.remain_seconds = remain_seconds;
    this.files = files;
  }
}
class OB11FlashFileDownloadedEvent extends OB11FlashFileEvent {
  constructor(title, share_link, file_set_id, files) {
    super(title, share_link, file_set_id, files);
    this.sub_type = "downloaded";
  }
}
class OB11FlashFileUploadingEvent extends OB11FlashFileEvent {
  uploaded_size;
  total_size;
  speed;
  remain_seconds;
  constructor(title, share_link, file_set_id, uploaded_size, total_size, speed, remain_seconds, files = []) {
    super(title, share_link, file_set_id, files);
    this.sub_type = "uploading";
    this.uploaded_size = uploaded_size;
    this.total_size = total_size;
    this.speed = speed;
    this.remain_seconds = remain_seconds;
    this.files = files;
  }
}
class OB11FlashFileUploadedEvent extends OB11FlashFileEvent {
  constructor(title, share_link, file_set_id, files = []) {
    super(title, share_link, file_set_id, files);
    this.sub_type = "uploaded";
  }
}
class OneBot11Adapter extends Service2 {
  constructor(ctx, config) {
    super(ctx, "onebot", true);
    this.ctx = ctx;
    this.config = config;
    const actionMap = initActionMap(this);
    this.ob11Http = new OB11Http(ctx, {
      port: config.httpPort,
      token: config.token,
      actionMap,
      listenLocalhost: config.onlyLocalhost
    });
    this.ob11HttpPost = new OB11HttpPost(ctx, {
      hosts: config.httpPostUrls,
      heartInterval: config.heartInterval,
      secret: config.httpSecret,
      enableHttpHeart: config.enableHttpHeart
    });
    this.ob11WebSocket = new OB11WebSocket(ctx, {
      port: config.wsPort,
      heartInterval: config.heartInterval,
      token: config.token,
      actionMap,
      listenLocalhost: config.onlyLocalhost
    });
    this.ob11WebSocketReverseManager = new OB11WebSocketReverseManager(ctx, {
      hosts: config.wsReverseUrls,
      heartInterval: config.heartInterval,
      token: config.token,
      actionMap
    });
  }
  static inject = [
    "ntMsgApi",
    "ntFileApi",
    "ntFileCacheApi",
    "ntFriendApi",
    "ntGroupApi",
    "ntUserApi",
    "ntWebApi",
    "ntSystemApi",
    "store",
    "app"
  ];
  ob11WebSocket;
  ob11WebSocketReverseManager;
  ob11Http;
  ob11HttpPost;
  dispatch(event) {
    if (this.config.enableWs) {
      this.ob11WebSocket.emitEvent(event);
    }
    if (this.config.enableWsReverse) {
      this.ob11WebSocketReverseManager.emitEvent(event);
    }
    if (this.config.enableHttpPost) {
      this.ob11HttpPost.emitEvent(event);
    }
    if (this.config.enableHttp) {
      this.ob11Http.emitEvent(event);
    }
    if (event.meta_event_type !== "heartbeat") {
      postHttpEvent(event);
    }
  }
  async handleGroupNotify(notify, doubt) {
    try {
      const flag = `${notify.group.groupCode}|${notify.seq}|${notify.type}|${doubt ? "1" : "0"}`;
      if ([GroupNotifyType.MemberLeaveNotifyAdmin, GroupNotifyType.KickMemberNotifyAdmin].includes(notify.type)) {
        if (notify.user2.uid) {
          this.ctx.logger.info("", notify.group.groupCode, notify.user1.uid, notify.user2.uid);
          const memberUin = await this.ctx.ntUserApi.getUinByUid(notify.user1.uid);
          const adminUin = await this.ctx.ntUserApi.getUinByUid(notify.user2.uid);
          const event = new OB11GroupDecreaseEvent(
            parseInt(notify.group.groupCode),
            parseInt(memberUin),
            parseInt(adminUin),
            "kick"
          );
          this.dispatch(event);
        }
      } else if (notify.type === GroupNotifyType.RequestJoinNeedAdminiStratorPass && notify.status === GroupNotifyStatus.Unhandle) {
        this.ctx.logger.info("");
        const requestUin = await this.ctx.ntUserApi.getUinByUid(notify.user1.uid);
        const event = new OB11GroupRequestEvent(
          parseInt(notify.group.groupCode),
          parseInt(requestUin) || 0,
          flag,
          notify.postscript,
          "add"
        );
        this.dispatch(event);
      } else if (notify.type === GroupNotifyType.InvitedNeedAdminiStratorPass && notify.status === GroupNotifyStatus.Unhandle) {
        this.ctx.logger.info("");
        const userId = await this.ctx.ntUserApi.getUinByUid(notify.user1.uid);
        const invitorId = await this.ctx.ntUserApi.getUinByUid(notify.user2.uid);
        const event = new OB11GroupRequestEvent(
          parseInt(notify.group.groupCode),
          parseInt(userId) || 0,
          flag,
          notify.postscript,
          "add",
          parseInt(invitorId) || 0
        );
        this.dispatch(event);
      } else if ([
        GroupNotifyType.SetAdmin,
        GroupNotifyType.CancelAdminNotifyCanceled,
        GroupNotifyType.CancelAdminNotifyAdmin
      ].includes(notify.type)) {
        this.ctx.logger.info("");
        const uin = await this.ctx.ntUserApi.getUinByUid(notify.user1.uid);
        const event = new OB11GroupAdminNoticeEvent(
          notify.type === GroupNotifyType.SetAdmin ? "set" : "unset",
          parseInt(notify.group.groupCode),
          parseInt(uin)
        );
        this.dispatch(event);
      }
    } catch (e) {
      this.ctx.logger.error("", e.stack);
    }
  }
  handleMsg(message) {
    OB11Entities.message(this.ctx, message).then((msg) => {
      if (!msg) {
        return;
      }
      if (!this.config.debug && msg.message.length === 0) {
        return;
      }
      const isSelfMsg = msg.user_id.toString() === selfInfo.uin;
      if (isSelfMsg) {
        msg.target_id = parseInt(message.peerUin);
      }
      this.dispatch(msg);
    }).catch((e) => this.ctx.logger.error("handling incoming messages", e));
    OB11Entities.groupEvent(this.ctx, message).then((groupEvent) => {
      if (groupEvent) {
        this.dispatch(groupEvent);
      }
    }).catch((e) => this.ctx.logger.error("handling incoming group events", e));
    OB11Entities.privateEvent(this.ctx, message).then((privateEvent) => {
      if (privateEvent) {
        this.dispatch(privateEvent);
      }
    }).catch((e) => this.ctx.logger.error("handling incoming buddy events", e));
  }
  handleRecallMsg(message) {
    const peer = {
      peerUid: message.peerUid,
      chatType: message.chatType
    };
    const oriMessageId = this.ctx.store.getShortIdByMsgInfo(peer, message.msgId);
    if (!oriMessageId) {
      return;
    }
    OB11Entities.recallEvent(this.ctx, message, oriMessageId).then((recallEvent) => {
      if (recallEvent) {
        this.dispatch(recallEvent);
      }
    }).catch((e) => this.ctx.logger.error("handling recall events", e));
  }
  async handleFriendRequest(req) {
    let userId = 0;
    try {
      const requesterUin = await this.ctx.ntUserApi.getUinByUid(req.friendUid);
      userId = parseInt(requesterUin);
    } catch (e) {
      this.ctx.logger.error("QQ", e);
    }
    const flag = req.friendUid + "|" + req.reqTime;
    const comment = req.extWords;
    const friendRequestEvent = new OB11FriendRequestEvent(
      userId,
      comment,
      flag
    );
    this.dispatch(friendRequestEvent);
  }
  async handleConfigUpdated(config) {
    const old = this.config;
    this.ob11Http.updateConfig({
      listenLocalhost: config.onlyLocalhost,
      port: config.ob11.httpPort,
      token: config.ob11.token
    });
    this.ob11HttpPost.updateConfig({
      hosts: config.ob11.httpPostUrls,
      heartInterval: config.heartInterval,
      secret: config.ob11.httpSecret,
      enableHttpHeart: config.ob11.enableHttpHeart
    });
    this.ob11WebSocket.updateConfig({
      listenLocalhost: config.onlyLocalhost,
      port: config.ob11.wsPort,
      heartInterval: config.heartInterval,
      token: config.ob11.token
    });
    this.ob11WebSocketReverseManager.updateConfig({
      hosts: config.ob11.wsReverseUrls,
      heartInterval: config.heartInterval,
      token: config.ob11.token
    });
    if (config.ob11.enable) {
      if (config.ob11.enableHttp !== old.enableHttp || config.ob11.enable !== old.enable) {
        if (!config.ob11.enableHttp) {
          await this.ob11Http.stop();
        } else {
          this.ob11Http.start();
        }
      }
      if ((config.ob11.httpPort !== old.httpPort || config.onlyLocalhost !== old.onlyLocalhost) && config.ob11.enableHttp) {
        await this.ob11Http.stop();
        this.ob11Http.start();
      }
      if (config.ob11.enableWs !== old.enableWs || config.ob11.enable !== old.enable) {
        if (config.ob11.enableWs) {
          this.ob11WebSocket.start();
        } else {
          await this.ob11WebSocket.stop();
        }
      }
      if ((config.ob11.wsPort !== old.wsPort || config.onlyLocalhost !== old.onlyLocalhost) && config.ob11.enableWs) {
        await this.ob11WebSocket.stop();
        this.ob11WebSocket.start();
        llonebotError.wsServerError = "";
      }
      if (config.ob11.enableWsReverse !== old.enableWsReverse || config.ob11.enable !== old.enable) {
        if (config.ob11.enableWsReverse) {
          this.ob11WebSocketReverseManager.start();
        } else {
          this.ob11WebSocketReverseManager.stop();
        }
      }
      if (config.ob11.enableWsReverse) {
        if (config.ob11.wsReverseUrls.length !== old.wsReverseUrls.length) {
          this.ob11WebSocketReverseManager.stop();
          this.ob11WebSocketReverseManager.start();
        } else {
          for (const newHost of config.ob11.wsReverseUrls) {
            if (!old.wsReverseUrls.includes(newHost)) {
              this.ob11WebSocketReverseManager.stop();
              this.ob11WebSocketReverseManager.start();
              break;
            }
          }
        }
      }
      if (config.ob11.enableHttpHeart !== old.enableHttpHeart || config.ob11.enable !== old.enable) {
        this.ob11HttpPost.stop();
      }
      if (config.ob11.enableHttpPost) {
        this.ob11HttpPost.start();
      }
    } else {
      this.ob11Http.stop();
      this.ob11HttpPost.stop();
      this.ob11WebSocket.stop();
      this.ob11WebSocketReverseManager.stop();
    }
    Object.assign(this.config, {
      ...config.ob11,
      heartInterval: config.heartInterval,
      debug: config.debug,
      msgCacheExpire: config.msgCacheExpire,
      musicSignUrl: config.musicSignUrl,
      enableLocalFile2Url: config.enableLocalFile2Url,
      ffmpeg: config.ffmpeg
    });
  }
  start() {
    if (this.config.enable) {
      if (this.config.enableWs) {
        this.ob11WebSocket.start();
      }
      if (this.config.enableWsReverse) {
        this.ob11WebSocketReverseManager.start();
      }
      if (this.config.enableHttp) {
        this.ob11Http.start();
      }
      if (this.config.enableHttpPost) {
        this.ob11HttpPost.start();
      }
    }
    this.ctx.on("llob/config-updated", (input) => {
      this.handleConfigUpdated(input).catch((e) => {
      });
    });
    this.ctx.on("nt/message-created", (input) => {
      if (input.senderUid === selfInfo.uid) {
        if (!this.config.reportSelfMessage) {
          return;
        }
      }
      this.handleMsg(input);
    });
    this.ctx.on("nt/message-deleted", (input) => {
      this.handleRecallMsg(input);
    });
    this.ctx.on("nt/message-sent", (input) => {
      if (!this.config.reportSelfMessage) {
        return;
      }
      this.handleMsg(input);
    });
    this.ctx.on("nt/group-notify", (input) => {
      const { doubt, notify } = input;
      this.handleGroupNotify(notify, doubt);
    });
    this.ctx.on("nt/friend-request", (input) => {
      this.handleFriendRequest(input);
    });
    this.ctx.on("nt/system-message-created", async (input) => {
      const sysMsg = Msg.Message.decode(input);
      const { msgType, subType } = sysMsg.contentHead ?? {};
      if (msgType === 528 && subType === 39) {
        const tip = SysMsg.ProfileLikeTip.decode(sysMsg.body.msgContent);
        if (tip.msgType !== 0 || tip.subType !== 203) return;
        const detail = tip.content?.msg?.detail;
        if (!detail) return;
        const [times] = detail.txt?.match(/\d+/) ?? ["0"];
        const event = new OB11ProfileLikeEvent(detail.uin, detail.nickname, +times);
        this.dispatch(event);
      } else if (msgType === 33) {
        const tip = SysMsg.GroupMemberChange.decode(sysMsg.body.msgContent);
        if (tip.type !== 130) return;
        this.ctx.logger.info("", tip);
        const memberUin = await this.ctx.ntUserApi.getUinByUid(tip.memberUid);
        const operatorUin = await this.ctx.ntUserApi.getUinByUid(tip.adminUid);
        const event = new OB11GroupIncreaseEvent(tip.groupCode, +memberUin, +operatorUin);
        this.dispatch(event);
      } else if (msgType === 34) {
        const tip = SysMsg.GroupMemberChange.decode(sysMsg.body.msgContent);
        if (tip.type !== 130) return;
        this.ctx.logger.info("", tip);
        const memberUin = await this.ctx.ntUserApi.getUinByUid(tip.memberUid);
        const userId = Number(memberUin);
        const event = new OB11GroupDecreaseEvent(tip.groupCode, userId, userId);
        this.dispatch(event);
      }
    });
    this.ctx.on("nt/flash-file-download-status", (input) => {
      if (input.status === FlashFileDownloadStatus.DOWNLOADED) {
        const files = [];
        this.ctx.ntFileApi.getFlashFileList(input.info.fileSetId).then((res) => {
          for (const file of res) {
            for (const file2 of file.fileList) {
              files.push({
                name: file2.name,
                size: parseInt(file2.filePhysicalSize),
                path: file2.saveFilePath
              });
            }
          }
          const event = new OB11FlashFileDownloadedEvent(
            input.info.name,
            input.info.shareInfo.shareLink,
            input.info.fileSetId,
            files
          );
          this.dispatch(event);
        }).catch((err) => {
          this.ctx.logger.error(err, { fileSetId: input.info.fileSetId });
        });
      }
    });
    this.ctx.on("nt/flash-file-upload-status", (fileSetInfo) => {
      if (fileSetInfo.uploadStatus === FlashFileUploadStatus.UPLOADED) {
        const event = new OB11FlashFileUploadedEvent(
          fileSetInfo.name,
          fileSetInfo.shareInfo.shareLink,
          fileSetInfo.fileSetId
        );
        this.dispatch(event);
      }
    });
    this.ctx.on("nt/flash-file-downloading", (input) => {
      const [fileSetId, downloadingInfo] = input;
      this.ctx.ntFileApi.getFlashFileInfo(fileSetId, false).then((res) => {
        this.ctx.ntFileApi.getFlashFileList(fileSetId, false).then((fileList) => {
          const files = [];
          for (const file of fileList) {
            for (const file2 of file.fileList) {
              files.push({
                name: file2.name,
                size: parseInt(file2.filePhysicalSize),
                path: file2.saveFilePath
              });
            }
          }
          const event = new OB11FlashFileDownloadingEvent(
            res.name,
            res.shareInfo.shareLink,
            fileSetId,
            parseInt(downloadingInfo.curDownLoadedBytes),
            parseInt(downloadingInfo.totalDownLoadedBytes),
            downloadingInfo.curSpeedBps,
            downloadingInfo.remainDownLoadSeconds,
            files
          );
          this.dispatch(event);
        }).catch((err) => {
          this.ctx.logger.error(err);
        });
      }).catch((err) => {
        this.ctx.logger.error(err);
      });
    });
    this.ctx.on("nt/flash-file-uploading", (info) => {
      this.ctx.ntFileApi.getFlashFileList(info.fileSet.fileSetId, false).then((fileList) => {
        const files = [];
        for (const file of fileList) {
          for (const file2 of file.fileList) {
            files.push({
              name: file2.name,
              size: parseInt(file2.filePhysicalSize),
              path: file2.physical.localPath
            });
          }
        }
        const event = new OB11FlashFileUploadingEvent(
          info.fileSet.name,
          info.fileSet.shareInfo.shareLink,
          info.fileSet.fileSetId,
          parseInt(info.uploadedFileSize),
          parseInt(info.fileSet.totalFileSize),
          parseInt(info.uploadSpeed),
          parseInt(info.timeRemain),
          files
        );
        this.dispatch(event);
      });
    });
  }
}
var __defProp$3 = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name$3 = (target, value) => __defProp$3(target, "name", { value, configurable: true });
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var require_index = __commonJS({
  "src/index.ts"(exports, module) {
    var kElement = Symbol.for("satori.element");
    var ElementConstructor = class {
      static {
        __name$3(this, "ElementConstructor");
      }
      get data() {
        return this.attrs;
      }
      getTagName() {
        if (this.type === "component") {
          return this.attrs.is?.name ?? "component";
        } else {
          return this.type;
        }
      }
      toAttrString() {
        return Object.entries(this.attrs).map(([key2, value]) => {
          if (isNullable(value)) return "";
          key2 = hyphenate(key2);
          if (value === true) return ` ${key2}`;
          if (value === false) return ` no-${key2}`;
          return ` ${key2}="${Element.escape("" + value, true)}"`;
        }).join("");
      }
      toString(strip = false) {
        if (this.type === "text" && "content" in this.attrs) {
          return strip ? this.attrs.content : Element.escape(this.attrs.content);
        }
        const inner = this.children.map((child) => child.toString(strip)).join("");
        if (strip) return inner;
        const attrs = this.toAttrString();
        const tag = this.getTagName();
        if (!this.children.length) return `<${tag}${attrs}/>`;
        return `<${tag}${attrs}>${inner}</${tag}>`;
      }
    };
    defineProperty(ElementConstructor, "name", "Element");
    defineProperty(ElementConstructor.prototype, kElement, true);
    function Element(type2, ...args) {
      const el = Object.create(ElementConstructor.prototype);
      const attrs = {}, children = [];
      if (args[0] && typeof args[0] === "object" && !Element.isElement(args[0]) && !Array.isArray(args[0])) {
        const props = args.shift();
        for (const [key2, value] of Object.entries(props)) {
          if (isNullable(value)) continue;
          if (key2 === "children") {
            args.push(...makeArray(value));
          } else {
            attrs[camelize(key2)] = value;
          }
        }
      }
      for (const child of args) {
        children.push(...Element.toElementArray(child));
      }
      if (typeof type2 === "function") {
        attrs.is = type2;
        type2 = "component";
      }
      return Object.assign(el, { type: type2, attrs, children });
    }
    __name$3(Element, "Element");
    var evaluate = new Function("expr", "context", `
  try {
    with (context) {
      return eval(expr)
    }
  } catch {}
`);
    ((Element2) => {
      Element2.jsx = Element2;
      Element2.jsxs = Element2;
      Element2.jsxDEV = Element2;
      Element2.Fragment = "template";
      function isElement(source2) {
        return source2 && typeof source2 === "object" && source2[kElement];
      }
      Element2.isElement = isElement;
      __name$3(isElement, "isElement");
      function toElement(content) {
        if (typeof content === "string" || typeof content === "number" || typeof content === "boolean") {
          content = "" + content;
          if (content) return Element2("text", { content });
        } else if (isElement(content)) {
          return content;
        } else if (!isNullable(content)) {
          throw new TypeError(`Invalid content: ${content}`);
        }
      }
      Element2.toElement = toElement;
      __name$3(toElement, "toElement");
      function toElementArray(content) {
        if (Array.isArray(content)) {
          return content.map(toElement).filter(isNonNullable);
        } else {
          return [toElement(content)].filter(isNonNullable);
        }
      }
      Element2.toElementArray = toElementArray;
      __name$3(toElementArray, "toElementArray");
      function normalize(source2, context) {
        return typeof source2 === "string" ? parse3(source2, context) : toElementArray(source2);
      }
      Element2.normalize = normalize;
      __name$3(normalize, "normalize");
      function escape2(source2, inline = false) {
        const result = (source2 ?? "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        return inline ? result.replace(/"/g, "&quot;") : result;
      }
      Element2.escape = escape2;
      __name$3(escape2, "escape");
      function unescape2(source2) {
        return source2.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#(\d+);/g, (_, code) => code === "38" ? _ : String.fromCharCode(+code)).replace(/&#x([0-9a-f]+);/gi, (_, code) => code === "26" ? _ : String.fromCharCode(parseInt(code, 16))).replace(/&(amp|#38|#x26);/g, "&");
      }
      Element2.unescape = unescape2;
      __name$3(unescape2, "unescape");
      function from2(source2, options = {}) {
        const elements = parse3(source2);
        if (options.caret) {
          if (options.type && elements[0]?.type !== options.type) return;
          return elements[0];
        }
        return select(elements, options.type || "*")[0];
      }
      Element2.from = from2;
      __name$3(from2, "from");
      const combRegExp = / *([ >+~]) */g;
      function parseSelector(input) {
        return input.split(",").map((query) => {
          const selectors = [];
          query = query.trim();
          let combCap, combinator = " ";
          while (combCap = combRegExp.exec(query)) {
            selectors.push({ type: query.slice(0, combCap.index), combinator });
            combinator = combCap[1];
            query = query.slice(combCap.index + combCap[0].length);
          }
          selectors.push({ type: query, combinator });
          return selectors;
        });
      }
      Element2.parseSelector = parseSelector;
      __name$3(parseSelector, "parseSelector");
      function select(source2, query) {
        if (!source2 || !query) return [];
        if (typeof source2 === "string") source2 = parse3(source2);
        if (typeof query === "string") query = parseSelector(query);
        if (!query.length) return [];
        let adjacent = [];
        const results = [];
        for (const [index, element] of source2.entries()) {
          const inner = [];
          const local = [...query, ...adjacent];
          adjacent = [];
          let matched = false;
          for (const group of local) {
            const { type: type2, combinator } = group[0];
            if (type2 === element.type || type2 === "*") {
              if (group.length === 1) {
                matched = true;
              } else if ([" ", ">"].includes(group[1].combinator)) {
                inner.push(group.slice(1));
              } else if (group[1].combinator === "+") {
                adjacent.push(group.slice(1));
              } else {
                query.push(group.slice(1));
              }
            }
            if (combinator === " ") {
              inner.push(group);
            }
          }
          if (matched) results.push(source2[index]);
          results.push(...select(element.children, inner));
        }
        return results;
      }
      Element2.select = select;
      __name$3(select, "select");
      function interpolate(expr, context) {
        expr = expr.trim();
        if (!/^[\w.]+$/.test(expr)) {
          return evaluate(expr, context) ?? "";
        }
        let value = context;
        for (const part of expr.split(".")) {
          value = value[part];
          if (isNullable(value)) return "";
        }
        return value ?? "";
      }
      Element2.interpolate = interpolate;
      __name$3(interpolate, "interpolate");
      const tagRegExp1 = /(?<comment><!--[\s\S]*?-->)|(?<tag><(\/?)([^!\s>/]*)([^>]*?)\s*(\/?)>)/;
      const tagRegExp2 = /(?<comment><!--[\s\S]*?-->)|(?<tag><(\/?)([^!\s>/]*)([^>]*?)\s*(\/?)>)|(?<curly>\{(?<derivative>[@:/#][^\s}]*)?[\s\S]*?\})/;
      const attrRegExp1 = /([^\s=]+)(?:="(?<value1>[^"]*)"|='(?<value2>[^']*)')?/g;
      const attrRegExp2 = /([^\s=]+)(?:="(?<value1>[^"]*)"|='(?<value2>[^']*)'|=\{(?<curly>[^}]+)\})?/g;
      let Position;
      ((Position2) => {
        Position2[Position2["OPEN"] = 0] = "OPEN";
        Position2[Position2["CLOSE"] = 1] = "CLOSE";
        Position2[Position2["EMPTY"] = 2] = "EMPTY";
        Position2[Position2["CONTINUE"] = 3] = "CONTINUE";
      })(Position || (Position = {}));
      function parse3(source2, context) {
        const tokens = [];
        function pushText(content) {
          if (content) tokens.push(content);
        }
        __name$3(pushText, "pushText");
        const tagRegExp = context ? tagRegExp2 : tagRegExp1;
        let tagCap;
        let trimStart = true;
        while (tagCap = tagRegExp.exec(source2)) {
          const { curly, comment, derivative } = tagCap.groups;
          const trimEnd = !curly;
          parseContent(source2.slice(0, tagCap.index), trimStart, trimEnd);
          trimStart = trimEnd;
          source2 = source2.slice(tagCap.index + tagCap[0].length);
          const [_, , , close, type2, extra, empty] = tagCap;
          if (comment) continue;
          if (curly) {
            let name = "", position = 2;
            if (derivative) {
              name = derivative.slice(1);
              position = {
                "@": 2,
                "#": 0,
                "/": 1,
                ":": 3
                /* CONTINUE */
              }[derivative[0]];
            }
            tokens.push({
              type: "curly",
              name,
              position,
              source: curly,
              extra: curly.slice(1 + (derivative ?? "").length, -1)
            });
            continue;
          }
          tokens.push({
            type: "angle",
            source: _,
            name: type2 || Element2.Fragment,
            position: close ? 1 : empty ? 2 : 0,
            extra
          });
        }
        parseContent(source2, trimStart, true);
        function parseContent(source22, trimStart2, trimEnd) {
          source22 = unescape2(source22);
          if (trimStart2) source22 = source22.replace(/^\s*\n\s*/, "");
          if (trimEnd) source22 = source22.replace(/\s*\n\s*$/, "");
          pushText(source22);
        }
        __name$3(parseContent, "parseContent");
        return parseTokens(foldTokens(tokens), context);
      }
      Element2.parse = parse3;
      __name$3(parse3, "parse");
      function foldTokens(tokens) {
        const stack2 = [[{
          type: "angle",
          name: Element2.Fragment,
          position: 0,
          source: "",
          extra: "",
          children: { default: [] }
        }, "default"]];
        function pushToken(...tokens2) {
          const [token2, slot] = stack2[0];
          token2.children[slot].push(...tokens2);
        }
        __name$3(pushToken, "pushToken");
        for (const token2 of tokens) {
          if (typeof token2 === "string") {
            pushToken(token2);
            continue;
          }
          const { name, position } = token2;
          if (position === 1) {
            if (stack2[0][0].name === name) {
              stack2.shift();
            }
          } else if (position === 3) {
            stack2[0][0].children[name] = [];
            stack2[0][1] = name;
          } else if (position === 0) {
            pushToken(token2);
            token2.children = { default: [] };
            stack2.unshift([token2, "default"]);
          } else {
            pushToken(token2);
          }
        }
        return stack2[stack2.length - 1][0].children.default;
      }
      __name$3(foldTokens, "foldTokens");
      function parseTokens(tokens, context) {
        const result = [];
        for (const token2 of tokens) {
          if (typeof token2 === "string") {
            result.push(Element2("text", { content: token2 }));
          } else if (token2.type === "angle") {
            const attrs = {};
            const attrRegExp = context ? attrRegExp2 : attrRegExp1;
            let attrCap;
            while (attrCap = attrRegExp.exec(token2.extra)) {
              const [, key2, v1, v2 = v1, v3] = attrCap;
              if (v3) {
                attrs[key2] = interpolate(v3, context);
              } else if (!isNullable(v2)) {
                attrs[key2] = unescape2(v2);
              } else if (key2.startsWith("no-")) {
                attrs[key2.slice(3)] = false;
              } else {
                attrs[key2] = true;
              }
            }
            result.push(Element2(token2.name, attrs, token2.children && parseTokens(token2.children.default, context)));
          } else if (!token2.name) {
            result.push(...toElementArray(interpolate(token2.extra, context)));
          } else if (token2.name === "if") {
            if (evaluate(token2.extra, context)) {
              result.push(...parseTokens(token2.children.default, context));
            } else {
              result.push(...parseTokens(token2.children.else || [], context));
            }
          } else if (token2.name === "each") {
            const [expr, ident] = token2.extra.split(/\s+as\s+/);
            const items = interpolate(expr, context);
            if (!items || !items[Symbol.iterator]) continue;
            for (const item of items) {
              result.push(...parseTokens(token2.children.default, { ...context, [ident]: item }));
            }
          }
        }
        return result;
      }
      __name$3(parseTokens, "parseTokens");
      function visit(element, rules, session) {
        const { type: type2, attrs, children } = element;
        if (typeof rules === "function") {
          return rules(element, session);
        } else {
          let result = rules[typeof type2 === "string" ? type2 : ""] ?? rules.default ?? true;
          if (typeof result === "function") {
            result = result(attrs, children, session);
          }
          return result;
        }
      }
      __name$3(visit, "visit");
      function transform(source2, rules, session) {
        const elements = typeof source2 === "string" ? parse3(source2) : source2;
        const output2 = [];
        elements.forEach((element) => {
          const { type: type2, attrs, children } = element;
          const result = visit(element, rules, session);
          if (result === true) {
            output2.push(Element2(type2, attrs, transform(children, rules, session)));
          } else if (result !== false) {
            output2.push(...toElementArray(result));
          }
        });
        return typeof source2 === "string" ? output2.join("") : output2;
      }
      Element2.transform = transform;
      __name$3(transform, "transform");
      async function transformAsync(source2, rules, session) {
        const elements = typeof source2 === "string" ? parse3(source2) : source2;
        const children = (await Promise.all(elements.map(async (element) => {
          const { type: type2, attrs, children: children2 } = element;
          const result = await visit(element, rules, session);
          if (result === true) {
            return [Element2(type2, attrs, await transformAsync(children2, rules, session))];
          } else if (result !== false) {
            return toElementArray(result);
          } else {
            return [];
          }
        }))).flat(1);
        return typeof source2 === "string" ? children.join("") : children;
      }
      Element2.transformAsync = transformAsync;
      __name$3(transformAsync, "transformAsync");
      function createFactory(type2, ...keys) {
        return (...args) => {
          const element = Element2(type2);
          keys.forEach((key2, index) => {
            if (!isNullable(args[index])) {
              element.attrs[key2] = args[index];
            }
          });
          if (args[keys.length]) {
            Object.assign(element.attrs, args[keys.length]);
          }
          return element;
        };
      }
      __name$3(createFactory, "createFactory");
      Element2.warn = /* @__PURE__ */ __name$3(() => {
      }, "warn");
      function createAssetFactory(type2) {
        return (src, ...args) => {
          let prefix = "base64://";
          if (typeof args[0] === "string") {
            prefix = `data:${args.shift()};base64,`;
          }
          if (is("Buffer", src)) {
            src = prefix + src.toString("base64");
          } else if (is("ArrayBuffer", src)) {
            src = prefix + Binary.toBase64(src);
          } else if (ArrayBuffer.isView(src)) {
            src = prefix + Binary.toBase64(src.buffer);
          }
          if (src.startsWith("base64://")) {
            (0, Element2.warn)(`protocol "base64:" is deprecated and will be removed in the future, please use "data:" instead`);
          }
          return Element2(type2, { ...args[0], src });
        };
      }
      __name$3(createAssetFactory, "createAssetFactory");
      Element2.text = createFactory("text", "content");
      Element2.at = createFactory("at", "id");
      Element2.sharp = createFactory("sharp", "id");
      Element2.quote = createFactory("quote", "id");
      Element2.image = createAssetFactory("img");
      Element2.img = createAssetFactory("img");
      Element2.video = createAssetFactory("video");
      Element2.audio = createAssetFactory("audio");
      Element2.file = createAssetFactory("file");
      function i18n(path2, children) {
        return Element2("i18n", typeof path2 === "string" ? { path: path2 } : path2, children);
      }
      Element2.i18n = i18n;
      __name$3(i18n, "i18n");
    })(Element || (Element = {}));
    module.exports = Element;
  }
});
const h = require_index();
var __defProp$2 = Object.defineProperty;
var __name$2 = (target, value) => __defProp$2(target, "name", { value, configurable: true });
function Field(name) {
  return { name };
}
__name$2(Field, "Field");
function Method(name, fields, isForm = false) {
  return { name, fields: fields.map(Field), isForm };
}
__name$2(Method, "Method");
var Methods = {
  "channel.get": Method("getChannel", ["channel_id", "guild_id"]),
  "channel.list": Method("getChannelList", ["guild_id", "next"]),
  "channel.create": Method("createChannel", ["guild_id", "data"]),
  "channel.update": Method("updateChannel", ["channel_id", "data"]),
  "channel.delete": Method("deleteChannel", ["channel_id"]),
  "channel.mute": Method("muteChannel", ["channel_id", "guild_id", "enable"]),
  "message.create": Method("createMessage", ["channel_id", "content", "referrer"]),
  "message.update": Method("editMessage", ["channel_id", "message_id", "content"]),
  "message.delete": Method("deleteMessage", ["channel_id", "message_id"]),
  "message.get": Method("getMessage", ["channel_id", "message_id"]),
  "message.list": Method("getMessageList", ["channel_id", "next", "direction", "limit", "order"]),
  "reaction.create": Method("createReaction", ["channel_id", "message_id", "emoji"]),
  "reaction.delete": Method("deleteReaction", ["channel_id", "message_id", "emoji", "user_id"]),
  "reaction.clear": Method("clearReaction", ["channel_id", "message_id", "emoji"]),
  "reaction.list": Method("getReactionList", ["channel_id", "message_id", "emoji", "next"]),
  "upload.create": Method("createUpload", [], true),
  "guild.get": Method("getGuild", ["guild_id"]),
  "guild.list": Method("getGuildList", ["next"]),
  "guild.member.get": Method("getGuildMember", ["guild_id", "user_id"]),
  "guild.member.list": Method("getGuildMemberList", ["guild_id", "next"]),
  "guild.member.kick": Method("kickGuildMember", ["guild_id", "user_id", "permanent"]),
  "guild.member.mute": Method("muteGuildMember", ["guild_id", "user_id", "duration", "reason"]),
  "guild.member.role.set": Method("setGuildMemberRole", ["guild_id", "user_id", "role_id"]),
  "guild.member.role.unset": Method("unsetGuildMemberRole", ["guild_id", "user_id", "role_id"]),
  "guild.member.role.list": Method("getGuildMemberRoleList", ["guild_id", "user_id", "next"]),
  "guild.role.list": Method("getGuildRoleList", ["guild_id", "next"]),
  "guild.role.create": Method("createGuildRole", ["guild_id", "data"]),
  "guild.role.update": Method("updateGuildRole", ["guild_id", "role_id", "data"]),
  "guild.role.delete": Method("deleteGuildRole", ["guild_id", "role_id"]),
  "login.get": Method("getLogin", []),
  "user.get": Method("getUser", ["user_id"]),
  "user.channel.create": Method("createDirectChannel", ["user_id", "guild_id"]),
  "friend.list": Method("getFriendList", ["next"]),
  "friend.delete": Method("deleteFriend", ["user_id"]),
  "friend.approve": Method("handleFriendRequest", ["message_id", "approve", "comment"]),
  "guild.approve": Method("handleGuildRequest", ["message_id", "approve", "comment"]),
  "guild.member.approve": Method("handleGuildMemberRequest", ["message_id", "approve", "comment"])
};
var Channel;
((Channel2) => {
  ((Type2) => {
    Type2[Type2["TEXT"] = 0] = "TEXT";
    Type2[Type2["DIRECT"] = 1] = "DIRECT";
    Type2[Type2["CATEGORY"] = 2] = "CATEGORY";
    Type2[Type2["VOICE"] = 3] = "VOICE";
  })(Channel2.Type || (Channel2.Type = {}));
})(Channel || (Channel = {}));
function Resource(attrs = [], children = [], content) {
  return { attrs, children, content };
}
__name$2(Resource, "Resource");
((Resource2) => {
  const Definitions = {
    user: Resource2(["id", "name", "nick", "avatar", "isBot"]),
    member: Resource2(["name", "nick", "avatar"]),
    channel: Resource2(["id", "type", "name"]),
    guild: Resource2(["id", "name", "avatar"]),
    quote: Resource2(["id"], ["quote", "user", "member", "channel"], "content")
  };
  function encode2(type2, data) {
    const resource = Definitions[type2];
    const element = h(type2, pick(data, resource.attrs));
    for (const key2 of resource.children) {
      if (isNullable(data[key2])) continue;
      element.children.push(encode2(key2, data[key2]));
    }
    if (resource.content && !isNullable(data[resource.content])) {
      element.children.push(...h.parse(data[resource.content]));
    }
    return element;
  }
  Resource2.encode = encode2;
  __name$2(encode2, "encode");
  function decode2(element) {
    const data = element.attrs;
    const resource = Definitions[element.type];
    for (const key2 of resource.children) {
      const index = element.children.findIndex((el) => el.type === key2);
      if (index === -1) continue;
      const [child] = element.children.splice(index, 1);
      data[key2] = decode2(child);
    }
    if (resource.content && element.children.length) {
      data[resource.content] = element.children.join("");
    }
    return data;
  }
  Resource2.decode = decode2;
  __name$2(decode2, "decode");
})(Resource || (Resource = {}));
function transformKey(source2, callback) {
  if (!source2 || typeof source2 !== "object") return source2;
  if (Array.isArray(source2)) return source2.map((value) => transformKey(value, callback));
  return Object.fromEntries(Object.entries(source2).map(([key2, value]) => {
    if (key2.startsWith("_") || key2 === "referrer") return [key2, value];
    return [callback(key2), transformKey(value, callback)];
  }));
}
__name$2(transformKey, "transformKey");
var Status = /* @__PURE__ */ ((Status2) => {
  Status2[Status2["OFFLINE"] = 0] = "OFFLINE";
  Status2[Status2["ONLINE"] = 1] = "ONLINE";
  Status2[Status2["CONNECT"] = 2] = "CONNECT";
  Status2[Status2["DISCONNECT"] = 3] = "DISCONNECT";
  Status2[Status2["RECONNECT"] = 4] = "RECONNECT";
  return Status2;
})(Status || {});
var Opcode = /* @__PURE__ */ ((Opcode2) => {
  Opcode2[Opcode2["EVENT"] = 0] = "EVENT";
  Opcode2[Opcode2["PING"] = 1] = "PING";
  Opcode2[Opcode2["PONG"] = 2] = "PONG";
  Opcode2[Opcode2["IDENTIFY"] = 3] = "IDENTIFY";
  Opcode2[Opcode2["READY"] = 4] = "READY";
  Opcode2[Opcode2["META"] = 5] = "META";
  return Opcode2;
})(Opcode || {});
var WebSocket;
((WebSocket2) => {
  WebSocket2.CONNECTING = 0;
  WebSocket2.OPEN = 1;
  WebSocket2.CLOSING = 2;
  WebSocket2.CLOSED = 3;
})(WebSocket || (WebSocket = {}));
const getChannel = async (ctx, payload) => {
  const info = await ctx.ntGroupApi.getGroupAllInfo(payload.channel_id);
  return {
    id: payload.channel_id,
    type: Channel.Type.TEXT,
    name: info.groupName
  };
};
const getChannelList = async (ctx, payload) => {
  const info = await ctx.ntGroupApi.getGroupAllInfo(payload.guild_id);
  return {
    data: [{
      id: payload.guild_id,
      type: Channel.Type.TEXT,
      name: info.groupName
    }]
  };
};
const updateChannel = async (ctx, payload) => {
  if (payload.data.name) {
    await ctx.ntGroupApi.setGroupName(payload.channel_id, payload.data.name);
  }
  return {};
};
const deleteChannel = async (ctx, payload) => {
  await ctx.ntGroupApi.quitGroup(payload.channel_id);
  return {};
};
const muteChannel = async (ctx, payload) => {
  await ctx.ntGroupApi.banGroup(payload.channel_id, payload.duration !== 0);
  return {};
};
const createDirectChannel = async (ctx, payload) => {
  return {
    id: "private:" + payload.user_id,
    type: Channel.Type.DIRECT
  };
};
function decodeUser(user) {
  return {
    id: user.uin,
    name: user.nick,
    nick: user.remark || user.nick,
    avatar: `http://q.qlogo.cn/headimg_dl?dst_uin=${user.uin}&spec=640`,
    is_bot: false
  };
}
function decodeGuildChannelId(data) {
  if (data.chatType === ChatType.Group) {
    return [data.peerUin, data.peerUin];
  } else {
    return [void 0, "private:" + data.peerUin];
  }
}
function decodeMessageUser(data) {
  return {
    id: data.senderUin,
    name: data.sendNickName,
    nick: data.sendRemarkName || data.sendNickName,
    avatar: `http://q.qlogo.cn/headimg_dl?dst_uin=${data.senderUin}&spec=640`
  };
}
async function decodeElement(ctx, data, quoted = false) {
  const buffer2 = [];
  for (const v of data.elements) {
    if (v.textElement && v.textElement.atType !== AtType.Unknown) {
      const { atNtUid, atUid, atType, content } = v.textElement;
      if (atType === AtType.All) {
        buffer2.push(h.at(void 0, { type: "all" }));
      } else if (atType === AtType.One) {
        let id;
        if (atUid && atUid !== "0") {
          id = atUid;
        } else {
          id = await ctx.ntUserApi.getUinByUid(atNtUid);
        }
        buffer2.push(h.at(id, { name: content.replace("@", "") }));
      }
    } else if (v.textElement && v.textElement.content) {
      buffer2.push(h.text(v.textElement.content));
    } else if (v.replyElement && !quoted) {
      const peer = {
        chatType: data.chatType,
        peerUid: data.peerUid,
        guildId: ""
      };
      const { replayMsgSeq, replyMsgTime, sourceMsgIdInRecords } = v.replyElement;
      const records = data.records.find((msgRecord) => msgRecord.msgId === sourceMsgIdInRecords);
      const senderUid = v.replyElement.senderUidStr || records?.senderUid;
      if (!records || !replyMsgTime || !senderUid) {
        ctx.logger.error("", v.replyElement);
        continue;
      }
      if (data.multiTransInfo) {
        buffer2.push(h.quote(records.msgId));
        continue;
      }
      try {
        const { msgList } = await ctx.ntMsgApi.getMsgsBySeqAndCount(peer, replayMsgSeq, 1, true, true);
        let replyMsg;
        if (records.msgRandom !== "0") {
          replyMsg = msgList.find((msg) => msg.msgRandom === records.msgRandom);
        } else {
          ctx.logger.info("msgRandom is missing", v.replyElement, records);
          replyMsg = msgList[0];
        }
        if (!replyMsg) {
          ctx.logger.warn("", v.replyElement, records);
          continue;
        }
        const elements = await decodeElement(ctx, replyMsg, true);
        buffer2.push(h("quote", { id: replyMsg.msgId }, elements));
      } catch (e) {
        ctx.logger.error("", e, v.replyElement, e.stack);
      }
    } else if (v.picElement) {
      const src = await ctx.ntFileApi.getImageUrl(v.picElement);
      buffer2.push(h.img(src, {
        width: v.picElement.picWidth,
        height: v.picElement.picHeight,
        subType: v.picElement.picSubType
      }));
    } else if (v.pttElement) {
      const src = pathToFileURL(v.pttElement.filePath).href;
      buffer2.push(h.audio(src, { duration: v.pttElement.duration }));
    } else if (v.videoElement) {
      const src = await ctx.ntFileApi.getVideoUrl({
        chatType: data.chatType,
        peerUid: data.peerUid
      }, data.msgId, v.elementId) || pathToFileURL(v.videoElement.filePath).href;
      buffer2.push(h.video(src));
    } else if (v.marketFaceElement) {
      const { emojiId, supportSize } = v.marketFaceElement;
      const { width = 300, height = 300 } = supportSize?.[0] ?? {};
      const dir = emojiId.substring(0, 2);
      const src = `https://gxh.vip.qq.com/club/item/parcel/item/${dir}/${emojiId}/raw${width}.gif`;
      buffer2.push(h("mface", {
        emojiPackageId: v.marketFaceElement.emojiPackageId,
        emojiId,
        key: v.marketFaceElement.key,
        summary: v.marketFaceElement.faceName
      }, [h.image(src, { width, height })]));
    } else if (v.faceElement) {
      const { faceIndex, faceType } = v.faceElement;
      buffer2.push(h("face", {
        id: String(faceIndex),
        type: String(faceType),
        platform: "llonebot"
      }));
    } else if (v.arkElement) {
      buffer2.push(h("llonebot:ark", {
        data: v.arkElement.bytesData
      }));
    }
  }
  return buffer2;
}
async function decodeMessage(ctx, data, message = {}) {
  if (!data.senderUin || data.senderUin === "0") return;
  const [guildId, channelId] = decodeGuildChannelId(data);
  const elements = await decodeElement(ctx, data);
  if (elements.length === 0) return;
  message.id = data.msgId;
  message.content = elements.join("");
  message.channel = {
    id: channelId,
    name: data.peerName,
    type: guildId ? Channel.Type.TEXT : Channel.Type.DIRECT
  };
  message.user = decodeMessageUser(data);
  message.created_at = +data.msgTime * 1e3;
  if (!message.user.name) {
    const info = (await ctx.ntUserApi.getUserSimpleInfo(data.senderUid)).coreInfo;
    message.user.name = info.nick;
    message.user.nick = info.remark || info.nick;
    if (message.channel.type === Channel.Type.DIRECT) {
      message.channel.name = info.nick;
    }
  }
  if (guildId) {
    message.guild = {
      id: guildId,
      name: data.peerName,
      avatar: `https://p.qlogo.cn/gh/${guildId}/${guildId}/640`
    };
    message.member = {
      user: message.user,
      nick: data.sendMemberName || message.user.name
    };
  }
  return message;
}
function decodeGuildMember(data) {
  return {
    user: {
      ...decodeUser(data),
      is_bot: data.isRobot
    },
    nick: data.cardName || data.nick,
    avatar: `http://q.qlogo.cn/headimg_dl?dst_uin=${data.uin}&spec=640`,
    joined_at: data.joinTime * 1e3
  };
}
function decodeGuild(data) {
  return {
    id: data.groupCode,
    name: data.groupName,
    avatar: `https://p.qlogo.cn/gh/${data.groupCode}/${data.groupCode}/640`
  };
}
async function getPeer(ctx, channelId) {
  let peerUid = channelId;
  let chatType = ChatType.Group;
  if (peerUid.includes("private:")) {
    const uin = channelId.replace("private:", "");
    const uid = await ctx.ntUserApi.getUidByUin(uin);
    if (!uid) throw new Error("");
    const isBuddy = await ctx.ntFriendApi.isBuddy(uid);
    chatType = isBuddy ? ChatType.C2C : ChatType.TempC2CFromGroup;
    peerUid = uid;
  }
  return {
    chatType,
    peerUid,
    guildId: ""
  };
}
const getGuild = async (ctx, payload) => {
  const info = await ctx.ntGroupApi.getGroupAllInfo(payload.guild_id);
  return decodeGuild(info);
};
const getGuildList = async (ctx) => {
  const groups = await ctx.ntGroupApi.getGroups();
  return {
    data: groups.map(decodeGuild)
  };
};
const handleGuildRequest = async (ctx, payload) => {
  await ctx.ntGroupApi.handleGroupRequest(
    payload.message_id,
    payload.approve ? GroupRequestOperateTypes.Approve : GroupRequestOperateTypes.Reject,
    payload.comment
  );
  return {};
};
const getLogin = async (ctx) => {
  const features = [];
  for (const [feature, info] of Object.entries(Methods)) {
    if (info.name in handlers) {
      features.push(feature);
    }
  }
  features.push("guild.plain");
  await ctx.ntUserApi.getSelfNick();
  return {
    sn: ctx.get("satori")._loginSeq,
    user: decodeUser(selfInfo),
    adapter: "llonebot",
    platform: "llonebot",
    status: selfInfo.online ? Status.ONLINE : Status.OFFLINE,
    features,
    proxy_urls: []
  };
};
const getGuildMember = async (ctx, payload) => {
  const uid = await ctx.ntUserApi.getUidByUin(payload.user_id);
  if (!uid) throw new Error("");
  const info = await ctx.ntGroupApi.getGroupMember(payload.guild_id, uid);
  if (!info) {
    throw new Error(`${payload.user_id}`);
  }
  return decodeGuildMember(info);
};
const getGuildMemberList = async (ctx, payload) => {
  let members = await ctx.ntGroupApi.getGroupMembers(payload.guild_id);
  if (members.size === 0) {
    await ctx.sleep(100);
    members = await ctx.ntGroupApi.getGroupMembers(payload.guild_id);
  }
  return {
    data: Array.from(members.values()).map(decodeGuildMember)
  };
};
const kickGuildMember = async (ctx, payload) => {
  const uid = await ctx.ntUserApi.getUidByUin(payload.user_id, payload.guild_id);
  if (!uid) throw new Error("");
  await ctx.ntGroupApi.kickMember(payload.guild_id, [uid], Boolean(payload.permanent));
  return {};
};
const muteGuildMember = async (ctx, payload) => {
  const uid = await ctx.ntUserApi.getUidByUin(payload.user_id, payload.guild_id);
  if (!uid) throw new Error("");
  await ctx.ntGroupApi.banMember(payload.guild_id, [
    { uid, timeStamp: payload.duration / 1e3 }
  ]);
  return {};
};
const handleGuildMemberRequest = async (ctx, payload) => {
  await ctx.ntGroupApi.handleGroupRequest(
    payload.message_id,
    payload.approve ? GroupRequestOperateTypes.Approve : GroupRequestOperateTypes.Reject,
    payload.comment
  );
  return {};
};
class State {
  constructor(type2) {
    this.type = type2;
  }
  children = [];
}
class MessageEncoder {
  constructor(ctx, channelId) {
    this.ctx = ctx;
    this.channelId = channelId;
  }
  errors = [];
  results = [];
  elements = [];
  deleteAfterSentFiles = [];
  stack = [new State("message")];
  peer;
  async flush() {
    if (this.elements.length === 0) return;
    if (this.stack[0].type === "multiForward") {
      this.stack[0].children.push(...this.elements);
      this.elements = [];
      return;
    }
    this.peer ??= await getPeer(this.ctx, this.channelId);
    const sent = await this.ctx.ntMsgApi.sendMsg(this.peer, this.elements);
    if (sent) {
      this.ctx.logger.info("", this.peer);
      const result = await decodeMessage(this.ctx, sent);
      if (result) {
        this.results.push(result);
      }
    }
    this.deleteAfterSentFiles.forEach((path2) => {
      try {
        unlink(path2).then().catch((e) => {
        });
      } catch (e) {
      }
    });
    this.deleteAfterSentFiles = [];
    this.elements = [];
  }
  async fetchFile(url) {
    const res = await uri2local(this.ctx, url);
    if (!res.success) {
      this.ctx.logger.error(res.errMsg);
      throw Error(res.errMsg);
    }
    if (!res.isLocal) {
      this.deleteAfterSentFiles.push(res.path);
    }
    return res.path;
  }
  async getPeerFromMsgId(msgId) {
    this.peer ??= await getPeer(this.ctx, this.channelId);
    const msg = (await this.ctx.ntMsgApi.getMsgsByMsgId(this.peer, [msgId])).msgList;
    if (msg.length > 0) {
      return this.peer;
    } else {
      const cacheMsg = this.ctx.store.getMsgCache(msgId);
      if (cacheMsg) {
        return {
          peerUid: cacheMsg.peerUid,
          chatType: cacheMsg.chatType
        };
      }
      const c2cMsg = await this.ctx.ntMsgApi.queryMsgsById(ChatType.C2C, msgId);
      if (c2cMsg.msgList.length) {
        return {
          peerUid: c2cMsg.msgList[0].peerUid,
          chatType: c2cMsg.msgList[0].chatType
        };
      }
      const groupMsg = await this.ctx.ntMsgApi.queryMsgsById(ChatType.Group, msgId);
      if (groupMsg.msgList.length) {
        return {
          peerUid: groupMsg.msgList[0].peerUid,
          chatType: groupMsg.msgList[0].chatType
        };
      }
    }
  }
  async forward(msgId, srcPeer, destPeer) {
    const list = await this.ctx.ntMsgApi.forwardMsg(srcPeer, destPeer, [msgId]);
    return list[0];
  }
  async multiForward() {
    if (!this.stack[0].children.length) return;
    const selfPeer = {
      chatType: ChatType.C2C,
      peerUid: selfInfo.uid
    };
    const nodeMsgIds = [];
    for (const node of this.stack[0].children) {
      if (typeof node === "string") {
        if (node.length !== 19) {
          this.ctx.logger.warn(" ID ", node);
          continue;
        }
        const peer = await this.getPeerFromMsgId(node);
        if (!peer) {
          this.ctx.logger.warn("", node);
          continue;
        }
        nodeMsgIds.push({ msgId: node, peer });
      } else {
        try {
          const sent = await this.ctx.ntMsgApi.sendMsg(selfPeer, [node]);
          if (!sent) {
            this.ctx.logger.warn("", node);
            continue;
          }
          nodeMsgIds.push({ msgId: sent.msgId, peer: selfPeer });
          await this.ctx.sleep(100);
        } catch (e) {
          this.ctx.logger.error("", e);
        }
      }
    }
    let srcPeer;
    let needSendSelf = false;
    for (const { peer } of nodeMsgIds) {
      srcPeer ??= { chatType: peer.chatType, peerUid: peer.peerUid };
      if (srcPeer.peerUid !== peer.peerUid) {
        needSendSelf = true;
        break;
      }
    }
    let retMsgIds = [];
    if (needSendSelf) {
      for (const { msgId, peer } of nodeMsgIds) {
        const srcPeer2 = {
          peerUid: peer.peerUid,
          chatType: peer.chatType
        };
        const clonedMsg = await this.forward(msgId, srcPeer2, selfPeer);
        if (clonedMsg) {
          retMsgIds.push(clonedMsg.msgId);
        }
        await this.ctx.sleep(100);
      }
      srcPeer = selfPeer;
    } else {
      retMsgIds = nodeMsgIds.map((e) => e.msgId);
    }
    if (retMsgIds.length === 0) {
      throw Error("");
    }
    if (this.stack[1].type === "multiForward") {
      this.peer ??= await getPeer(this.ctx, this.channelId);
      const msg = await this.ctx.ntMsgApi.multiForwardMsg(srcPeer, selfPeer, retMsgIds);
      this.stack[1].children.push(...msg.elements);
    } else {
      this.peer ??= await getPeer(this.ctx, this.channelId);
      await this.ctx.ntMsgApi.multiForwardMsg(srcPeer, this.peer, retMsgIds);
      this.ctx.logger.info("", this.peer);
    }
  }
  async visit(element) {
    const { type: type2, attrs, children } = element;
    if (type2 === "text") {
      this.elements.push(SendElement.text(attrs.content));
    } else if (type2 === "at") {
      this.peer ??= await getPeer(this.ctx, this.channelId);
      if (this.peer.chatType !== ChatType.Group) {
        return;
      }
      if (attrs.type === "all") {
        this.elements.push(SendElement.at("", "", AtType.All, "@"));
      } else {
        const uid = await this.ctx.ntUserApi.getUidByUin(attrs.id, this.peer.peerUid) ?? "";
        const display = attrs.name ? "@" + attrs.name : "";
        this.elements.push(SendElement.at(attrs.id, uid, AtType.One, display));
      }
    } else if (type2 === "a") {
      await this.render(children);
      const prev = this.elements.at(-1);
      if (prev?.elementType === 1 && prev.textElement.atType === 0) {
        prev.textElement.content += ` ( ${attrs.href} )`;
      }
    } else if (type2 === "img" || type2 === "image") {
      const url = attrs.src ?? attrs.url;
      const path2 = await this.fetchFile(url);
      const element2 = await SendElement.pic(this.ctx, path2);
      this.deleteAfterSentFiles.push(element2.picElement.sourcePath);
      this.elements.push(element2);
    } else if (type2 === "audio") {
      await this.flush();
      const url = attrs.src ?? attrs.url;
      const path2 = await this.fetchFile(url);
      this.elements.push(await SendElement.ptt(this.ctx, path2));
      await this.flush();
    } else if (type2 === "video") {
      await this.flush();
      const url = attrs.src ?? attrs.url;
      const path2 = await this.fetchFile(url);
      let thumb;
      if (attrs.poster) {
        thumb = await this.fetchFile(attrs.poster);
      }
      const element2 = await SendElement.video(this.ctx, path2, thumb);
      this.deleteAfterSentFiles.push(element2.videoElement.filePath);
      this.elements.push(element2);
      await this.flush();
    } else if (type2 === "file") {
      await this.flush();
      const url = attrs.src ?? attrs.url;
      const path2 = await this.fetchFile(url);
      const fileName = attrs.title ?? path__default.basename(path2);
      this.elements.push(await SendElement.file(this.ctx, path2, fileName));
      await this.flush();
    } else if (type2 === "br") {
      this.elements.push(SendElement.text("\n"));
    } else if (type2 === "p") {
      const prev = this.elements.at(-1);
      if (prev?.elementType === 1 && prev.textElement.atType === 0) {
        if (!prev.textElement.content.endsWith("\n")) {
          prev.textElement.content += "\n";
        }
      } else if (prev) {
        this.elements.push(SendElement.text("\n"));
      }
      await this.render(children);
      const last = this.elements.at(-1);
      if (last?.elementType === 1 && last.textElement.atType === 0) {
        if (!last.textElement.content.endsWith("\n")) {
          last.textElement.content += "\n";
        }
      } else {
        this.elements.push(SendElement.text("\n"));
      }
    } else if (type2 === "message") {
      if (attrs.id && attrs.forward) {
        await this.flush();
        const srcPeer = await this.getPeerFromMsgId(attrs.id);
        if (srcPeer) {
          this.peer ??= await getPeer(this.ctx, this.channelId);
          const sent = await this.forward(attrs.id, srcPeer, this.peer);
          if (sent) {
            this.ctx.logger.info("", this.peer);
            const result = await decodeMessage(this.ctx, sent);
            if (result) {
              this.results.push(result);
            }
          }
        }
      } else if (attrs.forward) {
        await this.flush();
        this.stack.unshift(new State("multiForward"));
        await this.render(children);
        await this.flush();
        await this.multiForward();
        this.stack.shift();
      } else if (attrs.id && this.stack[0].type === "multiForward") {
        this.stack[0].children.push(attrs.id);
      } else {
        await this.render(children);
        await this.flush();
      }
    } else if (type2 === "quote") {
      this.peer ??= await getPeer(this.ctx, this.channelId);
      const source2 = (await this.ctx.ntMsgApi.getMsgsByMsgId(this.peer, [attrs.id])).msgList[0];
      if (source2) {
        this.elements.push(SendElement.reply(source2.msgSeq, source2.msgId, source2.senderUin));
      }
    } else if (type2 === "face") {
      this.elements.push(SendElement.face(+attrs.id, +attrs.type));
    } else if (type2 === "mface") {
      this.elements.push(SendElement.mface(
        +attrs.emojiPackageId,
        attrs.emojiId,
        attrs.key,
        attrs.summary
      ));
    } else {
      await this.render(children);
    }
  }
  async render(elements, flush) {
    for (const element of elements) {
      await this.visit(element);
    }
    if (flush) {
      await this.flush();
    }
  }
  async send(content) {
    const elements = h.normalize(content);
    await this.render(elements);
    await this.flush();
    if (this.errors.length) {
      throw new AggregateError(this.errors);
    } else {
      return this.results;
    }
  }
}
const createMessage = (ctx, payload) => {
  const encoder = new MessageEncoder(ctx, payload.channel_id);
  return encoder.send(payload.content);
};
const getMessage = async (ctx, payload) => {
  const peer = await getPeer(ctx, payload.channel_id);
  const raw = ctx.store.getMsgCache(payload.message_id) ?? (await ctx.ntMsgApi.getMsgsByMsgId(peer, [payload.message_id])).msgList[0];
  const result = await decodeMessage(ctx, raw);
  if (!result) {
    throw new Error("");
  }
  return result;
};
const deleteMessage = async (ctx, payload) => {
  const peer = await getPeer(ctx, payload.channel_id);
  const data = await ctx.ntMsgApi.recallMsg(peer, [payload.message_id]);
  if (data.result !== 0) {
    ctx.logger.error("message.delete", payload.message_id, data);
    throw new Error(``);
  }
  return {};
};
const getMessageList = async (ctx, payload) => {
  const count = payload.limit ?? 50;
  const peer = await getPeer(ctx, payload.channel_id);
  let msgList;
  if (!payload.next) {
    msgList = (await ctx.ntMsgApi.getAioFirstViewLatestMsgs(peer, count)).msgList;
  } else {
    msgList = (await ctx.ntMsgApi.getMsgHistory(peer, payload.next, count)).msgList;
  }
  const data = filterNullable(await Promise.all(msgList.map((e) => decodeMessage(ctx, e))));
  if (payload.order === "desc") data.reverse();
  return {
    data,
    next: msgList.at(-1)?.msgId
  };
};
const createReaction = async (ctx, payload) => {
  const peer = await getPeer(ctx, payload.channel_id);
  const { msgList } = await ctx.ntMsgApi.getMsgsByMsgId(peer, [payload.message_id]);
  if (!msgList.length || !msgList[0].msgSeq) {
    throw new Error("");
  }
  await ctx.ntMsgApi.setEmojiLike(peer, msgList[0].msgSeq, payload.emoji, true);
  return {};
};
const deleteReaction = async (ctx, payload) => {
  const peer = await getPeer(ctx, payload.channel_id);
  const { msgList } = await ctx.ntMsgApi.getMsgsByMsgId(peer, [payload.message_id]);
  if (!msgList.length || !msgList[0].msgSeq) {
    throw new Error("");
  }
  await ctx.ntMsgApi.setEmojiLike(peer, msgList[0].msgSeq, payload.emoji, false);
  return {};
};
const getReactionList = async (ctx, payload) => {
  const peer = await getPeer(ctx, payload.channel_id);
  const { msgList } = await ctx.ntMsgApi.getMsgsByMsgId(peer, [payload.message_id]);
  if (!msgList.length || !msgList[0].msgSeq) {
    throw new Error("");
  }
  const emojiType = payload.emoji.length > 3 ? "2" : "1";
  const count = msgList[0].emojiLikesList.find((e) => e.emojiId === payload.emoji)?.likesCnt ?? "50";
  const data = await ctx.ntMsgApi.getMsgEmojiLikesList(peer, msgList[0].msgSeq, payload.emoji, emojiType, +count);
  const uids = await Promise.all(data.emojiLikesList.map((e) => ctx.ntUserApi.getUidByUin(e.tinyId, peer.peerUid)));
  const raw = await ctx.ntUserApi.getCoreAndBaseInfo(filterNullable(uids));
  return {
    data: Array.from(raw.values()).map((e) => decodeUser(e.coreInfo))
  };
};
const setGuildMemberRole = async (ctx, payload) => {
  const uid = await ctx.ntUserApi.getUidByUin(payload.user_id, payload.guild_id);
  if (!uid) {
    throw new Error("");
  }
  if (payload.role_id !== "2" && payload.role_id !== "3") {
    throw new Error("role_id  2  3");
  }
  await ctx.ntGroupApi.setMemberRole(payload.guild_id, uid, +payload.role_id);
  return {};
};
const getGuildRoleList = () => {
  return {
    data: [
      {
        id: "4",
        name: "owner"
      },
      {
        id: "3",
        name: "admin"
      },
      {
        id: "2",
        name: "member"
      }
    ]
  };
};
const getUser = async (ctx, payload) => {
  const uin = payload.user_id;
  const uid = await ctx.ntUserApi.getUidByUin(uin);
  if (!uid) throw new Error("");
  const data = await ctx.ntUserApi.getUserSimpleInfo(uid);
  const ranges = await ctx.ntUserApi.getRobotUinRange();
  return {
    ...decodeUser(data.coreInfo),
    is_bot: ranges.some((e) => uin >= e.minUin && uin <= e.maxUin)
  };
};
const getFriendList = async (ctx) => {
  const friends = await ctx.ntFriendApi.getBuddyList();
  return {
    data: friends.map((e) => decodeUser(e.coreInfo))
  };
};
const handleFriendRequest = async (ctx, payload) => {
  const data = payload.message_id.split("|");
  if (data.length < 2) {
    throw new Error(" message_id");
  }
  const uid = data[0];
  const reqTime = data[1];
  await ctx.ntFriendApi.handleFriendRequest(uid, reqTime, payload.approve);
  return {};
};
const handlers = {
  //  (Channel)
  getChannel,
  getChannelList,
  updateChannel,
  deleteChannel,
  muteChannel,
  createDirectChannel,
  //  (Guild)
  getGuild,
  getGuildList,
  handleGuildRequest,
  //  (Login)
  getLogin,
  //  (GuildMember)
  getGuildMember,
  getGuildMemberList,
  kickGuildMember,
  muteGuildMember,
  handleGuildMemberRequest,
  //  (Message)
  createMessage,
  getMessage,
  deleteMessage,
  getMessageList,
  //  (Reaction)
  createReaction,
  deleteReaction,
  getReactionList,
  //  (GuildRole)
  setGuildMemberRole,
  getGuildRoleList,
  //  (User)
  getUser,
  getFriendList,
  handleFriendRequest
};
class Locked extends Error {
  constructor(port) {
    super(`${port} is locked`);
  }
}
const lockedPorts = {
  old: /* @__PURE__ */ new Set(),
  young: /* @__PURE__ */ new Set()
};
const releaseOldLockedPortsIntervalMs = 1e3 * 15;
let timeout;
const getLocalHosts = () => {
  const interfaces = os__default.networkInterfaces();
  const results = /* @__PURE__ */ new Set([void 0, "0.0.0.0"]);
  for (const _interface of Object.values(interfaces)) {
    for (const config of _interface) {
      results.add(config.address);
    }
  }
  return results;
};
const checkAvailablePort = (options) => new Promise((resolve2, reject) => {
  const server = require$$1$5.createServer();
  server.unref();
  server.on("error", reject);
  server.listen(options, () => {
    const { port } = server.address();
    server.close(() => {
      resolve2(port);
    });
  });
});
const getAvailablePort$1 = async (options, hosts) => {
  if (options.host || options.port === 0) {
    return checkAvailablePort(options);
  }
  for (const host of hosts) {
    try {
      await checkAvailablePort({ port: options.port, host });
    } catch (error) {
      if (!["EADDRNOTAVAIL", "EINVAL"].includes(error.code)) {
        throw error;
      }
    }
  }
  return options.port;
};
const portCheckSequence = function* (ports) {
  if (ports) {
    yield* ports;
  }
  yield 0;
};
async function getPorts(options) {
  let ports;
  let exclude = /* @__PURE__ */ new Set();
  if (options) {
    if (options.port) {
      ports = typeof options.port === "number" ? [options.port] : options.port;
    }
    if (options.exclude) {
      const excludeIterable = options.exclude;
      if (typeof excludeIterable[Symbol.iterator] !== "function") {
        throw new TypeError("The `exclude` option must be an iterable.");
      }
      for (const element of excludeIterable) {
        if (typeof element !== "number") {
          throw new TypeError("Each item in the `exclude` option must be a number corresponding to the port you want excluded.");
        }
        if (!Number.isSafeInteger(element)) {
          throw new TypeError(`Number ${element} in the exclude option is not a safe integer and can't be used`);
        }
      }
      exclude = new Set(excludeIterable);
    }
  }
  if (timeout === void 0) {
    timeout = setTimeout(() => {
      timeout = void 0;
      lockedPorts.old = lockedPorts.young;
      lockedPorts.young = /* @__PURE__ */ new Set();
    }, releaseOldLockedPortsIntervalMs);
    if (timeout.unref) {
      timeout.unref();
    }
  }
  const hosts = getLocalHosts();
  for (const port of portCheckSequence(ports)) {
    try {
      if (exclude.has(port)) {
        continue;
      }
      let availablePort = await getAvailablePort$1({ ...options, port }, hosts);
      while (lockedPorts.old.has(availablePort) || lockedPorts.young.has(availablePort)) {
        if (port !== 0) {
          throw new Locked(port);
        }
        availablePort = await getAvailablePort$1({ ...options, port }, hosts);
      }
      lockedPorts.young.add(availablePort);
      return availablePort;
    } catch (error) {
      if (!["EADDRINUSE", "EACCES"].includes(error.code) && !(error instanceof Locked)) {
        throw error;
      }
    }
  }
  throw new Error("No available ports found");
}
async function getAvailablePort(startPort, range2 = 100) {
  const ports = Array.from({ length: range2 }, (_, i) => startPort + i);
  return await getPorts({ port: ports });
}
async function recordPort(uin, savePort) {
  const savePath = path__default.join(getFixedDataDir(), `ports_${uin}.json`);
  fsPromise.writeFile(savePath, JSON.stringify(savePort, null, 2)).then().catch(console.error);
}
class SatoriServer {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    this.express = express();
    this.express.use(express.json({ limit: "50mb" }));
    this.actionMap = initActionMap(this);
  }
  express;
  httpServer;
  wsServer;
  wsClients = [];
  actionMap;
  async CallOneBot11API(action, params) {
    const handler = this.actionMap.get(action);
    if (!handler) {
      throw new Error(`Unsupported OB11 action: ${action}`);
    }
    return handler.handle(params);
  }
  async handleOneBotRequest(req, res) {
    if (this.checkAuth(req, res)) return;
    const action = req.params.action;
    const params = req.method === "POST" ? req.body : req.query;
    let result;
    try {
      result = await this.CallOneBot11API(action, params);
    } catch (e) {
      result = OB11Response.error(e?.toString() ?? String(e), 200);
    }
    res.json(result);
  }
  start() {
    this.express.route("/v1/internal/onebot11/:action").post(this.handleOneBotRequest.bind(this)).get(this.handleOneBotRequest.bind(this));
    this.express.get("/v1/:name", async (req, res) => {
      res.status(405).send("Please use POST method to send requests.");
    });
    this.express.post("/v1/:name", async (req, res) => {
      const method = Methods[req.params.name];
      if (!method) {
        res.status(404).send("method not found");
        return;
      }
      if (this.checkAuth(req, res)) return;
      const selfId = req.headers["satori-user-id"] ?? req.headers["x-self-id"];
      const platform = req.headers["satori-platform"] ?? req.headers["x-platform"];
      if (selfId !== selfInfo.uin || !platform) {
        res.status(403).send("login not found");
        return;
      }
      const handle = handlers[method.name];
      if (!handle) {
        res.status(404).send("method not found");
        return;
      }
      try {
        const result = await handle(this.ctx, req.body);
        res.json(result);
      } catch (e) {
        this.ctx.logger.error(e);
        throw e;
      }
    });
    let { onlyLocalhost, port } = this.config;
    let host = onlyLocalhost ? "127.0.0.1" : "";
    getAvailablePort(port).then((availablePort) => {
      if (availablePort !== port) {
        return this.ctx.logger.warn(` ${port} `);
      }
      this.httpServer = this.express.listen(port, host, (error) => {
        this.ctx.logger.info(`Satori server started ${host}:${port}`);
        if (error) {
          this.ctx.logger.error("Failed to start Satori server:", error);
        }
      });
      this.wsServer = new WebSocketServer({
        server: this.httpServer
      });
      this.wsServer.on("connection", (socket, req) => {
        const url = req.url?.split("?").shift();
        if (!["/v1/events", "/v1/events/"].includes(url)) {
          return socket.close(1008, "invalid address");
        }
        socket.addEventListener("message", async (event) => {
          let payload;
          try {
            payload = JSON.parse(event.data.toString());
          } catch (error) {
            return socket.close(4e3, "invalid message");
          }
          if (payload.op === Opcode.IDENTIFY) {
            if (this.config.token && payload.body?.token !== this.config.token) {
              return socket.close(4004, "invalid token");
            }
            this.ctx.logger.info("ws connect", url);
            socket.send(JSON.stringify({
              op: Opcode.READY,
              body: {
                logins: [await handlers.getLogin(this.ctx, {})],
                proxy_urls: []
              }
            }));
            this.wsClients.push(socket);
          } else if (payload.op === Opcode.PING) {
            socket.send(JSON.stringify({
              op: Opcode.PONG,
              body: {}
            }));
          }
        });
      });
    });
  }
  async stop() {
    if (this.wsClients.length > 0) {
      for (const socket of this.wsClients) {
        try {
          if (socket.readyState === WebSocket$1.OPEN) {
            socket.close(1e3);
          }
        } catch {
        }
      }
    }
    if (this.wsServer) {
      const close = promisify(this.wsServer.close);
      await close.call(this.wsServer);
      this.wsServer = void 0;
    }
    if (this.httpServer) {
      const close = promisify(this.httpServer.close);
      await close.call(this.httpServer);
      this.httpServer = void 0;
    }
  }
  checkAuth(req, res) {
    if (!this.config.token) return;
    if (req.headers.authorization !== `Bearer ${this.config.token}`) {
      res.status(403).send("invalid token");
      return true;
    }
  }
  async dispatch(body) {
    this.wsClients.forEach((socket) => {
      if (socket.readyState === WebSocket$1.OPEN) {
        socket.send(JSON.stringify({
          op: Opcode.EVENT,
          body
        }));
        this.ctx.logger.info("WebSocket ", socket.url ?? "", body.type);
      }
    });
  }
  updateConfig(config) {
    Object.assign(this.config, config);
  }
}
async function parseMessageCreated(bot, input) {
  const message = await decodeMessage(bot.ctx, input);
  if (!message) return;
  return bot.event("message-created", {
    message: omit(message, ["member", "user", "channel", "guild"]),
    member: message.member,
    user: message.user,
    channel: message.channel,
    guild: message.guild
  });
}
async function parseMessageDeleted(bot, input) {
  const origin = bot.ctx.store.getMsgCache(input.msgId);
  if (!origin) return;
  const message = await decodeMessage(bot.ctx, origin);
  if (!message) return;
  const operatorUid = input.elements[0].grayTipElement.revokeElement.operatorUid;
  const user = await bot.ctx.ntUserApi.getUserSimpleInfo(operatorUid);
  return bot.event("message-deleted", {
    message: omit(message, ["member", "user", "channel", "guild"]),
    member: message.member,
    user: message.user,
    channel: message.channel,
    guild: message.guild,
    operator: omit(decodeUser(user.coreInfo), ["is_bot"])
  });
}
async function parseGuildAdded(bot, input) {
  const groupAll = await bot.ctx.ntGroupApi.getGroupAllInfo(input.peerUid);
  return bot.event("guild-added", {
    guild: decodeGuild(groupAll)
  });
}
async function parseGuildRemoved(bot, input) {
  const groupAll = await bot.ctx.ntGroupApi.getGroupAllInfo(input.peerUid);
  return bot.event("guild-removed", {
    guild: decodeGuild(groupAll)
  });
}
async function parseGuildRequest(bot, notify) {
  const groupCode = notify.group.groupCode;
  const flag = groupCode + "|" + notify.seq + "|" + notify.type;
  return bot.event("guild-request", {
    guild: decodeGuild(notify.group),
    message: {
      id: flag,
      content: notify.postscript
    }
  });
}
async function parseGuildMemberAdded(bot, input, isBot = false) {
  const groupAll = await bot.ctx.ntGroupApi.getGroupAllInfo(input.peerUid);
  let memberUid;
  if (input.elements[0].grayTipElement?.groupElement) {
    memberUid = input.elements[0].grayTipElement.groupElement.memberUid;
  } else if (input.elements[0].grayTipElement?.jsonGrayTipElement) {
    const json = JSON.parse(input.elements[0].grayTipElement.jsonGrayTipElement.jsonStr);
    const uin = new URL(json.items[2].jp).searchParams.get("robot_uin");
    if (!uin) return;
    memberUid = await bot.ctx.ntUserApi.getUidByUin(uin);
  } else {
    const iterator = input.elements[0].grayTipElement?.xmlElement?.members.keys();
    iterator?.next();
    memberUid = iterator?.next().value;
  }
  if (!memberUid) return;
  const user = decodeUser((await bot.ctx.ntUserApi.getUserSimpleInfo(memberUid)).coreInfo);
  user.is_bot = isBot;
  return bot.event("guild-member-added", {
    guild: decodeGuild(groupAll),
    user,
    member: {
      user,
      nick: user.name
    }
  });
}
async function parseGuildMemberRemoved(bot, input) {
  const user = decodeUser((await bot.ctx.ntUserApi.getUserSimpleInfo(input.user1.uid)).coreInfo);
  return bot.event("guild-member-removed", {
    guild: decodeGuild(input.group),
    user,
    member: {
      user,
      nick: user.name
    }
  });
}
async function parseGuildMemberRequest(bot, input, doubt) {
  const groupCode = input.group.groupCode;
  const flag = `${groupCode}|${input.seq}|${input.type}|${doubt === true ? "1" : "0"}`;
  return bot.event("guild-member-request", {
    guild: decodeGuild(input.group),
    message: {
      id: flag,
      content: input.postscript
    }
  });
}
async function parseFriendRequest(bot, input) {
  const flag = input.friendUid + "|" + input.reqTime;
  const user = await bot.ctx.ntUserApi.getUserSimpleInfo(input.friendUid);
  return bot.event("friend-request", {
    user: decodeUser(user.coreInfo),
    message: {
      id: flag,
      content: input.extWords
    }
  });
}
class SatoriAdapter extends Service2 {
  constructor(ctx, config) {
    super(ctx, "satori", true);
    this.ctx = ctx;
    this.config = config;
    this.selfId = selfInfo.uin;
    this.server = new SatoriServer(ctx, config);
    this._eventSeq = 0;
    this._loginSeq = 1;
  }
  static inject = [
    "ntMsgApi",
    "ntFileApi",
    "ntFileCacheApi",
    "ntFriendApi",
    "ntGroupApi",
    "ntUserApi",
    "ntWebApi",
    "store"
  ];
  selfId;
  server;
  _eventSeq;
  _loginSeq;
  async handleMessage(input) {
    if (input.msgType === 5 && input.subMsgType === 8 && input.elements[0]?.grayTipElement?.groupElement?.type === 1 && input.elements[0].grayTipElement.groupElement.memberUid === selfInfo.uid) {
      return await parseGuildAdded(this, input);
    } else if (input.msgType === 5 && input.subMsgType === 12 && input.elements[0]?.grayTipElement?.xmlElement?.templId === "10179" && input.elements[0].grayTipElement.xmlElement.templParam.get("invitee") === selfInfo.uin) {
      return await parseGuildAdded(this, input);
    } else if (input.msgType === 5 && input.subMsgType === 8 && input.elements[0]?.grayTipElement?.groupElement?.type === 3) {
      return await parseGuildRemoved(this, input);
    } else if (input.msgType === 5 && input.subMsgType === 8 && input.elements[0]?.grayTipElement?.groupElement?.type === 1) {
      return await parseGuildMemberAdded(this, input);
    } else if (input.msgType === 5 && input.subMsgType === 12 && input.elements[0]?.grayTipElement?.xmlElement?.templId === "10179") {
      return await parseGuildMemberAdded(this, input);
    } else if (input.msgType === 5 && input.subMsgType === 12 && input.elements[0]?.grayTipElement?.jsonGrayTipElement?.busiId === "19217") {
      return await parseGuildMemberAdded(this, input, true);
    } else if (input.msgType === 5 && input.subMsgType === 12 && input.elements[0]?.grayTipElement?.xmlElement?.templId === "10382") ;
    else {
      return await parseMessageCreated(this, input);
    }
  }
  async handleGroupNotify(input, doubt) {
    if (input.type === GroupNotifyType.InvitedByMember && input.status === GroupNotifyStatus.Unhandle) {
      return await parseGuildRequest(this, input);
    } else if (input.type === GroupNotifyType.MemberLeaveNotifyAdmin || input.type === GroupNotifyType.KickMemberNotifyAdmin) {
      return await parseGuildMemberRemoved(this, input);
    } else if (input.type === GroupNotifyType.RequestJoinNeedAdminiStratorPass && input.status === GroupNotifyStatus.Unhandle) {
      return await parseGuildMemberRequest(this, input, doubt);
    } else if (input.type === GroupNotifyType.InvitedNeedAdminiStratorPass && input.status === GroupNotifyStatus.Unhandle) {
      return await parseGuildMemberRequest(this, input, doubt);
    }
  }
  start() {
    if (this.config.enable) {
      this.server.start();
    }
    this.ctx.on("nt/message-created", async (input) => {
      const event = await this.handleMessage(input).catch((e) => this.ctx.logger.error(e));
      if (event) {
        this.server.dispatch(event);
      }
    });
    this.ctx.on("nt/group-notify", async (input) => {
      const { doubt, notify } = input;
      const event = await this.handleGroupNotify(notify, doubt).catch((e) => this.ctx.logger.error(e));
      if (event) {
        this.server.dispatch(event);
      }
    });
    this.ctx.on("nt/message-deleted", async (input) => {
      const event = await parseMessageDeleted(this, input).catch((e) => this.ctx.logger.error(e));
      if (event) {
        this.server.dispatch(event);
      }
    });
    this.ctx.on("nt/friend-request", async (input) => {
      const event = await parseFriendRequest(this, input).catch((e) => this.ctx.logger.error(e));
      if (event) {
        this.server.dispatch(event);
      }
    });
    this.ctx.on("llob/config-updated", async (input) => {
      const old = omit(this.config, ["ffmpeg"]);
      const inputSatoriConfig = {
        ...input.satori,
        onlyLocalhost: input.onlyLocalhost
      };
      if (!isDeepStrictEqual(old, inputSatoriConfig)) {
        await this.server.stop();
        this.server.updateConfig(inputSatoriConfig);
        if (inputSatoriConfig.enable) {
          this.server.start();
        }
      }
      Object.assign(this.config, { ...inputSatoriConfig, ffmpeg: input.ffmpeg });
    });
  }
  event(type2, data) {
    const sn = ++this._eventSeq;
    return {
      // @ts-expect-error: For backward compatibility
      id: sn,
      sn,
      type: type2,
      self_id: this.selfId,
      platform: "llonebot",
      timestamp: Date.now(),
      ...data
    };
  }
}
var __defProp$1 = Object.defineProperty;
var __name$1 = (target, value) => __defProp$1(target, "name", { value, configurable: true });
function escapeId(value) {
  return "`" + value + "`";
}
__name$1(escapeId, "escapeId");
function isBracketed(value) {
  return value.startsWith("(") && value.endsWith(")");
}
__name$1(isBracketed, "isBracketed");
function isSqlJson(type2) {
  return type2 ? type2.type === "json" || !!type2.inner : false;
}
__name$1(isSqlJson, "isSqlJson");
var Builder = class {
  constructor(driver, tables) {
    this.driver = driver;
    this.state.tables = tables;
    this.queryOperators = {
      // logical
      $or: /* @__PURE__ */ __name$1((key2, value) => this.logicalOr(value.map((value2) => this.parseFieldQuery(key2, value2))), "$or"),
      $and: /* @__PURE__ */ __name$1((key2, value) => this.logicalAnd(value.map((value2) => this.parseFieldQuery(key2, value2))), "$and"),
      $not: /* @__PURE__ */ __name$1((key2, value) => this.logicalNot(this.parseFieldQuery(key2, value)), "$not"),
      // existence
      $exists: /* @__PURE__ */ __name$1((key2, value) => this.createNullQuery(key2, value), "$exists"),
      // comparison
      $eq: this.createEqualQuery,
      $ne: this.comparator("!="),
      $gt: this.comparator(">"),
      $gte: this.comparator(">="),
      $lt: this.comparator("<"),
      $lte: this.comparator("<="),
      // membership
      $in: /* @__PURE__ */ __name$1((key2, value) => this.createMemberQuery(key2, value, ""), "$in"),
      $nin: /* @__PURE__ */ __name$1((key2, value) => this.createMemberQuery(key2, value, " NOT"), "$nin"),
      // regexp
      $regex: /* @__PURE__ */ __name$1((key2, value) => this.createRegExpQuery(key2, value), "$regex"),
      $regexFor: /* @__PURE__ */ __name$1((key2, value) => typeof value === "string" ? `${this.escape(value)} collate utf8mb4_bin regexp ${key2}` : `${this.escape(value.input)} ${value.flags?.includes("i") ? "regexp" : "collate utf8mb4_bin regexp"} ${key2}`, "$regexFor"),
      // bitwise
      $bitsAllSet: /* @__PURE__ */ __name$1((key2, value) => `${key2} & ${this.escape(value)} = ${this.escape(value)}`, "$bitsAllSet"),
      $bitsAllClear: /* @__PURE__ */ __name$1((key2, value) => `${key2} & ${this.escape(value)} = 0`, "$bitsAllClear"),
      $bitsAnySet: /* @__PURE__ */ __name$1((key2, value) => `${key2} & ${this.escape(value)} != 0`, "$bitsAnySet"),
      $bitsAnyClear: /* @__PURE__ */ __name$1((key2, value) => `${key2} & ${this.escape(value)} != ${this.escape(value)}`, "$bitsAnyClear"),
      // list
      $el: /* @__PURE__ */ __name$1((key2, value) => {
        if (Array.isArray(value)) {
          return this.logicalOr(value.map((value2) => this.createElementQuery(key2, value2)));
        } else if (typeof value !== "number" && typeof value !== "string") {
          throw new TypeError("query expr under $el is not supported");
        } else {
          return this.createElementQuery(key2, value);
        }
      }, "$el"),
      $size: /* @__PURE__ */ __name$1((key2, value) => {
        if (this.isJsonQuery(key2)) {
          return `${this.jsonLength(key2)} = ${this.escape(value)}`;
        } else {
          if (!value) return this.logicalNot(key2);
          return `${key2} AND LENGTH(${key2}) - LENGTH(REPLACE(${key2}, ${this.escape(",")}, ${this.escape("")})) = ${this.escape(value)} - 1`;
        }
      }, "$size")
    };
    this.evalOperators = {
      // universal
      $: /* @__PURE__ */ __name$1((key2) => this.getRecursive(key2), "$"),
      $select: /* @__PURE__ */ __name$1((args) => `${args.map((arg) => this.parseEval(arg)).join(", ")}`, "$select"),
      $if: /* @__PURE__ */ __name$1((args) => `if(${args.map((arg) => this.parseEval(arg)).join(", ")})`, "$if"),
      $ifNull: /* @__PURE__ */ __name$1((args) => `ifnull(${args.map((arg) => this.parseEval(arg)).join(", ")})`, "$ifNull"),
      // number
      $add: /* @__PURE__ */ __name$1((args) => `(${args.map((arg) => this.parseEval(arg)).join(" + ")})`, "$add"),
      $multiply: /* @__PURE__ */ __name$1((args) => `(${args.map((arg) => this.parseEval(arg)).join(" * ")})`, "$multiply"),
      $subtract: this.binary("-"),
      $divide: this.binary("/"),
      $modulo: this.binary("%"),
      // mathemetic
      $abs: /* @__PURE__ */ __name$1((arg) => `abs(${this.parseEval(arg)})`, "$abs"),
      $floor: /* @__PURE__ */ __name$1((arg) => `floor(${this.parseEval(arg)})`, "$floor"),
      $ceil: /* @__PURE__ */ __name$1((arg) => `ceil(${this.parseEval(arg)})`, "$ceil"),
      $round: /* @__PURE__ */ __name$1((arg) => `round(${this.parseEval(arg)})`, "$round"),
      $exp: /* @__PURE__ */ __name$1((arg) => `exp(${this.parseEval(arg)})`, "$exp"),
      $log: /* @__PURE__ */ __name$1((args) => `log(${args.filter((x) => !isNullable(x)).map((arg) => this.parseEval(arg)).reverse().join(", ")})`, "$log"),
      $power: /* @__PURE__ */ __name$1((args) => `power(${args.map((arg) => this.parseEval(arg)).join(", ")})`, "$power"),
      $random: /* @__PURE__ */ __name$1(() => `rand()`, "$random"),
      // string
      $concat: /* @__PURE__ */ __name$1((args) => `concat(${args.map((arg) => this.parseEval(arg)).join(", ")})`, "$concat"),
      $regex: /* @__PURE__ */ __name$1(([key2, value, flags]) => `(${this.parseEval(key2)} ${flags?.includes("i") || value instanceof RegExp && value.flags.includes("i") ? "regexp" : "collate utf8mb4_bin regexp"} ${this.parseEval(value)})`, "$regex"),
      // logical / bitwise
      $or: /* @__PURE__ */ __name$1((args) => {
        const type2 = Type.fromTerm(this.state.expr, Type.Boolean);
        if (Field$1.boolean.includes(type2.type)) return this.logicalOr(args.map((arg) => this.parseEval(arg)));
        else return `(${args.map((arg) => this.parseEval(arg)).join(" | ")})`;
      }, "$or"),
      $and: /* @__PURE__ */ __name$1((args) => {
        const type2 = Type.fromTerm(this.state.expr, Type.Boolean);
        if (Field$1.boolean.includes(type2.type)) return this.logicalAnd(args.map((arg) => this.parseEval(arg)));
        else return `(${args.map((arg) => this.parseEval(arg)).join(" & ")})`;
      }, "$and"),
      $not: /* @__PURE__ */ __name$1((arg) => {
        const type2 = Type.fromTerm(this.state.expr, Type.Boolean);
        if (Field$1.boolean.includes(type2.type)) return this.logicalNot(this.parseEval(arg));
        else return `(~(${this.parseEval(arg)}))`;
      }, "$not"),
      // boolean
      $eq: this.binary("="),
      $ne: this.binary("!="),
      $gt: this.binary(">"),
      $gte: this.binary(">="),
      $lt: this.binary("<"),
      $lte: this.binary("<="),
      // membership
      $in: /* @__PURE__ */ __name$1(([key2, value]) => this.asEncoded(this.createMemberQuery(this.parseEval(key2, false), value, ""), false), "$in"),
      $nin: /* @__PURE__ */ __name$1(([key2, value]) => this.asEncoded(this.createMemberQuery(this.parseEval(key2, false), value, " NOT"), false), "$nin"),
      // typecast
      $literal: /* @__PURE__ */ __name$1(([value, type2]) => this.escape(value, type2), "$literal"),
      // aggregation
      $sum: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `ifnull(sum(${value}), 0)`), "$sum"),
      $avg: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `avg(${value})`), "$avg"),
      $min: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `min(${value})`), "$min"),
      $max: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `max(${value})`), "$max"),
      $count: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `count(distinct ${value})`), "$count"),
      $length: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `count(${value})`, (value) => this.isEncoded() ? this.jsonLength(value) : this.asEncoded(`if(${value}, LENGTH(${value}) - LENGTH(REPLACE(${value}, ${this.escape(",")}, ${this.escape("")})) + 1, 0)`, false)), "$length"),
      $object: /* @__PURE__ */ __name$1((fields) => this.groupObject(fields), "$object"),
      $array: /* @__PURE__ */ __name$1((expr) => this.groupArray(this.transform(this.parseEval(expr, false), expr, "encode")), "$array"),
      $get: /* @__PURE__ */ __name$1(([x, key2]) => typeof key2 === "string" ? this.asEncoded(`json_extract(${this.parseEval(x, false)}, '$.${key2}')`, true) : this.asEncoded(`json_extract(${this.parseEval(x, false)}, concat('$[', ${this.parseEval(key2)}, ']'))`, true), "$get"),
      $exec: /* @__PURE__ */ __name$1((sel) => this.parseSelection(sel), "$exec")
    };
  }
  static {
    __name$1(this, "Builder");
  }
  escapeMap = {};
  escapeRegExp;
  createEqualQuery = this.comparator("=");
  queryOperators;
  evalOperators;
  state = {};
  $true = "1";
  $false = "0";
  modifiedTable;
  transformers = /* @__PURE__ */ Object.create(null);
  createNullQuery(key2, value) {
    return `${key2} is ${value ? "not " : ""}null`;
  }
  createMemberQuery(key2, value, notStr = "") {
    if (Array.isArray(value)) {
      if (!value.length) return notStr ? this.$true : this.$false;
      if (Array.isArray(value[0])) {
        return `(${key2})${notStr} in (${value.map((val) => `(${val.map((x) => this.escape(x)).join(", ")})`).join(", ")})`;
      }
      return `${key2}${notStr} in (${value.map((val) => this.escape(val)).join(", ")})`;
    } else if (value.$exec) {
      return `(${key2})${notStr} in ${this.parseSelection(value.$exec, true)}`;
    } else {
      const res = this.jsonContains(this.parseEval(value, false), this.encode(key2, true, true));
      return notStr ? this.logicalNot(res) : res;
    }
  }
  createRegExpQuery(key2, value) {
    if (typeof value !== "string" && value.flags?.includes("i")) {
      return `${key2} regexp ${this.escape(value.source)}`;
    } else {
      return `${key2} collate utf8mb4_bin regexp ${this.escape(typeof value === "string" ? value : value.source)}`;
    }
  }
  createElementQuery(key2, value) {
    if (this.isJsonQuery(key2)) {
      return this.jsonContains(key2, this.encode(value, true, true));
    } else {
      return `find_in_set(${this.escape(value)}, ${key2})`;
    }
  }
  isJsonQuery(key2) {
    return Type.fromTerm(this.state.expr)?.type === "json" || this.isEncoded(key2);
  }
  comparator(operator) {
    return (key2, value) => {
      return `${key2} ${operator} ${this.escape(value)}`;
    };
  }
  binary(operator) {
    return ([left, right]) => {
      return `(${this.parseEval(left)} ${operator} ${this.parseEval(right)})`;
    };
  }
  logicalAnd(conditions) {
    if (!conditions.length) return this.$true;
    if (conditions.includes(this.$false)) return this.$false;
    return conditions.join(" AND ");
  }
  logicalOr(conditions) {
    if (!conditions.length) return this.$false;
    if (conditions.includes(this.$true)) return this.$true;
    return `(${conditions.join(" OR ")})`;
  }
  logicalNot(condition) {
    return `NOT(${condition})`;
  }
  parseSelection(sel, inline = false) {
    const { args: [expr], ref: ref2, table, tables } = sel;
    const restore = this.saveState({ tables });
    const inner = this.get(table, true, true);
    const output2 = this.parseEval(expr, false);
    const fields = expr["$select"]?.map((x) => this.getRecursive(x["$"]));
    const where = fields && this.logicalAnd(fields.map((x) => `(${x} is not null)`));
    restore();
    if (inline || !isAggrExpr(expr)) {
      return `(SELECT ${output2} FROM ${inner} ${isBracketed(inner) ? ref2 : ""}${where ? ` WHERE ${where}` : ""})`;
    } else {
      return [
        `(ifnull((SELECT ${this.groupArray(this.transform(output2, Type.getInner(Type.fromTerm(expr)), "encode"))}`,
        `FROM ${inner} ${isBracketed(inner) ? ref2 : ""}), json_array()))`
      ].join(" ");
    }
  }
  jsonLength(value) {
    return this.asEncoded(`json_length(${value})`, false);
  }
  jsonContains(obj, value) {
    return this.asEncoded(`json_contains(${obj}, ${value})`, false);
  }
  asEncoded(value, encoded) {
    if (encoded !== void 0) this.state.encoded = encoded;
    return value;
  }
  encode(value, encoded, pure = false, type2) {
    return this.asEncoded(encoded === this.isEncoded() && !pure ? value : encoded ? `cast(${this.transform(value, type2, "encode")} as json)` : this.transform(`json_unquote(${value})`, type2, "decode"), pure ? void 0 : encoded);
  }
  isEncoded(key2) {
    return key2 ? this.state.encodedMap?.[key2] : this.state.encoded;
  }
  createAggr(expr, aggr, nonaggr) {
    if (this.state.group) {
      this.state.group = false;
      const value = aggr(this.parseEval(expr, false));
      this.state.group = true;
      return value;
    } else {
      const value = this.parseEval(expr, false);
      const res = nonaggr ? nonaggr(value) : `(select ${aggr(`json_unquote(${this.escapeId("value")})`)} from json_table(${value}, '$[*]' columns (value json path '$')) ${randomId()})`;
      return res;
    }
  }
  /**
   * Convert value from SQL field to JSON field
   */
  transform(value, type2, method, miss) {
    type2 = Type.isType(type2) ? type2 : Type.fromTerm(type2);
    const transformer = this.transformers[type2.type] ?? this.transformers[this.driver.database.types[type2.type]?.type];
    return transformer?.[method] ? transformer[method](value) : miss ?? value;
  }
  groupObject(_fields) {
    const _groupObject = /* @__PURE__ */ __name$1((fields, type2, prefix = "") => {
      const parse3 = /* @__PURE__ */ __name$1((expr, key2) => {
        const value = !_fields[`${prefix}${key2}`] && type2 && Type.getInner(type2, key2)?.inner ? _groupObject(expr, Type.getInner(type2, key2), `${prefix}${key2}.`) : this.parseEval(expr, false);
        return this.isEncoded() ? `json_extract(${value}, '$')` : this.transform(value, expr, "encode");
      }, "parse");
      return `json_object(` + Object.entries(fields).map(([key2, expr]) => `'${key2}', ${parse3(expr, key2)}`).join(",") + `)`;
    }, "_groupObject");
    return this.asEncoded(_groupObject(unravel(_fields), Type.fromTerm(this.state.expr), ""), true);
  }
  groupArray(value) {
    return this.asEncoded(`ifnull(json_arrayagg(${value}), json_array())`, true);
  }
  parseFieldQuery(key2, query) {
    const conditions = [];
    if (Array.isArray(query)) {
      conditions.push(this.createMemberQuery(key2, query));
    } else if (query instanceof RegExp) {
      conditions.push(this.createRegExpQuery(key2, query));
    } else if (isComparable(query)) {
      conditions.push(this.createEqualQuery(key2, query));
    } else if (isNullable(query)) {
      conditions.push(this.createNullQuery(key2, false));
    } else {
      for (const prop in query) {
        if (prop in this.queryOperators) {
          conditions.push(this.queryOperators[prop](key2, query[prop]));
        }
      }
    }
    return this.logicalAnd(conditions);
  }
  parseQuery(query) {
    const conditions = [];
    for (const key2 in query) {
      if (key2 === "$not") {
        conditions.push(this.logicalNot(this.parseQuery(query.$not)));
      } else if (key2 === "$and") {
        conditions.push(this.logicalAnd(query.$and.map(this.parseQuery.bind(this))));
      } else if (key2 === "$or") {
        conditions.push(this.logicalOr(query.$or.map(this.parseQuery.bind(this))));
      } else if (key2 === "$expr") {
        conditions.push(this.parseEval(query.$expr));
      } else {
        const flattenQuery = isFlat(query[key2]) ? { [key2]: query[key2] } : flatten(query[key2], `${key2}.`);
        for (const key22 in flattenQuery) {
          const model = this.state.tables[this.state.table] ?? Object.values(this.state.tables)[0];
          const expr = Eval3("", [this.state.table ?? Object.keys(this.state.tables)[0], key22], model.getType(key22));
          conditions.push(this.parseFieldQuery(this.parseEval(expr), flattenQuery[key22]));
        }
      }
    }
    return this.logicalAnd(conditions);
  }
  parseEvalExpr(expr) {
    this.state.encoded = false;
    for (const key2 in expr) {
      if (key2 in this.evalOperators) {
        this.state.expr = expr;
        return this.evalOperators[key2](expr[key2]);
      }
    }
    return this.escape(expr);
  }
  transformJsonField(obj, path2) {
    return this.asEncoded(`json_extract(${obj}, '$${path2}')`, true);
  }
  transformKey(key2, fields, prefix) {
    if (key2 in fields || !key2.includes(".")) {
      return this.asEncoded(prefix + this.escapeId(key2), this.isEncoded(key2) ?? isSqlJson(fields[key2]?.type));
    }
    const field = Object.keys(fields).find((k) => key2.startsWith(k + ".")) || key2.split(".")[0];
    const rest = key2.slice(field.length + 1).split(".");
    return this.transformJsonField(`${prefix}${this.escapeId(field)}`, rest.map((key22) => `.${this.escapeKey(key22)}`).join(""));
  }
  getRecursive(args) {
    if (typeof args === "string") {
      return this.getRecursive(["_", args]);
    }
    const [table, key2] = args;
    const fields = this.state.tables?.[table]?.fields || {};
    const fkey = Object.keys(fields).find((field) => key2 === field || key2.startsWith(field + "."));
    if (fkey && fields[fkey]?.expr) {
      if (key2 === fkey) {
        return this.parseEvalExpr(fields[fkey]?.expr);
      } else {
        const field = this.parseEvalExpr(fields[fkey]?.expr);
        const rest = key2.slice(fkey.length + 1).split(".");
        return this.transformJsonField(`${field}`, rest.map((key22) => `.${this.escapeKey(key22)}`).join(""));
      }
    }
    const prefix = this.modifiedTable ? `${this.escapeId(this.state.tables?.[table]?.name ?? this.modifiedTable)}.` : !this.state.tables || table === "_" || key2 in fields || table in this.state.tables ? "" : `${this.escapeId(table)}.`;
    if (!(table in (this.state.tables || {})) && table in (this.state.innerTables || {})) {
      const fields2 = this.state.innerTables?.[table]?.fields || {};
      const res = fields2[key2]?.expr ? this.parseEvalExpr(fields2[key2]?.expr) : this.transformKey(key2, fields2, `${this.escapeId(table)}.`);
      return res;
    }
    if (!(table in (this.state.tables || {})) && table in (this.state.refTables || {})) {
      const fields2 = this.state.refTables?.[table]?.fields || {};
      const res = fields2[key2]?.expr ? this.parseEvalExpr(fields2[key2]?.expr) : this.transformKey(key2, fields2, `${this.escapeId(table)}.`);
      if (this.state.wrappedSubquery) {
        if (res in (this.state.refFields ?? {})) return this.state.refFields[res];
        const key22 = `minato_tvar_${randomId()}`;
        (this.state.refFields ??= {})[res] = key22;
        return this.asEncoded(this.escapeId(key22), true);
      } else return res;
    }
    return this.transformKey(key2, fields, prefix);
  }
  parseEval(expr, unquote = true) {
    this.state.encoded = false;
    if (typeof expr === "string" || typeof expr === "number" || typeof expr === "boolean" || expr instanceof Date || expr instanceof RegExp) {
      return this.escape(expr);
    }
    return unquote ? this.encode(this.parseEvalExpr(expr), false, false, Type.fromTerm(expr)) : this.parseEvalExpr(expr);
  }
  saveState(extra = {}) {
    const thisState = this.state;
    this.state = { refTables: { ...this.state.refTables || {}, ...this.state.tables || {} }, ...extra };
    return () => {
      thisState.encoded = this.state.encoded;
      this.state = thisState;
    };
  }
  suffix(modifier) {
    const { limit, offset, sort, group, having } = modifier;
    let sql = "";
    if (group?.length) {
      sql += ` GROUP BY ${group.map(this.escapeId).join(", ")}`;
      const filter = this.parseEval(having);
      if (filter !== this.$true) sql += ` HAVING ${filter}`;
    }
    if (sort.length) {
      sql += " ORDER BY " + sort.map(([expr, dir]) => {
        return `${this.parseEval(expr)} ${dir.toUpperCase()}`;
      }).join(", ");
    }
    if (limit < Infinity) sql += " LIMIT " + limit;
    if (offset > 0) sql += " OFFSET " + offset;
    return sql;
  }
  get(sel, inline = false, group = false, addref = true) {
    const { args, table, query, ref: ref2, model } = sel;
    this.state.table = ref2;
    let prefix;
    if (typeof table === "string") {
      prefix = this.escapeId(table);
    } else if (Selection.is(table)) {
      prefix = this.get(table, true);
      if (!prefix) return;
    } else {
      this.state.innerTables = Object.fromEntries(Object.values(table).map((t) => [t.ref, t.model]));
      const joins = Object.entries(table).map(([key2, table2]) => {
        const restore = this.saveState({ tables: { ...table2.tables } });
        const t = `${this.get(table2, true, false, false)} AS ${this.escapeId(table2.ref)}`;
        restore();
        return [key2, t];
      });
      prefix = [
        // the leading space is to prevent from being parsed as bracketed and added ref
        " ",
        joins[0][1],
        ...joins.slice(1, -1).map(([key2, join]) => `${args[0].optional?.[key2] ? "LEFT" : ""} JOIN ${join} ON ${this.$true}`),
        `${args[0].optional?.[joins.at(-1)[0]] ? "LEFT " : ""}JOIN`,
        joins.at(-1)[1]
      ].join(" ");
      const filter2 = this.parseEval(args[0].having);
      prefix += ` ON ${filter2}`;
    }
    const filter = this.parseQuery(query);
    if (filter === this.$false) return;
    this.state.group = group || !!args[0].group;
    const encodedMap = {};
    const fields = args[0].fields ?? Object.fromEntries(Object.entries(model.fields).filter(([, field]) => Field$1.available(field)).map(([key2, field]) => [key2, field.expr ? field.expr : Eval3("", [ref2, key2], Type.fromField(field))]));
    const keys = Object.entries(fields).map(([key2, value]) => {
      value = this.parseEval(value, false);
      encodedMap[key2] = this.state.encoded;
      return this.escapeId(key2) === value ? this.escapeId(key2) : `${value} AS ${this.escapeId(key2)}`;
    }).join(", ");
    let suffix = this.suffix(args[0]);
    this.state.encodedMap = encodedMap;
    if (filter !== this.$true) {
      suffix = ` WHERE ${filter}` + suffix;
    }
    if (inline && !args[0].fields && !suffix && (typeof table === "string" || Selection.is(table))) {
      return addref && isBracketed(prefix) ? `${prefix} ${ref2}` : prefix;
    }
    if (!prefix.includes(" ") || isBracketed(prefix)) {
      suffix = ` ${ref2}` + suffix;
    }
    const result = `SELECT ${keys} FROM ${prefix}${suffix}`;
    return inline ? `(${result})` : result;
  }
  /**
   * Convert value from Type to Field.Type.
   * @param root indicate whether the context is inside json
   */
  dump(value, type2, root2 = true) {
    if (!type2) return value;
    if (Type.isType(type2) || isEvalExpr(type2)) {
      type2 = Type.isType(type2) ? type2 : Type.fromTerm(type2);
      const converter = type2.inner || type2.type === "json" ? root2 ? this.driver.types["json"] : void 0 : this.driver.types[type2.type];
      if (type2.inner || type2.type === "json") root2 = false;
      let res = value;
      res = Type.transform(res, type2, (value2, type22) => this.dump(value2, type22, root2));
      res = converter?.dump ? converter.dump(res) : res;
      const ancestor = this.driver.database.types[type2.type]?.type;
      if (!root2 && !ancestor) res = this.transform(res, type2, "dump");
      res = this.dump(res, ancestor ? Type.fromField(ancestor) : void 0, root2);
      return res;
    }
    value = type2.format(value);
    const result = {};
    for (const key2 in value) {
      const { type: ftype } = type2.fields[key2];
      result[key2] = this.dump(value[key2], ftype);
    }
    return result;
  }
  /**
   * Convert value from Field.Type to Type.
   */
  load(value, type2, root2 = true) {
    if (!type2) return value;
    if (Type.isType(type2) || isEvalExpr(type2)) {
      type2 = Type.isType(type2) ? type2 : Type.fromTerm(type2);
      const converter = this.driver.types[root2 && value && type2.type === "json" ? "json" : type2.type];
      const ancestor = this.driver.database.types[type2.type]?.type;
      let res = this.load(value, ancestor ? Type.fromField(ancestor) : void 0, root2);
      res = this.transform(res, type2, "load");
      res = converter?.load ? converter.load(res) : res;
      res = Type.transform(res, type2, (value2, type22) => this.load(value2, type22, false));
      return !isNullable(res) && type2.inner && !Type.isArray(type2) ? unravel(res) : res;
    }
    const result = {};
    for (const key2 in value) {
      if (!(key2 in type2.fields)) continue;
      result[key2] = value[key2];
      let subroot = root2;
      if (subroot && result[key2] && this.isEncoded(key2)) {
        subroot = false;
        result[key2] = this.driver.types["json"].load(result[key2]);
      }
      result[key2] = this.load(result[key2], type2.fields[key2].type, subroot);
    }
    return type2.parse(result);
  }
  /**
   * Convert value from Type to SQL.
   */
  escape(value, type2) {
    type2 &&= Type.fromField(type2);
    return this.escapePrimitive(type2 ? this.dump(value, type2) : value, type2);
  }
  /**
   * Convert value from Field.Type to SQL.
   */
  escapePrimitive(value, type2) {
    if (isNullable(value)) return "NULL";
    switch (typeof value) {
      case "boolean":
      case "number":
      case "bigint":
        return value + "";
      case "object":
        return this.quote(JSON.stringify(value));
      default:
        return this.quote(value);
    }
  }
  escapeId(value) {
    return escapeId(value);
  }
  escapeKey(value) {
    return `"${value}"`;
  }
  quote(value) {
    this.escapeRegExp ??= new RegExp(`[${Object.values(this.escapeMap).join("")}]`, "g");
    let chunkIndex = this.escapeRegExp.lastIndex = 0;
    let escapedVal = "";
    let match;
    while (match = this.escapeRegExp.exec(value)) {
      escapedVal += value.slice(chunkIndex, match.index) + this.escapeMap[match[0]];
      chunkIndex = this.escapeRegExp.lastIndex;
    }
    if (chunkIndex === 0) {
      return "'" + value + "'";
    }
    if (chunkIndex < value.length) {
      return "'" + escapedVal + value.slice(chunkIndex) + "'";
    }
    return "'" + escapedVal + "'";
  }
};
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var en_US_default = { path: "Database path." };
var zh_CN_default = { path: "" };
var SQLiteBuilder = class extends Builder {
  constructor(driver, tables) {
    super(driver, tables);
    this.driver = driver;
    this.queryOperators.$regexFor = (key2, value) => typeof value === "string" ? `${this.escape(value)} regexp ${key2}` : value.flags?.includes("i") ? `regexp2(${key2}, ${this.escape(value.input)}, 'i')` : `${this.escape(value.input)} regexp ${key2}`;
    this.evalOperators.$if = (args) => `iif(${args.map((arg) => this.parseEval(arg)).join(", ")})`;
    this.evalOperators.$regex = ([key2, value, flags]) => flags?.includes("i") || value instanceof RegExp && value.flags?.includes("i") ? `regexp2(${this.parseEval(value)}, ${this.parseEval(key2)}, ${this.escape(flags ?? value.flags)})` : `regexp(${this.parseEval(value)}, ${this.parseEval(key2)})`;
    this.evalOperators.$concat = (args) => `(${args.map((arg) => this.parseEval(arg)).join("||")})`;
    this.evalOperators.$modulo = ([left, right]) => `modulo(${this.parseEval(left)}, ${this.parseEval(right)})`;
    this.evalOperators.$log = ([left, right]) => isNullable(right) ? `log(${this.parseEval(left)})` : `log(${this.parseEval(left)}) / log(${this.parseEval(right)})`;
    this.evalOperators.$length = (expr) => this.createAggr(expr, (value) => `count(${value})`, (value) => this.isEncoded() ? this.jsonLength(value) : this.asEncoded(`iif(${value}, LENGTH(${value}) - LENGTH(REPLACE(${value}, ${this.escape(",")}, ${this.escape("")})) + 1, 0)`, false));
    this.evalOperators.$number = (arg) => {
      const type2 = Type.fromTerm(arg);
      const value = this.parseEval(arg);
      const res = Field$1.date.includes(type2.type) ? `cast(${value} / 1000 as integer)` : `cast(${this.parseEval(arg)} as double)`;
      return this.asEncoded(`ifnull(${res}, 0)`, false);
    };
    const binaryXor = /* @__PURE__ */ __name((left, right) => `((${left} & ~${right}) | (~${left} & ${right}))`, "binaryXor");
    this.evalOperators.$xor = (args) => {
      const type2 = Type.fromTerm(this.state.expr, Type.Boolean);
      if (Field$1.boolean.includes(type2.type)) return args.map((arg) => this.parseEval(arg)).reduce((prev, curr) => `(${prev} != ${curr})`);
      else return args.map((arg) => this.parseEval(arg)).reduce((prev, curr) => binaryXor(prev, curr));
    };
    this.evalOperators.$get = ([x, key2]) => typeof key2 === "string" ? this.asEncoded(`(${this.parseEval(x, false)} -> '$.${key2}')`, true) : this.asEncoded(`(${this.parseEval(x, false)} -> ('$[' || ${this.parseEval(key2)} || ']'))`, true);
    this.transformers["bigint"] = {
      encode: /* @__PURE__ */ __name((value) => `cast(${value} as text)`, "encode"),
      decode: /* @__PURE__ */ __name((value) => `cast(${value} as integer)`, "decode"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) ? value : BigInt(value), "load"),
      dump: /* @__PURE__ */ __name((value) => isNullable(value) ? value : `${value}`, "dump")
    };
    this.transformers["binary"] = {
      encode: /* @__PURE__ */ __name((value) => `hex(${value})`, "encode"),
      decode: /* @__PURE__ */ __name((value) => `unhex(${value})`, "decode"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) || typeof value === "object" ? value : Binary.fromHex(value), "load"),
      dump: /* @__PURE__ */ __name((value) => isNullable(value) || typeof value === "string" ? value : Binary.toHex(value), "dump")
    };
  }
  static {
    __name(this, "SQLiteBuilder");
  }
  escapeMap = {
    "'": "''"
  };
  escapePrimitive(value, type2) {
    if (value instanceof Date) value = +value;
    else if (value instanceof RegExp) value = value.source;
    else if (Binary.is(value)) return `X'${Binary.toHex(value)}'`;
    else if (Binary.isSource(value)) return `X'${Binary.toHex(Binary.fromSource(value))}'`;
    return super.escapePrimitive(value, type2);
  }
  createElementQuery(key2, value) {
    if (this.isJsonQuery(key2)) {
      return this.jsonContains(key2, this.escape(value, "json"));
    } else {
      return `(',' || ${key2} || ',') LIKE ${this.escape("%," + value + ",%")}`;
    }
  }
  createRegExpQuery(key2, value) {
    if (typeof value !== "string" && value.flags?.includes("i")) {
      return `regexp2(${this.escape(typeof value === "string" ? value : value.source)}, ${key2}, ${this.escape(value.flags)})`;
    } else {
      return `regexp(${this.escape(typeof value === "string" ? value : value.source)}, ${key2})`;
    }
  }
  jsonLength(value) {
    return this.asEncoded(`json_array_length(${value})`, false);
  }
  jsonContains(obj, value) {
    return this.asEncoded(`json_array_contains(${obj}, ${value})`, false);
  }
  encode(value, encoded, pure = false, type2) {
    return encoded ? super.encode(value, encoded, pure, type2) : encoded === this.isEncoded() && !pure ? value : this.asEncoded(this.transform(`(${value} ->> '$')`, type2, "decode"), pure ? void 0 : false);
  }
  createAggr(expr, aggr, nonaggr) {
    if (!this.state.group && !nonaggr) {
      const value = this.parseEval(expr, false);
      return `(select ${aggr(escapeId("value"))} from json_each(${value}) ${randomId()})`;
    } else {
      return super.createAggr(expr, aggr, nonaggr);
    }
  }
  groupArray(value) {
    const res = this.isEncoded() ? `('[' || group_concat(${value}) || ']')` : `('[' || group_concat(json_quote(${value})) || ']')`;
    return this.asEncoded(`ifnull(${res}, json_array())`, true);
  }
  transformJsonField(obj, path2) {
    return this.asEncoded(`(${obj} -> '$${path2}')`, true);
  }
};
function getTypeDef({ deftype: type2 }) {
  switch (type2) {
    case "primary":
    case "boolean":
    case "integer":
    case "unsigned":
    case "bigint":
    case "date":
    case "time":
    case "timestamp":
      return `INTEGER`;
    case "float":
    case "double":
    case "decimal":
      return `REAL`;
    case "char":
    case "string":
    case "text":
    case "list":
    case "json":
      return `TEXT`;
    case "binary":
      return `BLOB`;
    default:
      throw new Error(`unsupported type: ${type2}`);
  }
}
__name(getTypeDef, "getTypeDef");
var SQLiteDriver = class extends Driver {
  static name = "sqlite";
  path;
  db;
  sql = new SQLiteBuilder(this);
  beforeUnload;
  _transactionTask;
  /** synchronize table schema */
  async prepare(table, dropKeys) {
    const columns = this._all(`PRAGMA table_info(${escapeId(table)})`);
    const model = this.model(table);
    const columnDefs = [];
    const indexDefs = [];
    const alter = [];
    const mapping = {};
    let shouldMigrate = false;
    for (const key2 in model.fields) {
      if (!Field$1.available(model.fields[key2])) {
        if (dropKeys?.includes(key2)) shouldMigrate = true;
        continue;
      }
      const legacy = [key2, ...model.fields[key2].legacy || []];
      const column2 = columns.find(({ name }) => legacy.includes(name));
      const { initial, nullable = true } = model.fields[key2];
      const typedef = getTypeDef(model.fields[key2]);
      let def = `${escapeId(key2)} ${typedef}`;
      if (key2 === model.primary && model.autoInc) {
        def += " NOT NULL PRIMARY KEY AUTOINCREMENT";
      } else {
        def += (nullable ? " " : " NOT ") + "NULL";
        if (!isNullable(initial)) {
          def += " DEFAULT " + this.sql.escape(this.sql.dump({ [key2]: initial }, model)[key2]);
        }
      }
      columnDefs.push(def);
      if (!column2) {
        alter.push("ADD " + def);
      } else {
        mapping[column2.name] = key2;
        shouldMigrate ||= column2.name !== key2 || column2.type !== typedef;
      }
    }
    if (model.primary && !model.autoInc) {
      indexDefs.push(`PRIMARY KEY (${this._joinKeys(makeArray(model.primary))})`);
    }
    if (model.unique) {
      indexDefs.push(...model.unique.map((keys) => `UNIQUE (${this._joinKeys(makeArray(keys))})`));
    }
    if (model.foreign) {
      indexDefs.push(...Object.entries(model.foreign).map(([key2, value]) => {
        const [table2, key22] = value;
        return `FOREIGN KEY (\`${key2}\`) REFERENCES ${escapeId(table2)} (\`${key22}\`)`;
      }));
    }
    if (!columns.length) {
      this.logger.info("auto creating table %c", table);
      this._run(`CREATE TABLE ${escapeId(table)} (${[...columnDefs, ...indexDefs].join(", ")})`);
    } else if (shouldMigrate) {
      for (const { name, type: type2, notnull, pk, dflt_value: value } of columns) {
        if (mapping[name] || dropKeys?.includes(name)) continue;
        let def = `${escapeId(name)} ${type2}`;
        def += (notnull ? " NOT " : " ") + "NULL";
        if (pk) def += " PRIMARY KEY";
        if (value !== null) def += " DEFAULT " + this.sql.escape(value);
        columnDefs.push(def);
        mapping[name] = name;
      }
      const temp = table + "_temp";
      const fields = Object.keys(mapping).map(escapeId).join(", ");
      this.logger.info("auto migrating table %c", table);
      this._run(`CREATE TABLE ${escapeId(temp)} (${[...columnDefs, ...indexDefs].join(", ")})`);
      try {
        this._run(`INSERT INTO ${escapeId(temp)} SELECT ${fields} FROM ${escapeId(table)}`);
        this._run(`DROP TABLE ${escapeId(table)}`);
      } catch (error) {
        this._run(`DROP TABLE ${escapeId(temp)}`);
        throw error;
      }
      this._run(`ALTER TABLE ${escapeId(temp)} RENAME TO ${escapeId(table)}`);
    } else if (alter.length) {
      this.logger.info("auto updating table %c", table);
      for (const def of alter) {
        this._run(`ALTER TABLE ${escapeId(table)} ${def}`);
      }
    }
    if (dropKeys) return;
    dropKeys = [];
    await this.migrate(table, {
      error: this.logger.warn,
      before: /* @__PURE__ */ __name((keys) => keys.every((key2) => columns.some(({ name }) => name === key2)), "before"),
      after: /* @__PURE__ */ __name((keys) => dropKeys.push(...keys), "after"),
      finalize: /* @__PURE__ */ __name(() => {
        if (!dropKeys.length) return;
        this.prepare(table, dropKeys);
      }, "finalize")
    });
  }
  async start() {
    this.path = this.config.path;
    if (this.path !== ":memory:") {
      this.path = resolve(this.ctx.baseDir, this.path);
    }
    const isBrowser = process.env.KOISHI_ENV === "browser";
    const sqlite = await init({
      locateFile: /* @__PURE__ */ __name((file) => process.env.KOISHI_BASE ? process.env.KOISHI_BASE + "/" + file : isBrowser ? "/modules/@koishijs/plugin-database-sqlite/" + file : createRequire(import.meta.url || pathToFileURL(__filename).href).resolve("@minatojs/sql.js/dist/" + file), "locateFile")
    });
    if (this.path !== ":memory:") {
      const dir = resolve(this.path, "..");
      try {
        await access(dir);
      } catch {
        throw new Error(`The database directory '${resolve(this.path, "..")}' is not accessible. You may have to create it first.`);
      }
    }
    if (!isBrowser || this.path === ":memory:") {
      this.db = new sqlite.Database(this.path);
    } else {
      const buffer2 = await readFile(this.path).catch(() => null);
      this.db = new sqlite.Database(this.path, buffer2);
      if (isBrowser) {
        window.addEventListener("beforeunload", this.beforeUnload = () => {
          this._export();
        });
      }
    }
    this.db.create_function("regexp", (pattern2, str) => +new RegExp(pattern2).test(str));
    this.db.create_function("regexp2", (pattern2, str, flags) => +new RegExp(pattern2, flags).test(str));
    this.db.create_function("json_array_contains", (array, value) => +JSON.parse(array).includes(JSON.parse(value)));
    this.db.create_function("modulo", (left, right) => left % right);
    this.db.create_function("rand", () => Math.random());
    this.define({
      types: ["boolean"],
      dump: /* @__PURE__ */ __name((value) => isNullable(value) ? value : +value, "dump"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) ? value : !!value, "load")
    });
    this.define({
      types: ["json"],
      dump: /* @__PURE__ */ __name((value) => JSON.stringify(value), "dump"),
      load: /* @__PURE__ */ __name((value) => typeof value === "string" ? JSON.parse(value) : value, "load")
    });
    this.define({
      types: ["list"],
      dump: /* @__PURE__ */ __name((value) => Array.isArray(value) ? value.join(",") : value, "dump"),
      load: /* @__PURE__ */ __name((value) => value ? value.split(",") : [], "load")
    });
    this.define({
      types: ["date", "time", "timestamp"],
      dump: /* @__PURE__ */ __name((value) => isNullable(value) ? value : +new Date(value), "dump"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) ? value : new Date(Number(value)), "load")
    });
    this.define({
      types: ["binary"],
      dump: /* @__PURE__ */ __name((value) => isNullable(value) ? value : new Uint8Array(value), "dump"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) ? value : Binary.fromSource(value), "load")
    });
    this.define({
      types: ["primary", ...Field$1.number],
      dump: /* @__PURE__ */ __name((value) => value, "dump"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) ? value : Number(value), "load")
    });
  }
  _joinKeys(keys) {
    return keys?.length ? keys.map((key2) => `\`${key2}\``).join(", ") : "*";
  }
  async stop() {
    await new Promise((resolve2) => setTimeout(resolve2, 0));
    this.db?.close();
    if (this.beforeUnload) {
      this.beforeUnload();
      window.removeEventListener("beforeunload", this.beforeUnload);
    }
  }
  _exec(sql, params, callback) {
    try {
      const stmt = this.db.prepare(sql);
      const result = callback(stmt);
      stmt.free();
      this.logger.debug("> %s", sql, params);
      return result;
    } catch (e) {
      this.logger.warn("> %s", sql, params);
      throw e;
    }
  }
  _all(sql, params = [], config) {
    return this._exec(sql, params, (stmt) => {
      stmt.bind(params);
      const result = [];
      while (stmt.step()) {
        result.push(stmt.getAsObject(null, config));
      }
      return result;
    });
  }
  _get(sql, params = [], config) {
    return this._exec(sql, params, (stmt) => stmt.getAsObject(params, config));
  }
  _export() {
    const data = this.db.export();
    return writeFile(this.path, data);
  }
  _run(sql, params = [], callback) {
    this._exec(sql, params, (stmt) => stmt.run(params));
    const result = callback?.();
    return result;
  }
  async drop(table) {
    this._run(`DROP TABLE ${escapeId(table)}`);
  }
  async dropAll() {
    const tables = Object.keys(this.database.tables);
    for (const table of tables) {
      this._run(`DROP TABLE ${escapeId(table)}`);
    }
  }
  async stats() {
    const stats = { size: this.db.size(), tables: {} };
    const tableNames = this._all('SELECT name FROM sqlite_master WHERE type="table" ORDER BY name;');
    const dbstats = this._all('SELECT name, pgsize as size FROM "dbstat" WHERE aggregate=TRUE;');
    tableNames.forEach((tbl) => {
      stats.tables[tbl.name] = this._get(`SELECT COUNT(*) as count FROM ${escapeId(tbl.name)};`);
      stats.tables[tbl.name].size = dbstats.find((o) => o.name === tbl.name).size;
    });
    return stats;
  }
  async remove(sel) {
    const { query, table, tables } = sel;
    const builder = new SQLiteBuilder(this, tables);
    const filter = builder.parseQuery(query);
    if (filter === "0") return {};
    const result = this._run(`DELETE FROM ${escapeId(table)} WHERE ${filter}`, [], () => this._get(`SELECT changes() AS count`));
    return { matched: result.count, removed: result.count };
  }
  async get(sel) {
    const { model, tables } = sel;
    const builder = new SQLiteBuilder(this, tables);
    const sql = builder.get(sel);
    if (!sql) return [];
    const rows = this._all(sql, [], { useBigInt: true });
    return rows.map((row) => builder.load(row, model));
  }
  async eval(sel, expr) {
    const builder = new SQLiteBuilder(this, sel.tables);
    const inner = builder.get(sel.table, true, true);
    const output2 = builder.parseEval(expr, false);
    const { value } = this._get(`SELECT ${output2} AS value FROM ${inner}`, [], { useBigInt: true });
    return builder.load(value, expr);
  }
  _update(sel, indexFields, updateFields, update, data) {
    const { ref: ref2, table, tables, model } = sel;
    const builder = new SQLiteBuilder(this, tables);
    executeUpdate(data, update, ref2);
    const row = builder.dump(data, model);
    const assignment = updateFields.map((key2) => `${escapeId(key2)} = ?`).join(",");
    const query = Object.fromEntries(indexFields.map((key2) => [key2, row[key2]]));
    const filter = builder.parseQuery(query);
    this._run(`UPDATE ${escapeId(table)} SET ${assignment} WHERE ${filter}`, updateFields.map((key2) => row[key2] ?? null));
  }
  async set(sel, update) {
    const { model, table, query } = sel;
    const { primary } = model, fields = model.avaiableFields();
    const updateFields = [...new Set(Object.keys(update).map((key2) => {
      return Object.keys(fields).find((field) => field === key2 || key2.startsWith(field + "."));
    }))];
    const primaryFields = makeArray(primary);
    if (query.$expr || hasSubquery(sel.query) || Object.values(update).some((x) => hasSubquery(x))) {
      const sel2 = this.database.select(table, query);
      sel2.tables[sel.ref] = sel2.tables[sel2.ref];
      delete sel2.tables[sel2.ref];
      sel2.ref = sel.ref;
      const project = mapValues(update, (value, key2) => () => isEvalExpr(value) ? value : Eval3.literal(value, model.getType(key2)));
      const rawUpsert = await sel2.project({
        ...project,
        // do not touch sel2.row since it is not patched
        ...Object.fromEntries(primaryFields.map((x) => [x, () => Eval3("", [sel.ref, x], sel2.model.getType(x))]))
      }).execute();
      const upsert = rawUpsert.map((row) => ({
        ...mapValues(update, (_, key2) => getCell(row, key2)),
        ...Object.fromEntries(primaryFields.map((x) => [x, getCell(row, x)]))
      }));
      return this.database.upsert(table, upsert);
    } else {
      const data = await this.database.get(table, query);
      for (const row of data) {
        this._update(sel, primaryFields, updateFields, update, row);
      }
      return { matched: data.length };
    }
  }
  _create(table, data) {
    const model = this.model(table);
    data = this.sql.dump(data, model);
    const keys = Object.keys(data);
    const sql = `INSERT INTO ${escapeId(table)} (${this._joinKeys(keys)}) VALUES (${Array(keys.length).fill("?").join(", ")})`;
    return this._run(sql, keys.map((key2) => data[key2] ?? null), () => this._get(`SELECT last_insert_rowid() AS id`));
  }
  async create(sel, data) {
    const { model, table } = sel;
    const { id } = this._create(table, data);
    const { autoInc, primary } = model;
    if (!autoInc || Array.isArray(primary)) return data;
    return { ...data, [primary]: id };
  }
  async upsert(sel, data, keys) {
    if (!data.length) return {};
    const { model, table, ref: ref2 } = sel;
    const fields = model.avaiableFields();
    const result = { inserted: 0, matched: 0, modified: 0 };
    const dataFields = [...new Set(Object.keys(Object.assign({}, ...data)).map((key2) => {
      return Object.keys(fields).find((field) => field === key2 || key2.startsWith(field + "."));
    }))];
    let updateFields = difference(dataFields, keys);
    if (!updateFields.length) updateFields = [dataFields[0]];
    const step = Math.floor(960 / keys.length);
    for (let i = 0; i < data.length; i += step) {
      const chunk = data.slice(i, i + step);
      const results = await this.database.get(table, {
        $or: chunk.map((item) => Object.fromEntries(keys.map((key2) => [key2, item[key2]])))
      });
      for (const item of chunk) {
        const row = results.find((row2) => {
          row2 = model.format(row2);
          return keys.every((key2) => deepEqual(row2[key2], item[key2], true));
        });
        if (row) {
          this._update(sel, keys, updateFields, item, row);
          result.matched++;
        } else {
          this._create(table, executeUpdate(model.create(), item, ref2));
          result.inserted++;
        }
      }
    }
    return result;
  }
  async withTransaction(callback) {
    if (this._transactionTask) await this._transactionTask.catch(() => {
    });
    return this._transactionTask = new Promise((resolve2, reject) => {
      this._run("BEGIN TRANSACTION");
      callback().then(
        () => resolve2(this._run("COMMIT")),
        (e) => (this._run("ROLLBACK"), reject(e))
      );
    });
  }
  async getIndexes(table) {
    const indexes = this._all(`SELECT type,name,tbl_name,sql FROM sqlite_master WHERE type = 'index' AND tbl_name = ?`, [table]);
    const result = [];
    for (const { name, sql } of indexes) {
      result.push({
        name,
        unique: !sql || sql.toUpperCase().startsWith("CREATE UNIQUE"),
        keys: this._parseIndexDef(sql)
      });
    }
    return result;
  }
  async createIndex(table, index) {
    const name = index.name ?? Object.entries(index.keys).map(([key2, direction]) => `${key2}_${direction ?? "asc"}`).join("+");
    const keyFields = Object.entries(index.keys).map(([key2, direction]) => `${escapeId(key2)} ${direction ?? "asc"}`).join(", ");
    await this._run(`create ${index.unique ? "UNIQUE" : ""} index ${escapeId(name)} ON ${escapeId(table)} (${keyFields})`);
  }
  async dropIndex(table, name) {
    await this._run(`DROP INDEX ${escapeId(name)}`);
  }
  _parseIndexDef(def) {
    if (!def) return {};
    try {
      const keys = {}, matches = def.match(/\((.*)\)/);
      matches[1].split(",").forEach((key2) => {
        const [name, direction] = key2.trim().split(" ");
        keys[name.startsWith("`") ? name.slice(1, -1) : name] = direction?.toLowerCase() === "desc" ? "desc" : "asc";
      });
      return keys;
    } catch {
      return {};
    }
  }
};
((SQLiteDriver2) => {
  SQLiteDriver2.Config = z.object({
    path: z.string().role("path").required()
  }).i18n({
    "en-US": en_US_default,
    "zh-CN": zh_CN_default
  });
})(SQLiteDriver || (SQLiteDriver = {}));
var src_default = SQLiteDriver;
class BidiMap {
  key2Value = /* @__PURE__ */ new Map();
  value2Key = /* @__PURE__ */ new Map();
  maxSize;
  constructor(maxSize) {
    this.maxSize = maxSize;
  }
  set(key2, value) {
    this.key2Value.set(key2, value);
    this.value2Key.set(value, key2);
    if (this.maxSize !== -1 && this.key2Value.size > this.maxSize) {
      const oldestKey = this.key2Value.keys().next().value;
      this.value2Key.delete(this.key2Value.get(oldestKey));
      this.key2Value.delete(oldestKey);
    }
  }
  get(key2) {
    return this.key2Value.get(key2);
  }
  getValue(key2) {
    return this.key2Value.get(key2);
  }
  getKey(value) {
    return this.value2Key.get(value);
  }
}
class Store extends Service2 {
  constructor(ctx, config) {
    super(ctx, "store", true);
    this.ctx = ctx;
    this.config = config;
    this.cache = new BidiMap(1e3);
    this.messages = /* @__PURE__ */ new Map();
    this.initDatabase().then().catch(console.error);
  }
  static inject = ["database", "model", "logger"];
  cache;
  messages;
  async initDatabase() {
    this.ctx.model.extend("message", {
      shortId: "integer(10)",
      chatType: "unsigned",
      msgId: "string(24)",
      peerUid: "string(24)"
    }, {
      primary: "shortId"
    });
    this.ctx.model.extend("file_v2", {
      fileName: "string",
      fileSize: "string",
      fileUuid: "string(128)",
      msgId: "string(24)",
      msgTime: "unsigned(10)",
      peerUid: "string(24)",
      chatType: "unsigned",
      elementId: "string(24)",
      elementType: "unsigned"
    }, {
      primary: "fileUuid",
      indexes: ["fileName"]
    });
    this.ctx.model.extend("forward", {
      rootMsgId: "string(24)",
      parentMsgId: "string(24)",
      peerUid: "string(24)"
    }, {
      primary: "parentMsgId"
    });
  }
  createMsgShortId(peer, msgId) {
    const cacheKey = `${msgId}|${peer.chatType}|${peer.peerUid}`;
    const existingShortId = this.getShortIdByMsgInfo(peer, msgId);
    if (existingShortId) {
      return existingShortId;
    }
    const hash = createHash("md5").update(cacheKey).digest();
    hash[0] &= 127;
    const shortId = hash.readInt32BE();
    this.cache.set(cacheKey, shortId);
    this.ctx.database.upsert("message", [{
      msgId,
      shortId,
      chatType: peer.chatType,
      peerUid: peer.peerUid
    }], "shortId").then().catch((e) => this.ctx.logger.error("createMsgShortId database error:", e));
    return shortId;
  }
  async getMsgInfoByShortId(shortId) {
    const data = this.cache.getKey(shortId);
    if (data) {
      const [msgId, chatTypeStr, peerUid] = data.split("|");
      return {
        msgId,
        peer: {
          chatType: +chatTypeStr,
          peerUid,
          guildId: ""
        }
      };
    }
    const items = await this.ctx.database.get("message", { shortId });
    if (items?.length) {
      const { msgId, chatType, peerUid } = items[0];
      return {
        msgId,
        peer: {
          chatType,
          peerUid,
          guildId: ""
        }
      };
    }
  }
  async getShortIdByMsgId(msgId) {
    return (await this.ctx.database.get("message", { msgId }))[0]?.shortId;
  }
  getShortIdByMsgInfo(peer, msgId) {
    const cacheKey = `${msgId}|${peer.chatType}|${peer.peerUid}`;
    return this.cache.getValue(cacheKey);
  }
  async addFileCache(data) {
    const existingFile = await this.ctx.database.get("file_v2", { fileUuid: data.fileUuid });
    if (existingFile.length) {
      return existingFile;
    }
    this.ctx.database.upsert("file_v2", [data], "fileUuid").then().catch((e) => this.ctx.logger.error("addFileCache database error:", e));
  }
  getFileCacheByName(fileName) {
    return this.ctx.database.get("file_v2", { fileName }, {
      sort: { msgTime: "desc" }
    });
  }
  getFileCacheById(fileUuid) {
    return this.ctx.database.get("file_v2", { fileUuid });
  }
  async addMsgCache(msg) {
    const expire = this.config.msgCacheExpire;
    if (expire === 0) {
      return;
    }
    const id = msg.msgId;
    this.messages.set(id, msg);
    if (this.messages.size > 1e4) {
      const firstKey = this.messages.keys().next().value;
      if (firstKey) {
        this.messages.delete(firstKey);
      }
    }
    setTimeout(() => {
      this.messages.delete(id);
    }, expire);
  }
  getMsgCache(msgId) {
    return this.messages.get(msgId);
  }
  addMultiMsgInfo(rootMsgId, parentMsgId, peerUid) {
    this.ctx.database.upsert("forward", [{ rootMsgId, parentMsgId, peerUid }]).then().catch((e) => this.ctx.logger.error("addMultiMsgInfo database error:", e));
  }
  getMultiMsgInfo(parentMsgId) {
    return this.ctx.database.get("forward", { parentMsgId });
  }
}
var NTMethod = /* @__PURE__ */ ((NTMethod2) => {
  NTMethod2["ACTIVE_CHAT_PREVIEW"] = "nodeIKernelMsgService/getAioFirstViewLatestMsgsAndAddActiveChat";
  NTMethod2["ACTIVE_CHAT_HISTORY"] = "nodeIKernelMsgService/getMsgsIncludeSelfAndAddActiveChat";
  NTMethod2["HISTORY_MSG"] = "nodeIKernelMsgService/getMsgsIncludeSelf";
  NTMethod2["GET_MULTI_MSG"] = "nodeIKernelMsgService/getMultiMsg";
  NTMethod2["DELETE_ACTIVE_CHAT"] = "nodeIKernelMsgService/deleteActiveChatByUid";
  NTMethod2["MEDIA_FILE_PATH"] = "nodeIKernelMsgService/getRichMediaFilePathForGuild";
  NTMethod2["RECALL_MSG"] = "nodeIKernelMsgService/recallMsg";
  NTMethod2["EMOJI_LIKE"] = "nodeIKernelMsgService/setMsgEmojiLikes";
  NTMethod2["GROUP_MEMBER_SCENE"] = "nodeIKernelGroupService/createMemberListScene";
  NTMethod2["GROUP_MEMBERS"] = "nodeIKernelGroupService/getAllMemberList";
  NTMethod2["HANDLE_GROUP_REQUEST"] = "nodeIKernelGroupService/operateSysNotify";
  NTMethod2["QUIT_GROUP"] = "nodeIKernelGroupService/quitGroup";
  NTMethod2["GROUP_AT_ALL_REMAIN_COUNT"] = "nodeIKernelGroupService/getGroupRemainAtTimes";
  NTMethod2["KICK_MEMBER"] = "nodeIKernelGroupService/kickMember";
  NTMethod2["MUTE_MEMBER"] = "nodeIKernelGroupService/setMemberShutUp";
  NTMethod2["MUTE_GROUP"] = "nodeIKernelGroupService/setGroupShutUp";
  NTMethod2["SET_MEMBER_CARD"] = "nodeIKernelGroupService/modifyMemberCardName";
  NTMethod2["SET_MEMBER_ROLE"] = "nodeIKernelGroupService/modifyMemberRole";
  NTMethod2["SET_GROUP_NAME"] = "nodeIKernelGroupService/modifyGroupName";
  NTMethod2["HANDLE_FRIEND_REQUEST"] = "nodeIKernelBuddyService/approvalFriendRequest";
  NTMethod2["CACHE_SET_SILENCE"] = "nodeIKernelStorageCleanService/setSilentScan";
  NTMethod2["CACHE_ADD_SCANNED_PATH"] = "nodeIKernelStorageCleanService/addCacheScanedPaths";
  NTMethod2["CACHE_SCAN"] = "nodeIKernelStorageCleanService/scanCache";
  NTMethod2["CACHE_CLEAR"] = "nodeIKernelStorageCleanService/clearCacheDataByKeys";
  NTMethod2["CACHE_CHAT_GET"] = "nodeIKernelStorageCleanService/getChatCacheInfo";
  NTMethod2["CACHE_FILE_GET"] = "nodeIKernelStorageCleanService/getFileCacheInfo";
  NTMethod2["CACHE_CHAT_CLEAR"] = "nodeIKernelStorageCleanService/clearChatCacheInfo";
  return NTMethod2;
})(NTMethod || {});
const NT_SERVICE_TO_PMHQ = {
  "nodeIKernelBuddyService": "getBuddyService",
  "nodeIKernelProfileService": "getProfileService",
  "nodeIKernelGroupService": "getGroupService",
  "nodeIKernelProfileLikeService": "getProfileLikeService",
  "nodeIKernelMsgService": "getMsgService",
  "nodeIKernelMSFService": "getMSFService",
  "nodeIKernelUixConvertService": "getUixConvertService",
  "nodeIKernelRichMediaService": "getRichMediaService",
  "nodeIKernelTicketService": "getTicketService",
  "nodeIKernelTipOffService": "getTipOffService",
  "nodeIKernelRobotService": "getRobotService",
  "nodeIKernelNodeMiscService": "getNodeMiscService",
  "nodeIKernelRecentContactService": "getRecentContactService",
  "nodeIKernelFlashTransferService": "getFlashTransferService"
};
function invoke(method, args, options = {}) {
  const splitMethod = method.split("/");
  const serviceName = splitMethod[0];
  const methodName = splitMethod.slice(1).join("/");
  const pmhqService = NT_SERVICE_TO_PMHQ[serviceName];
  let funcName = `wrapperSession.${pmhqService}().${methodName}`;
  if (!pmhqService) {
    funcName = method;
  }
  let timeout2 = options.timeout ?? 5e3;
  return new Promise((resolve2, reject) => {
    let timeoutId = null;
    let hookId = "";
    if (timeout2) {
      timeoutId = setTimeout(() => {
        removeReceiveHook(hookId);
        reject(`invoke timeout, ${funcName}, ${args}`);
      }, timeout2);
    }
    if (options.resultCmd) {
      let firstResult = void 0;
      hookId = registerReceiveHook(options.resultCmd, (data) => {
        if (options.resultCb && !options.resultCb(data, firstResult)) {
          return;
        }
        resolve2(data);
        removeReceiveHook(hookId);
        timeoutId && clearTimeout(timeoutId);
      });
      pmhq.call(funcName, args, timeout2).then((r) => firstResult = r).catch(reject);
    } else {
      pmhq.call(funcName, args, timeout2).then((r) => {
        resolve2(r);
        timeoutId && clearTimeout(timeoutId);
      }).catch(reject);
    }
  });
}
class RkeyManager {
  constructor(ctx, serverUrl) {
    this.ctx = ctx;
    this.serverUrl = serverUrl;
  }
  serverUrl = "";
  rkeyData = {
    group_rkey: "",
    private_rkey: "",
    expired_time: 0
  };
  async getRkey() {
    if (this.isExpired()) {
      try {
        await this.refreshRkey();
      } catch (e) {
        this.ctx.logger.error("rkey", e);
      }
    }
    return this.rkeyData;
  }
  isExpired() {
    const now = (/* @__PURE__ */ new Date()).getTime() / 1e3;
    return now > this.rkeyData.expired_time;
  }
  async refreshRkey() {
    try {
      const { privateRKey, groupRKey } = await this.ctx.get("app").pmhq.getRKey();
      if (privateRKey && groupRKey) {
        this.ctx.logger.info(`rkey,private:${privateRKey}, group:${groupRKey}`);
        this.rkeyData = {
          private_rkey: privateRKey,
          group_rkey: groupRKey,
          expired_time: (/* @__PURE__ */ new Date()).getTime() / 1e3 + 50 * 60
        };
      }
    } catch (e) {
      this.ctx.logger.warn(`rkey ${e}rkey`);
      try {
        this.rkeyData = await this.fetchServerRkey();
      } catch (e2) {
        this.ctx.logger.error("rkey", e2);
      }
    }
  }
  async fetchServerRkey() {
    const response2 = await fetch(this.serverUrl);
    if (!response2.ok) {
      throw new Error(response2.statusText);
    }
    return response2.json();
  }
}
class NTQQFileApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntFileApi", true);
    this.ctx = ctx;
    this.rkeyManager = new RkeyManager(ctx, "https://llob.linyuchen.net/rkey");
  }
  rkeyManager;
  async getVideoUrl(peer, msgId, elementId) {
    try {
      const data = await invoke("nodeIKernelRichMediaService/getVideoPlayUrlV2", [
        peer,
        msgId,
        elementId,
        0,
        // video code format, 0: H264, 1: H265 ?
        {
          downSourceType: 1,
          triggerType: 1
        }
      ]);
      if (data.result !== 0) {
        this.ctx.logger.warn("getVideoUrl", data);
      }
      return data.urlResult.domainUrl[0]?.url;
    } catch (e) {
      this.ctx.logger.warn("getVideoUrl error", e);
      return "";
    }
  }
  async getFileType(filePath) {
    return await getFileType(filePath);
  }
  /**  QQ  */
  async uploadFile(filePath, elementType = ElementType.Pic, elementSubType = 0) {
    const fileMd5 = await calculateFileMD5(filePath);
    let fileName = path__default.basename(filePath);
    if (!fileName.includes(".")) {
      const ext = (await this.getFileType(filePath))?.ext;
      fileName += ext ? "." + ext : "";
    }
    const mediaPath = await invoke(NTMethod.MEDIA_FILE_PATH, [
      {
        md5HexStr: fileMd5,
        fileName,
        elementType,
        elementSubType,
        thumbSize: 0,
        needCreate: true,
        downloadType: 1,
        file_uuid: ""
      }
    ]);
    await copyFile(filePath, mediaPath);
    const fileSize = (await stat(filePath)).size;
    return {
      md5: fileMd5,
      fileName,
      path: mediaPath,
      fileSize
    };
  }
  async downloadMedia(msgId, chatType, peerUid, elementId, thumbPath = "", sourcePath = "", timeout2 = 1e3 * 60 * 30, force = false) {
    if (sourcePath && existsSync(sourcePath)) {
      if (force) {
        unlink(sourcePath).then().catch((e) => {
        });
      } else {
        return sourcePath;
      }
    }
    const data = await invoke(
      "nodeIKernelMsgService/downloadRichMedia",
      [{
        fileModelId: "0",
        downloadSourceType: 0,
        triggerType: 1,
        msgId,
        chatType,
        peerUid,
        elementId,
        thumbSize: 0,
        downloadType: 1,
        filePath: thumbPath
      }],
      {
        resultCmd: ReceiveCmdS.MEDIA_DOWNLOAD_COMPLETE,
        resultCb: (payload) => payload.msgId === msgId,
        timeout: timeout2
      }
    );
    return data.filePath;
  }
  async getImageSize(filePath) {
    const fileType2 = await getFileType(filePath);
    const size = await getImageSize(filePath);
    return {
      type: fileType2.ext,
      ...size
    };
  }
  async getImageUrl(element) {
    if (!element) {
      return "";
    }
    const url = element.originImageUrl;
    const md5HexStr = element.md5HexStr;
    const fileMd5 = element.md5HexStr;
    if (url) {
      const parsedUrl = new URL(IMAGE_HTTP_HOST + url);
      const imageAppid = parsedUrl.searchParams.get("appid");
      const isNTPic = imageAppid && ["1406", "1407"].includes(imageAppid);
      if (isNTPic) {
        let rkey = parsedUrl.searchParams.get("rkey");
        if (rkey) {
          return IMAGE_HTTP_HOST_NT + url;
        }
        const rkeyData = await this.rkeyManager.getRkey();
        rkey = imageAppid === "1406" ? rkeyData.private_rkey : rkeyData.group_rkey;
        return IMAGE_HTTP_HOST_NT + url + rkey;
      } else {
        return IMAGE_HTTP_HOST + url;
      }
    } else if (fileMd5 || md5HexStr) {
      return `${IMAGE_HTTP_HOST}/gchatpic_new/0/0-0-${(fileMd5 || md5HexStr).toUpperCase()}/0`;
    }
    this.ctx.logger.error("url", element);
    return "";
  }
  async downloadFileForModelId(peer, fileModelId, timeout2 = 2 * Time.minute) {
    const data = await invoke(
      "nodeIKernelRichMediaService/downloadFileForModelId",
      [
        peer,
        [fileModelId],
        ""
        // savePath
      ],
      {
        resultCmd: ReceiveCmdS.MEDIA_DOWNLOAD_COMPLETE,
        resultCb: (payload) => payload.fileModelId === fileModelId,
        timeout: timeout2
      }
    );
    return data.filePath;
  }
  async ocrImage(path2) {
    return await invoke(
      "nodeIKernelNodeMiscService/wantWinScreenOCR",
      [
        path2
      ],
      {
        timeout: 2 * Time.minute
      }
    );
  }
  async uploadRMFileWithoutMsg(filePath, bizType, peerUid) {
    const data = await invoke(
      "nodeIKernelRichMediaService/uploadRMFileWithoutMsg",
      [
        {
          filePath,
          bizType,
          peerUid,
          useNTV2: true
        }
      ],
      {
        resultCmd: ReceiveCmdS.MEDIA_UPLOAD_COMPLETE,
        resultCb: (payload) => payload.filePath === filePath,
        timeout: 10 * Time.second
      }
    );
    return data;
  }
  async uploadFlashFile(title, filePaths) {
    const res = await invoke(
      "nodeIKernelFlashTransferService/createFlashTransferUploadTask",
      [
        (/* @__PURE__ */ new Date()).getTime(),
        {
          "scene": 1,
          "name": title,
          "uploaders": [
            {
              "uin": selfInfo.uin,
              "nickname": selfInfo.nick,
              "uid": selfInfo.uid,
              "sendEntrance": ""
            }
          ],
          "permission": {},
          "coverPath": "",
          "paths": filePaths,
          "excludePaths": [],
          "expireLeftTime": 0,
          "isNeedDelExif": true,
          "coverOriginalInfos": [
            {
              "path": "",
              "thumbnailPath": ""
            }
          ],
          "uploadSceneType": 1
        }
      ]
    );
    if (res.result !== 0) {
      throw new Error(`: ${res.result}`);
    }
    return res.createFlashTransferResult;
  }
  async downloadFlashFile(fileSetId, sceneType = 1) {
    const res = await invoke(
      "nodeIKernelFlashTransferService/startFileSetDownload",
      [
        fileSetId,
        sceneType,
        { "isIncludeCompressInnerFiles": false }
      ]
    );
    if (res.result !== 0) {
      throw new Error(`: ${res.errMsg}`);
    }
  }
  flashFileListCache = /* @__PURE__ */ new Map();
  async getFlashFileList(fileSetId, force = true) {
    if (!force) {
      const cachedList = this.flashFileListCache.get(fileSetId);
      if (cachedList) {
        return cachedList;
      }
    }
    const res = await invoke(
      "nodeIKernelFlashTransferService/getFileList",
      [
        {
          seq: 0,
          fileSetId,
          isUseCache: false,
          sceneType: 1,
          reqInfos: [
            {
              count: 18,
              paginationInfo: {},
              parentId: "",
              reqIndexPath: "",
              reqDepth: 1,
              filterCondition: {
                fileCategory: 0,
                filterType: 0
              },
              sortConditions: [
                {
                  sortField: 0,
                  sortOrder: 0
                }
              ],
              isNeedPhysicalInfoReady: false
            }
          ]
        }
      ]
    );
    if (res.rsp.result !== 0) {
      throw new Error(`: ${res.rsp.errMs}`);
    }
    if (this.flashFileListCache.size > 100) {
      const oldestKey = this.flashFileListCache.keys().next().value;
      this.flashFileListCache.delete(oldestKey);
    }
    this.flashFileListCache.set(fileSetId, res.rsp.fileLists);
    return res.rsp.fileLists;
  }
  async getFlashFileSetIdByCode(code) {
    const res = await invoke(
      "nodeIKernelFlashTransferService/getFileSetIdByCode",
      [code]
    );
    if (res.result !== 0) {
      throw new Error(` fileSetId : ${res.errMsg}`);
    }
    return res.fileSetId;
  }
  flashFileInfoCache = /* @__PURE__ */ new Map();
  async getFlashFileInfo(fileSetId, force = true) {
    if (!force) {
      const cachedInfo = this.flashFileInfoCache.get(fileSetId);
      if (cachedInfo) {
        return cachedInfo;
      }
    }
    const res = await invoke(
      "nodeIKernelFlashTransferService/getFileSet",
      [
        { seq: 0, fileSetId, isUseCache: false, isNoReqSvr: false, sceneType: 1 }
      ]
    );
    if (res.result !== 0) {
      throw new Error(`: ${res.errMsg}`);
    }
    if (this.flashFileInfoCache.size > 100) {
      const oldestKey = this.flashFileInfoCache.keys().next().value;
      this.flashFileInfoCache.delete(oldestKey);
    }
    this.flashFileInfoCache.set(fileSetId, res.fileSet);
    return res.fileSet;
  }
}
class NTQQFileCacheApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntFileCacheApi", true);
    this.ctx = ctx;
  }
  async setCacheSilentScan(isSilent = true) {
    return await invoke(NTMethod.CACHE_SET_SILENCE, [{ isSilent }]);
  }
  getCacheSessionPathList() {
  }
  scanCache() {
    invoke(ReceiveCmdS.CACHE_SCAN_FINISH, []);
    return invoke(NTMethod.CACHE_SCAN, [], { timeout: 300 * Time.second });
  }
  getHotUpdateCachePath() {
  }
  getDesktopTmpPath() {
  }
  getFileCacheInfo(fileType2, pageSize = 1e3, lastRecord) {
    const _lastRecord = lastRecord ? lastRecord : { fileType: fileType2 };
    return invoke(NTMethod.CACHE_FILE_GET, [{
      fileType: fileType2,
      restart: true,
      pageSize,
      order: 1,
      lastRecord: _lastRecord
    }]);
  }
  async clearChatCache(chats = [], fileKeys = []) {
    return await invoke(NTMethod.CACHE_CHAT_CLEAR, [{
      chats,
      fileKeys
    }]);
  }
}
const uidUinBidiMap = new BidiMap(-1);
class NTQQFriendApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntFriendApi", true);
    this.ctx = ctx;
  }
  async handleFriendRequest(friendUid, reqTime, accept) {
    return await invoke(NTMethod.HANDLE_FRIEND_REQUEST, [
      {
        friendUid,
        reqTime,
        accept
      }
    ]);
  }
  async getBuddyList() {
    const data = await invoke(
      "getBuddyList",
      [],
      {}
    );
    for (const item of data) {
      if (item.uid && item.uin) {
        uidUinBidiMap.set(item.uid, item.uin);
      }
    }
    return data;
  }
  async getBuddyV2(refresh = false) {
    const data = await this.getBuddyV2WithCate(false);
    return data.flatMap((item) => item.buddyList);
  }
  async getBuddyV2WithCate(refresh = false) {
    const categoryData = (await invoke(
      "nodeIKernelBuddyService/getBuddyListV2",
      [refresh, 0],
      {}
    )).data;
    const buddyList = await this.getBuddyList();
    const buddyMap = /* @__PURE__ */ new Map();
    for (const buddy of buddyList) {
      buddyMap.set(buddy.uid, buddy);
    }
    for (const category of categoryData) {
      category.buddyList = [];
      for (const uid of category.buddyUids) {
        category.buddyList.push(buddyMap.get(uid));
      }
    }
    return categoryData;
  }
  async isBuddy(uid) {
    return await invoke("nodeIKernelBuddyService/isBuddy", [uid]);
  }
  async getBuddyRecommendContact(uin) {
    const ret = await invoke("nodeIKernelBuddyService/getBuddyRecommendContactArkJson", [{ uin }]);
    return ret.arkMsg;
  }
  async setBuddyRemark(uid, remark = "") {
    return await invoke("nodeIKernelBuddyService/setBuddyRemark", [
      { uid, remark }
    ]);
  }
  async delBuddy(friendUid) {
    return await invoke("nodeIKernelBuddyService/delBuddy", [
      {
        friendUid,
        tempBlock: false,
        tempBothDel: true
      }
    ]);
  }
  async setBuddyCategory(uid, categoryId) {
    return await invoke("nodeIKernelBuddyService/setBuddyCategory", [uid, categoryId]);
  }
}
class NTQQGroupApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntGroupApi", true);
    this.ctx = ctx;
  }
  async getGroups() {
    const result = await invoke(
      "nodeIKernelGroupService/getGroupList",
      [true],
      {
        resultCmd: "nodeIKernelGroupListener/onGroupListUpdate"
      }
    );
    return result[1];
  }
  async getGroupMembers(groupCode, force = true) {
    const data = await invoke(NTMethod.GROUP_MEMBERS, [groupCode, force]);
    if (data.errCode !== 0) {
      throw new Error("," + data.errMsg);
    }
    const infos = data.result.infos;
    for (const [uid, member] of infos) {
      uidUinBidiMap.set(uid, member.uin);
    }
    return infos;
  }
  async getGroupMember(groupCode, uid, forceUpdate = false) {
    const data = await invoke(
      "nodeIKernelGroupService/getMemberInfo",
      [
        groupCode,
        [uid],
        forceUpdate
      ],
      {
        resultCmd: "nodeIKernelGroupListener/onMemberInfoChange",
        resultCb: (result) => {
          return result[0] === groupCode && result[2].has(uid);
        }
      }
    );
    return data[2].get(uid);
  }
  async getSingleScreenNotifies(doubt, number2, startSeq = "") {
    const data = await invoke(
      "nodeIKernelGroupService/getSingleScreenNotifies",
      [doubt, startSeq, number2],
      {
        resultCmd: ReceiveCmdS.GROUP_NOTIFY
      }
    );
    return data[2];
  }
  async getGroupRequest() {
    const normal = await this.getSingleScreenNotifies(false, 50);
    const normalCount = normal.length;
    const doubt = await this.getSingleScreenNotifies(true, 50);
    normal.push(...doubt);
    return { notifies: normal, normalCount };
  }
  async handleGroupRequest(flag, operateType, reason) {
    const flagitem = flag.split("|");
    const groupCode = flagitem[0];
    const seq = flagitem[1];
    const type2 = parseInt(flagitem[2]);
    const doubt = flagitem[3] === "1";
    return await invoke(NTMethod.HANDLE_GROUP_REQUEST, [
      doubt,
      {
        operateType,
        targetMsg: {
          seq,
          type: type2,
          groupCode,
          postscript: reason || " "
          // 
        }
      }
    ]);
  }
  async quitGroup(groupCode) {
    return await invoke(NTMethod.QUIT_GROUP, [groupCode]);
  }
  async kickMember(groupCode, kickUids, refuseForever = false, kickReason = "") {
    return await invoke(NTMethod.KICK_MEMBER, [groupCode, kickUids, refuseForever, kickReason]);
  }
  /** timeStamp, 0 */
  async banMember(groupCode, memList) {
    return await invoke(NTMethod.MUTE_MEMBER, [groupCode, memList]);
  }
  async banGroup(groupCode, shutUp) {
    return await invoke(NTMethod.MUTE_GROUP, [groupCode, shutUp]);
  }
  async setMemberCard(groupCode, memberUid, cardName) {
    return await invoke(NTMethod.SET_MEMBER_CARD, [groupCode, memberUid, cardName]);
  }
  async setMemberRole(groupCode, memberUid, role) {
    return await invoke(NTMethod.SET_MEMBER_ROLE, [groupCode, memberUid, role]);
  }
  async setGroupName(groupCode, groupName) {
    return await invoke(NTMethod.SET_GROUP_NAME, [groupCode, groupName, false]);
  }
  async getGroupRemainAtTimes(groupCode) {
    return await invoke(NTMethod.GROUP_AT_ALL_REMAIN_COUNT, [groupCode]);
  }
  async removeGroupEssence(groupCode, msgId) {
    const ntMsgApi = this.ctx.get("ntMsgApi");
    const data = await ntMsgApi.getMsgHistory({ chatType: 2, guildId: "", peerUid: groupCode }, msgId, 1, false);
    return await invoke("nodeIKernelGroupService/removeGroupEssence", [{
      groupCode,
      msgRandom: Number(data?.msgList[0].msgRandom),
      msgSeq: Number(data?.msgList[0].msgSeq)
    }]);
  }
  async addGroupEssence(groupCode, msgId) {
    const ntMsgApi = this.ctx.get("ntMsgApi");
    const data = await ntMsgApi.getMsgHistory({ chatType: 2, guildId: "", peerUid: groupCode }, msgId, 1, false);
    return await invoke("nodeIKernelGroupService/addGroupEssence", [
      {
        groupCode,
        msgRandom: Number(data?.msgList[0].msgRandom),
        msgSeq: Number(data?.msgList[0].msgSeq)
      }
    ]);
  }
  async createGroupFileFolder(groupId, folderName) {
    return await invoke("nodeIKernelRichMediaService/createGroupFolder", [groupId, folderName]);
  }
  async deleteGroupFileFolder(groupId, folderId) {
    return await invoke("nodeIKernelRichMediaService/deleteGroupFolder", [groupId, folderId]);
  }
  async deleteGroupFile(groupId, fileIdList, busIdList) {
    return await invoke("nodeIKernelRichMediaService/deleteGroupFile", [groupId, busIdList, fileIdList]);
  }
  async getGroupFileList(groupId, fileListForm) {
    const data = await invoke(
      "nodeIKernelRichMediaService/getGroupFileList",
      [
        groupId,
        fileListForm
      ],
      {
        resultCmd: "nodeIKernelMsgListener/onGroupFileInfoUpdate",
        resultCb: (payload, reqId) => {
          return payload.reqId === reqId;
        }
      }
    );
    return data;
  }
  async publishGroupBulletin(groupCode, req) {
    const ntUserApi = this.ctx.get("ntUserApi");
    const psKey = (await ntUserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    return await invoke("nodeIKernelGroupService/publishGroupBulletin", [groupCode, psKey, req]);
  }
  async uploadGroupBulletinPic(groupCode, path2) {
    const ntUserApi = this.ctx.get("ntUserApi");
    const psKey = (await ntUserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    return await invoke("nodeIKernelGroupService/uploadGroupBulletinPic", [groupCode, psKey, path2]);
  }
  async getGroupRecommendContact(groupCode) {
    const ret = await invoke("nodeIKernelGroupService/getGroupRecommendContactArkJson", [{ groupCode }]);
    return ret.arkJson;
  }
  async queryCachedEssenceMsg(groupCode, msgSeq = "0", msgRandom = "0") {
    return await invoke("nodeIKernelGroupService/queryCachedEssenceMsg", [
      {
        groupCode,
        msgSeq: +msgSeq,
        msgRandom: +msgRandom
      }
    ]);
  }
  async getGroupHonorList(groupCode) {
    return await invoke("nodeIKernelGroupService/getGroupHonorList", [{
      req: {
        groupCode: [+groupCode]
      }
    }]);
  }
  async getGroupAllInfo(groupCode) {
    return await invoke(
      "nodeIKernelGroupService/getGroupAllInfo",
      [
        groupCode,
        4
      ],
      {
        resultCmd: "nodeIKernelGroupListener/onGroupAllInfoChange",
        resultCb: (payload) => {
          return payload.groupCode === groupCode;
        }
      }
    );
  }
  async getGroupBulletinList(groupCode) {
    const ntUserApi = this.ctx.get("ntUserApi");
    const psKey = (await ntUserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    const result = await invoke(
      "nodeIKernelGroupService/getGroupBulletinList",
      [
        groupCode,
        psKey,
        "",
        {
          startIndex: -1,
          num: 20,
          needInstructionsForJoinGroup: 1,
          needPublisherInfo: 1
        }
      ],
      {
        resultCmd: "nodeIKernelGroupListener/onGetGroupBulletinListResult",
        resultCb: (payload) => payload[0] === groupCode
      }
    );
    return result[2];
  }
  async setGroupAvatar(groupCode, path2) {
    return await invoke("nodeIKernelGroupService/setHeader", [path2, groupCode]);
  }
  async searchMember(groupCode, keyword) {
    const sceneId = await invoke(NTMethod.GROUP_MEMBER_SCENE, [{
      groupCode,
      scene: "groupMemberList_MainWindow"
    }]);
    const data = await invoke(
      "nodeIKernelGroupService/searchMember",
      [{ sceneId, keyword }],
      {
        resultCmd: "nodeIKernelGroupListener/onSearchMemberChange",
        resultCb: (payload) => {
          return payload.sceneId === sceneId && payload.keyword === keyword;
        }
      }
    );
    return data.infos;
  }
  async getGroupFileCount(groupId) {
    return await invoke(
      "nodeIKernelRichMediaService/batchGetGroupFileCount",
      [{ groupIds: [groupId] }]
    );
  }
  async getGroupFileSpace(groupId) {
    return await invoke(
      "nodeIKernelRichMediaService/getGroupSpace",
      [{ groupId }]
    );
  }
  async setGroupMsgMask(groupCode, msgMask) {
    return await invoke("nodeIKernelGroupService/setGroupMsgMask", [groupCode, msgMask]);
  }
  async setGroupRemark(groupCode, groupRemark = "") {
    return await invoke("nodeIKernelGroupService/modifyGroupRemark", [groupCode, groupRemark]);
  }
  async moveGroupFile(groupId, fileIdList, curFolderId, dstFolderId) {
    return await invoke("nodeIKernelRichMediaService/moveGroupFile", [{
      groupId,
      fileIdList,
      curFolderId,
      dstFolderId,
      busIdList: [102]
    }]);
  }
  async getGroupShutUpMemberList(groupCode) {
    const res = await invoke(
      "nodeIKernelGroupService/getGroupShutUpMemberList",
      [groupCode],
      {
        resultCmd: "nodeIKernelGroupListener/onShutUpMemberListChanged",
        resultCb: (payload) => payload[0] === groupCode
      }
    );
    return res[1];
  }
  async renameGroupFolder(groupId, folderId, newFolderName) {
    return await invoke("nodeIKernelRichMediaService/renameGroupFolder", [
      groupId,
      folderId,
      newFolderName
    ]);
  }
}
class NTQQMsgApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntMsgApi", true);
    this.ctx = ctx;
  }
  static inject = ["ntUserApi"];
  async getTempChatInfo(chatType, peerUid) {
    return await invoke("nodeIKernelMsgService/getTempChatInfo", [chatType, peerUid]);
  }
  async setEmojiLike(peer, msgSeq, emojiId, setEmoji) {
    const emojiType = emojiId.length > 3 ? "2" : "1";
    return await invoke(NTMethod.EMOJI_LIKE, [peer, msgSeq, emojiId, emojiType, setEmoji]);
  }
  async getMultiMsg(peer, rootMsgId, parentMsgId) {
    return await invoke(NTMethod.GET_MULTI_MSG, [peer, rootMsgId, parentMsgId]);
  }
  async activateChat(peer) {
    return await invoke(NTMethod.ACTIVE_CHAT_PREVIEW, [peer, 0]);
  }
  async activateChatAndGetHistory(peer, cnt) {
    return await invoke(NTMethod.ACTIVE_CHAT_HISTORY, [peer, cnt, "0", true]);
  }
  async getAioFirstViewLatestMsgs(peer, cnt) {
    return await invoke("nodeIKernelMsgService/getAioFirstViewLatestMsgs", [peer, cnt]);
  }
  async getMsgsByMsgId(peer, msgIds) {
    if (!peer) throw new Error("peer is not allowed");
    if (!msgIds) throw new Error("msgIds is not allowed");
    return await invoke("nodeIKernelMsgService/getMsgsByMsgId", [peer, msgIds]);
  }
  async getMsgHistory(peer, msgId, cnt, queryOrder = false) {
    return await invoke(NTMethod.HISTORY_MSG, [peer, msgId, cnt, queryOrder]);
  }
  async recallMsg(peer, msgIds) {
    return await invoke(NTMethod.RECALL_MSG, [peer, msgIds]);
  }
  async sendMsg(peer, msgElements, timeout2 = 1e4) {
    const uniqueId = await this.generateMsgUniqueId(peer.chatType);
    const msgAttributeInfos = /* @__PURE__ */ new Map();
    msgAttributeInfos.set(0, {
      attrType: 0,
      attrId: uniqueId,
      vasMsgInfo: {
        msgNamePlateInfo: {},
        bubbleInfo: {},
        avatarPendantInfo: {},
        vasFont: {},
        iceBreakInfo: {}
      }
    });
    let sentMsgId;
    const data = await invoke(
      "nodeIKernelMsgService/sendMsg",
      [
        "0",
        peer,
        msgElements,
        msgAttributeInfos
      ],
      {
        resultCmd: "nodeIKernelMsgListener/onMsgInfoListUpdate",
        resultCb: (payload) => {
          for (const msgRecord of payload) {
            if (msgRecord.msgAttrs.get(0)?.attrId === uniqueId && msgRecord.sendStatus === 2) {
              sentMsgId = msgRecord.msgId;
              return true;
            }
          }
          return false;
        },
        timeout: timeout2
      }
    );
    return data.find((msgRecord) => msgRecord.msgId === sentMsgId);
  }
  async forwardMsg(srcPeer, destPeer, msgIds) {
    const uniqueId = await this.generateMsgUniqueId(destPeer.chatType);
    destPeer.guildId = uniqueId;
    const commentElements = [];
    const msgAttributeInfos = /* @__PURE__ */ new Map();
    const data = await invoke(
      "nodeIKernelMsgService/forwardMsgWithComment",
      [
        msgIds,
        srcPeer,
        [destPeer],
        commentElements,
        msgAttributeInfos
      ],
      {
        resultCmd: "nodeIKernelMsgListener/onMsgInfoListUpdate",
        resultCb: (payload) => {
          for (const msgRecord of payload) {
            if (msgRecord.guildId === uniqueId && msgRecord.sendStatus === 2) {
              return true;
            }
          }
          return false;
        },
        timeout: 3e3
      }
    );
    delete destPeer.guildId;
    return data.filter((msgRecord) => msgRecord.guildId === uniqueId);
  }
  async multiForwardMsg(srcPeer, destPeer, msgIds) {
    const senderShowName = await this.ctx.ntUserApi.getSelfNick(false);
    const msgInfos = msgIds.map((id) => {
      return { msgId: id, senderShowName };
    });
    const selfUid = selfInfo.uid;
    const commentElements = [];
    const msgAttributeInfos = /* @__PURE__ */ new Map();
    const data = await invoke(
      "nodeIKernelMsgService/multiForwardMsgWithComment",
      [
        msgInfos,
        srcPeer,
        destPeer,
        commentElements,
        msgAttributeInfos
      ],
      {
        resultCmd: "nodeIKernelMsgListener/onMsgInfoListUpdate",
        resultCb: (payload) => {
          for (const msgRecord of payload) {
            if (msgRecord.msgType === 11 && msgRecord.subMsgType === 7 && msgRecord.peerUid === destPeer.peerUid && msgRecord.senderUid === selfUid) {
              const element = msgRecord.elements[0];
              const data2 = JSON.parse(element.arkElement.bytesData);
              if (data2.app !== "com.tencent.multimsg" || !data2.meta.detail.resid) {
                continue;
              }
              return true;
            }
          }
          return false;
        }
      }
    );
    return data.find((msgRecord) => {
      const { arkElement } = msgRecord.elements[0];
      if (arkElement?.bytesData.includes("com.tencent.multimsg")) {
        return true;
      }
    });
  }
  async getSingleMsg(peer, msgSeq) {
    return await invoke("nodeIKernelMsgService/getSingleMsg", [peer, msgSeq]);
  }
  async queryFirstMsgBySeq(peer, msgSeq) {
    return await invoke("nodeIKernelMsgService/queryMsgsWithFilterEx", [
      "0",
      // msgId
      "0",
      // msgTime
      msgSeq,
      {
        chatInfo: peer,
        filterMsgType: [],
        filterSendersUid: [],
        filterMsgToTime: "0",
        filterMsgFromTime: "0",
        isReverseOrder: true,
        isIncludeCurrent: true,
        pageLimit: 1
      }
    ]);
  }
  async queryMsgsWithFilterExBySeq(peer, msgSeq, filterMsgTime, filterSendersUid = []) {
    return await invoke("nodeIKernelMsgService/queryMsgsWithFilterEx", [
      "0",
      "0",
      msgSeq,
      {
        chatInfo: peer,
        filterMsgType: [],
        filterSendersUid,
        filterMsgToTime: filterMsgTime,
        filterMsgFromTime: filterMsgTime,
        isIncludeCurrent: true,
        pageLimit: 1
      }
    ]);
  }
  async setMsgRead(peer) {
    return await invoke("nodeIKernelMsgService/setMsgRead", [peer]);
  }
  async getMsgEmojiLikesList(peer, msgSeq, emojiId, emojiType, count) {
    return await invoke("nodeIKernelMsgService/getMsgEmojiLikesList", [
      peer,
      msgSeq,
      emojiId,
      emojiType,
      count
    ]);
  }
  async fetchFavEmojiList(count) {
    return await invoke("nodeIKernelMsgService/fetchFavEmojiList", [
      "",
      // resId
      count,
      true,
      // backwardFetch
      true
      // forceRefresh
    ]);
  }
  async generateMsgUniqueId(chatType) {
    const time = await this.getServerTime();
    const uniqueId = await invoke("nodeIKernelMsgService/generateMsgUniqueId", [chatType, time]);
    if (typeof uniqueId === "string") {
      return uniqueId;
    } else {
      const random = Math.trunc(Math.random() * 100);
      return `${Date.now()}${random}`;
    }
  }
  async queryMsgsById(chatType, msgId) {
    const msgTime = this.getMsgTimeFromId(msgId);
    return await invoke("nodeIKernelMsgService/queryMsgsWithFilterEx", [{
      msgId,
      msgTime: "0",
      msgSeq: "0",
      params: {
        chatInfo: {
          peerUid: "",
          chatType
        },
        filterMsgToTime: msgTime,
        filterMsgFromTime: msgTime,
        isIncludeCurrent: true,
        pageLimit: 1
      }
    }]);
  }
  getMsgTimeFromId(msgId) {
    return String(BigInt(msgId) >> 32n);
  }
  async getServerTime() {
    return await invoke("nodeIKernelMSFService/getServerTime", []);
  }
  async fetchUnitedCommendConfig(groups) {
    return await invoke("nodeIKernelUnitedConfigService/fetchUnitedCommendConfig", [{ groups }]);
  }
  async getMsgsBySeqAndCount(peer, msgSeq, cnt, queryOrder, includeDeleteMsg) {
    try {
      return await invoke(
        "nodeIKernelMsgService/getMsgsBySeqAndCount",
        [
          peer,
          msgSeq,
          cnt,
          queryOrder,
          includeDeleteMsg
        ],
        {
          timeout: Math.max(1e3 * cnt, 3e3)
        }
      );
    } catch (e) {
      this.ctx.logger.error("getMsgsBySeqAndCount error", e);
      return { msgList: [] };
    }
  }
  async getSourceOfReplyMsgByClientSeqAndTime(peer, clientSeq, msgTime, sourceMsgIdInRecords) {
    return await invoke("nodeIKernelMsgService/getSourceOfReplyMsgByClientSeqAndTime", [peer, clientSeq, msgTime, sourceMsgIdInRecords]);
  }
  async translatePtt2Text(msgId, peer, voiceMsgElement) {
    const res = await invoke(
      "nodeIKernelMsgService/translatePtt2Text",
      [msgId, peer, voiceMsgElement],
      {
        resultCmd: ReceiveCmdS.UPDATE_MSG,
        resultCb: (msgList) => {
          const voiceMsg = msgList[0];
          if (voiceMsg && voiceMsg.msgId === msgId && voiceMsg.elements.length > 0) {
            const pttElement = voiceMsg.elements[0].pttElement;
            if (pttElement && pttElement.text) {
              return true;
            }
          }
          return false;
        }
      }
    );
    return res[0]?.elements[0]?.pttElement?.text || "";
  }
}
class RequestUtil {
  // cookiesGET
  static async HttpsGetCookies(url) {
    const client = url.startsWith("https") ? https : require$$2$3;
    return new Promise((resolve2, reject) => {
      client.get(url, (res) => {
        let cookies = {};
        const handleRedirect = (res2) => {
          if (res2.statusCode === 301 || res2.statusCode === 302) {
            if (res2.headers.location) {
              const redirectUrl = new URL(res2.headers.location, url);
              RequestUtil.HttpsGetCookies(redirectUrl.href).then((redirectCookies) => {
                cookies = { ...cookies, ...redirectCookies };
                resolve2(cookies);
              }).catch(reject);
            } else {
              resolve2(cookies);
            }
          } else {
            resolve2(cookies);
          }
        };
        res.on("data", () => {
        });
        res.on("end", () => {
          handleRedirect(res);
        });
        if (res.headers["set-cookie"]) {
          res.headers["set-cookie"].forEach((cookie2) => {
            const parts = cookie2.split(";")[0].split("=");
            const key2 = parts[0];
            const value = parts[1];
            if (key2 && value && key2.length > 0 && value.length > 0) {
              cookies[key2] = value;
            }
          });
        }
      }).on("error", (err) => {
        reject(err);
      });
    });
  }
  // JSON data json
  static async HttpGetJson(url, method = "GET", data, headers = {}, isJsonRet = true, isArgJson = true) {
    const option = new URL(url);
    const protocol = url.startsWith("https://") ? https : require$$2$3;
    const options = {
      hostname: option.hostname,
      port: option.port,
      path: option.href,
      method,
      headers
    };
    return new Promise((resolve2, reject) => {
      const req = protocol.request(options, (res) => {
        let responseBody = "";
        res.on("data", (chunk) => {
          responseBody += chunk.toString();
        });
        res.on("end", () => {
          try {
            if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
              if (isJsonRet) {
                const responseJson = JSON.parse(responseBody);
                resolve2(responseJson);
              } else {
                resolve2(responseBody);
              }
            } else {
              reject(new Error(`Unexpected status code: ${res.statusCode}`));
            }
          } catch (parseError) {
            reject(parseError);
          }
        });
      });
      req.on("error", (error) => {
        reject(error);
      });
      if (method === "POST" || method === "PUT" || method === "PATCH") {
        if (isArgJson) {
          req.write(JSON.stringify(data));
        } else {
          req.write(data);
        }
      }
      req.end();
    });
  }
  // 
  static async HttpGetText(url, method = "GET", data, headers = {}) {
    return this.HttpGetJson(url, method, data, headers, false, false);
  }
}
class NTQQUserApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntUserApi", true);
    this.ctx = ctx;
  }
  static inject = ["ntFriendApi", "ntGroupApi"];
  async setSelfAvatar(path2) {
    return await invoke(
      "nodeIKernelProfileService/setHeader",
      [path2],
      {
        timeout: 10 * Time.second
        // 10
      }
    );
  }
  async getUidByUin(uin, groupCode) {
    let uid = uidUinBidiMap.getKey(uin);
    if (uid) return uid;
    const funcs = [
      async () => {
        return (await invoke("nodeIKernelUixConvertService/getUid", [[uin]]))?.uidInfo.get(uin);
      },
      async () => {
        return (await invoke("nodeIKernelGroupService/getUidByUins", [[uin]])).uids.get(uin);
      },
      async () => {
        return (await invoke("nodeIKernelProfileService/getUidByUin", ["FriendsServiceImpl", [uin]]))?.get(uin);
      },
      async () => {
        return (await this.getUserDetailInfoByUin(uin)).detail.uid;
      }
    ];
    for (const f of funcs) {
      try {
        const uid2 = await f();
        if (uid2) {
          uidUinBidiMap.set(uid2, uin);
          return uid2;
        }
      } catch (e) {
        this.ctx.logger.error("get uid by uin filed", e);
      }
    }
    return "";
  }
  async getUserDetailInfoByUin(uin) {
    return await invoke("nodeIKernelProfileService/getUserDetailInfoByUin", [uin]);
  }
  async getUinByUid(uid, groupCode) {
    let uin = uidUinBidiMap.get(uid);
    if (uin)
      return uin;
    if (groupCode) {
      try {
        await this.ctx.ntGroupApi.getGroupMembers(groupCode);
        uin = uidUinBidiMap.get(uid);
        if (uin) return uin;
      } catch (e) {
      }
    }
    const funcs = [
      async () => {
        const uin2 = (await invoke("nodeIKernelUixConvertService/getUin", [[uid]])).uinInfo.get(uid) || "";
        this.ctx.logger.info("nodeIKernelUixConvertService/getUin", uin2);
        return uin2;
      },
      async () => {
        const uin2 = (await this.fetchUserDetailInfo(uid))?.uin;
        this.ctx.logger.info("fetchUserDetailInfo", uin2);
        return uin2;
      }
    ];
    for (const f of funcs) {
      try {
        const result = await f();
        if (result) {
          uidUinBidiMap.set(uid, result);
          return result;
        }
      } catch (e) {
        this.ctx.logger.error("get uin filed", e);
      }
    }
    return "";
  }
  // 
  async fetchUserDetailInfo(uid) {
    const result = await invoke(
      "nodeIKernelProfileService/fetchUserDetailInfo",
      [
        "BuddyProfileStore",
        // callFrom
        [uid],
        UserDetailSource.KSERVER,
        // source
        [ProfileBizType.KALL]
        //bizList
      ]
    );
    return result.detail.get(uid);
  }
  async getUserDetailInfoWithBizInfo(uid) {
    const result = await invoke(
      "nodeIKernelProfileService/getUserDetailInfoWithBizInfo",
      [
        uid,
        [0]
      ],
      {
        resultCmd: "nodeIKernelProfileListener/onUserDetailInfoChanged",
        resultCb: (payload) => payload.simpleInfo.uid === uid
      }
    );
    return result.simpleInfo;
  }
  async getUserSimpleInfo(uid, force = true) {
    return await this.getUserDetailInfoWithBizInfo(uid);
  }
  async getCoreAndBaseInfo(uids) {
    return await invoke(
      "nodeIKernelProfileService/getCoreAndBaseInfo",
      [
        uids,
        "nodeStore"
      ]
    );
  }
  async getBuddyNick(uid) {
    const data = await invoke("nodeIKernelBuddyService/getBuddyNick", [[uid]]);
    return data.get(uid) || "";
  }
  async getCookies(domain) {
    const clientKeyData = await this.forceFetchClientKey();
    if (clientKeyData?.result !== 0) {
      throw new Error("clientKey");
    }
    const uin = selfInfo.uin;
    const requestUrl = "https://ssl.ptlogin2.qq.com/jump?ptlang=1033&clientuin=" + uin + "&clientkey=" + clientKeyData.clientKey + "&u1=https%3A%2F%2F" + domain + "%2F" + uin + "%2Finfocenter&keyindex=19%27";
    const cookies = await RequestUtil.HttpsGetCookies(requestUrl);
    return cookies;
  }
  async getPSkey(domains) {
    return await invoke("nodeIKernelTipOffService/getPskey", [
      domains,
      true
      // isFromNewPCQQ
    ]);
  }
  async like(uid, count = 1) {
    return await invoke(
      "nodeIKernelProfileLikeService/setBuddyProfileLike",
      [{
        friendUid: uid,
        sourceId: 71,
        doLikeCount: count,
        doLikeTollCount: 0
      }]
    );
  }
  async forceFetchClientKey() {
    return await invoke("nodeIKernelTicketService/forceFetchClientKey", [{ url: "" }]);
  }
  async getSelfNick(refresh = true) {
    if ((refresh || !selfInfo.nick) && selfInfo.uid) {
      selfInfo.nick = await this.getBuddyNick(selfInfo.uid);
    }
    return selfInfo.nick;
  }
  async setSelfStatus(status, extStatus, batteryStatus) {
    return await invoke("nodeIKernelMsgService/setStatus", [
      {
        status,
        extStatus,
        batteryStatus
      }
    ]);
  }
  async getProfileLike(uid, start = 0, limit = 20) {
    return await invoke("nodeIKernelProfileLikeService/getBuddyProfileLike", [
      {
        friendUids: [uid],
        basic: 1,
        vote: 0,
        favorite: 1,
        userProfile: 1,
        type: 3,
        start,
        limit
      }
    ]);
  }
  async getProfileLikeMe(uid, start = 0, limit = 20) {
    return await invoke("nodeIKernelProfileLikeService/getBuddyProfileLike", [
      {
        friendUids: [uid],
        basic: 1,
        vote: 1,
        favorite: 0,
        userProfile: 1,
        type: 2,
        start,
        limit
      }
    ]);
  }
  async getRobotUinRange() {
    const data = await invoke(
      "nodeIKernelRobotService/getRobotUinRange",
      [
        {
          justFetchMsgConfig: "1",
          type: 1,
          version: 0,
          aioKeywordVersion: 0
        }
      ]
    );
    return data.response.robotUinRanges;
  }
  async quitAccount() {
    return await invoke(
      "quitAccount",
      []
    );
  }
  async modifySelfProfile(profile) {
    return await invoke("nodeIKernelProfileService/modifyDesktopMiniProfile", [profile]);
  }
  async getRecentContactListSnapShot(count) {
    return await invoke("nodeIKernelRecentContactService/getRecentContactListSnapShot", [count]);
  }
}
class NTQQWebApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntWebApi", true);
    this.ctx = ctx;
  }
  static inject = ["ntUserApi"];
  genBkn(sKey) {
    sKey = sKey || "";
    let hash = 5381;
    for (let i = 0; i < sKey.length; i++) {
      const code = sKey.charCodeAt(i);
      hash = hash + (hash << 5) + code;
    }
    return (hash & 2147483647).toString();
  }
  async getGroupHonorInfo(groupCode, getType) {
    const getDataInternal = async (groupCode2, type2) => {
      const url = "https://qun.qq.com/interactive/honorlist?gc=" + groupCode2 + "&type=" + type2;
      let resJson;
      try {
        const res = await RequestUtil.HttpGetText(url, "GET", "", { "Cookie": cookieStr });
        const match = res.match(/window\.__INITIAL_STATE__=(.*?);/);
        if (match) {
          resJson = JSON.parse(match[1].trim());
        }
        if (type2 === 1) {
          return resJson?.talkativeList;
        } else {
          return resJson?.actorList;
        }
      } catch (e) {
        this.ctx.logger.error("", url, e);
      }
      return void 0;
    };
    const honorInfo = { group_id: groupCode };
    const cookieObject = await this.ctx.ntUserApi.getCookies("qun.qq.com");
    const cookieStr = this.cookieToString(cookieObject);
    if (getType === "talkative" || getType === "all") {
      try {
        const RetInternal = await getDataInternal(groupCode, 1);
        if (!RetInternal) {
          throw new Error("");
        }
        honorInfo.current_talkative = {
          user_id: RetInternal[0]?.uin,
          avatar: RetInternal[0]?.avatar,
          nickname: RetInternal[0]?.name,
          day_count: 0,
          description: RetInternal[0]?.desc
        };
        honorInfo.talkative_list = [];
        for (const talkative_ele of RetInternal) {
          honorInfo.talkative_list.push({
            user_id: talkative_ele?.uin,
            avatar: talkative_ele?.avatar,
            description: talkative_ele?.desc,
            day_count: 0,
            nickname: talkative_ele?.name
          });
        }
      } catch (e) {
        this.ctx.logger.error(e);
      }
    }
    if (getType === "performer" || getType === "all") {
      try {
        const RetInternal = await getDataInternal(groupCode, 2);
        if (!RetInternal) {
          throw new Error("");
        }
        honorInfo.performer_list = [];
        for (const performer_ele of RetInternal) {
          honorInfo.performer_list.push({
            user_id: performer_ele?.uin,
            nickname: performer_ele?.name,
            avatar: performer_ele?.avatar,
            description: performer_ele?.desc
          });
        }
      } catch (e) {
        this.ctx.logger.error(e);
      }
    }
    if (getType === "performer" || getType === "all") {
      try {
        const RetInternal = await getDataInternal(groupCode, 3);
        if (!RetInternal) {
          throw new Error("");
        }
        honorInfo.legend_list = [];
        for (const legend_ele of RetInternal) {
          honorInfo.legend_list.push({
            user_id: legend_ele?.uin,
            nickname: legend_ele?.name,
            avatar: legend_ele?.avatar,
            desc: legend_ele?.description
          });
        }
      } catch (e) {
        this.ctx.logger.error("", e);
      }
    }
    if (getType === "emotion" || getType === "all") {
      try {
        const RetInternal = await getDataInternal(groupCode, 6);
        if (!RetInternal) {
          throw new Error("");
        }
        honorInfo.emotion_list = [];
        for (const emotion_ele of RetInternal) {
          honorInfo.emotion_list.push({
            user_id: emotion_ele?.uin,
            nickname: emotion_ele?.name,
            avatar: emotion_ele?.avatar,
            desc: emotion_ele?.description
          });
        }
      } catch (e) {
        this.ctx.logger.error("", e);
      }
    }
    if (getType === "emotion" || getType === "all") {
      honorInfo.strong_newbie_list = [];
    }
    return honorInfo;
  }
  cookieToString(cookieObject) {
    return Object.entries(cookieObject).map(([key2, value]) => `${key2}=${value}`).join("; ");
  }
}
class NTQQSystemApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntSystemApi", true);
    this.ctx = ctx;
  }
  async restart() {
    await this.setSettingAutoLogin(true);
  }
  async getSettingAutoLogin() {
    return invoke("nodeIKernelNodeMiscService/queryAutoRun", []);
  }
  async setSettingAutoLogin(state) {
    await invoke("nodeIKernelSettingService/setNeedConfirmSwitch", [1]);
    await invoke("nodeIKernelSettingService/setAutoLoginSwitch", [state]);
  }
}
const __vite_import_meta_env__ = {};
express();
const __filename$1 = fileURLToPath$1(import.meta.url);
const __dirname$2 = require$$1$2.dirname(__filename$1);
let feDistPath = require$$1$2.resolve(__dirname$2, "webui/");
if (!__vite_import_meta_env__) {
  feDistPath = require$$1$2.join(__dirname$2, "../../../dist/webui/");
}
class WebUIServer extends Service2 {
  constructor(ctx, config) {
    super(ctx);
    this.config = config;
    this.app.use(express.static(feDistPath));
    this.app.use(express.json());
    this.app.use("/api", (req, res, next) => {
      const config2 = getConfigUtil().getConfig();
      const token2 = config2.webui?.token;
      if (!token2) {
        if (req.path === "/set-token") return next();
        res.status(401).json({ success: false, message: "WebUI" });
        return;
      }
      const reqToken = req.headers["x-webui-token"] || req.body?.token || req.query?.token;
      if (reqToken !== token2) {
        res.status(403).json({ success: false, message: "Token" });
        return;
      }
      next();
    });
    this.app.get("/api/config/", (req, res) => {
      try {
        const config2 = getConfigUtil().getConfig();
        const { nick, uin } = selfInfo;
        res.json({ success: true, data: { config: config2, selfInfo: { nick, uin } } });
      } catch (e) {
        res.status(500).json({ success: false, message: "", error: String(e) });
      }
    });
    this.app.post("/api/config", (req, res) => {
      try {
        const config2 = req.body;
        const oldConfig = getConfigUtil().getConfig();
        const newConfig = { ...oldConfig, ...config2 };
        this.ctx.parallel("llob/config-updated", newConfig).then();
        getConfigUtil().setConfig(newConfig);
        res.json({ success: true, message: "" });
      } catch (e) {
        res.status(500).json({ success: false, message: "", error: String(e) });
      }
    });
    this.app.post("/api/set-token", (req, res) => {
      const { token: token2 } = req.body;
      if (!token2) {
        res.status(400).json({ success: false, message: "Token" });
        return;
      }
      const config2 = getConfigUtil().getConfig();
      config2.webui.token = token2;
      getConfigUtil().setConfig(config2);
      res.json({ success: true, message: "Token" });
    });
    this.app.get("/api/login-info", (req, res) => {
      const { nick, uin } = selfInfo;
      res.json({ success: true, data: { nick, uin } });
    });
    this.app.get("/", (req, res) => {
      res.sendFile(require$$1$2.join(feDistPath, "index.html"));
    });
    ctx.on("llob/config-updated", (newConfig) => {
      const oldConfig = { ...this.config };
      this.config = { onlyLocalhost: newConfig.onlyLocalhost, ...newConfig.webui };
      if (oldConfig.onlyLocalhost != newConfig.onlyLocalhost || oldConfig.enable != newConfig.webui?.enable || oldConfig.port != newConfig.webui?.port) {
        this.ctx.logger.info("WebUI :", this.config);
        this.restart();
      }
    });
  }
  static inject = [];
  server = null;
  app = express();
  // Override the base Service.start() signature to match expected arguments
  async start() {
    if (!this.config?.enable) {
      return;
    }
    let port = this.config.port ?? 3080;
    port = await getAvailablePort(port);
    recordPort(
      selfInfo.uin,
      { webUIPort: port }
    ).catch((err) => {
      this.ctx.logger.error("WebUI:", err);
    });
    const host = this.config.onlyLocalhost ? "127.0.0.1" : "";
    this.server = this.app.listen(port, host, () => {
      this.ctx.logger.info(`WebUI : ${port}`);
    });
    this.server.on("error", (err) => {
      if (err.code === "EADDRINUSE") {
        this.ctx.logger.error(`WebUI  ${port} `);
      } else {
        this.ctx.logger.error("WebUI :", err);
      }
    });
  }
  stop() {
    this.server?.close();
  }
  restart() {
    this.stop();
    this.start();
  }
}
const __dirname$1 = typeof window === "undefined" ? path__default.dirname(fileURLToPath(import.meta.url)) : "";
global.__dirname = __dirname$1;
async function onLoad() {
  if (!existsSync(DATA_DIR)) {
    mkdirSync(DATA_DIR, { recursive: true });
  }
  if (!existsSync(LOG_DIR)) {
    mkdirSync(LOG_DIR);
  }
  if (!existsSync(TEMP_DIR)) {
    mkdirSync(TEMP_DIR);
  }
  const dbDir = path__default.join(DATA_DIR, "database");
  if (!existsSync(dbDir)) {
    mkdirSync(dbDir);
  }
  const ctx = new Context2();
  ctx.plugin(NTQQFileApi);
  ctx.plugin(NTQQFileCacheApi);
  ctx.plugin(NTQQFriendApi);
  ctx.plugin(NTQQGroupApi);
  ctx.plugin(NTQQMsgApi);
  ctx.plugin(NTQQUserApi);
  ctx.plugin(NTQQWebApi);
  ctx.plugin(NTQQSystemApi);
  ctx.plugin(src_default$1);
  ctx.logger.info(`LLOneBot ${version}`);
  const pmhqSelfInfo = await pmhq.call("getSelfInfo", []);
  const self2 = Object.assign(selfInfo, {
    uin: pmhqSelfInfo.uin,
    uid: pmhqSelfInfo.uid,
    online: true
  });
  ctx.ntUserApi.getSelfNick().then((nick) => {
    self2.nick = nick;
  }).catch((e) => ctx.logger.error("bot", e));
  const configUtil = getConfigUtil();
  const config = configUtil.getConfig();
  configUtil.listenChange((c2) => {
    ctx.parallel("llob/config-updated", c2);
  });
  setFFMpegPath(config.ffmpeg || "");
  startHook();
  ctx.plugin(Log, {
    enable: config.log,
    filename: logFileName
  });
  ctx.plugin(src_default, {
    path: path__default.join(dbDir, `${selfInfo.uin}.db`)
  });
  ctx.plugin(Store, {
    msgCacheExpire: config.msgCacheExpire * 1e3
  });
  ctx.plugin(Core, config);
  ctx.plugin(OneBot11Adapter, {
    ...config.ob11,
    onlyLocalhost: config.onlyLocalhost,
    heartInterval: config.heartInterval,
    debug: config.debug,
    musicSignUrl: config.musicSignUrl,
    enableLocalFile2Url: config.enableLocalFile2Url,
    ffmpeg: config.ffmpeg
  });
  ctx.plugin(SatoriAdapter, {
    ...config.satori,
    ffmpeg: config.ffmpeg,
    onlyLocalhost: config.onlyLocalhost
  });
  ctx.plugin(WebUIServer, { ...config.webui, onlyLocalhost: config.onlyLocalhost });
  ctx.start();
  llonebotError.otherError = "";
}
onLoad().then().catch((e) => console.log(e));
//# sourceMappingURL=llonebot.js.map
